(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r=>{
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
function fd(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var HR = {
    exports: {}
}
  , rg = {}
  , GR = {
    exports: {}
}
  , It = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dd = Symbol.for("react.element")
  , cN = Symbol.for("react.portal")
  , uN = Symbol.for("react.fragment")
  , fN = Symbol.for("react.strict_mode")
  , dN = Symbol.for("react.profiler")
  , hN = Symbol.for("react.provider")
  , pN = Symbol.for("react.context")
  , mN = Symbol.for("react.forward_ref")
  , gN = Symbol.for("react.suspense")
  , vN = Symbol.for("react.memo")
  , yN = Symbol.for("react.lazy")
  , eE = Symbol.iterator;
function _N(n) {
    return n === null || typeof n != "object" ? null : (n = eE && n[eE] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var WR = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , XR = Object.assign
  , $R = {};
function iu(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = $R,
    this.updater = t || WR
}
iu.prototype.isReactComponent = {};
iu.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
iu.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function jR() {}
jR.prototype = iu.prototype;
function lS(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = $R,
    this.updater = t || WR
}
var cS = lS.prototype = new jR;
cS.constructor = lS;
XR(cS, iu.prototype);
cS.isPureReactComponent = !0;
var tE = Array.isArray
  , YR = Object.prototype.hasOwnProperty
  , uS = {
    current: null
}
  , qR = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function KR(n, e, t) {
    var i, r = {}, s = null, o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            YR.call(e, i) && !qR.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1)
        r.children = t;
    else if (1 < a) {
        for (var l = Array(a), f = 0; f < a; f++)
            l[f] = arguments[f + 2];
        r.children = l
    }
    if (n && n.defaultProps)
        for (i in a = n.defaultProps,
        a)
            r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: dd,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: uS.current
    }
}
function xN(n, e) {
    return {
        $$typeof: dd,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function fS(n) {
    return typeof n == "object" && n !== null && n.$$typeof === dd
}
function SN(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var nE = /\/+/g;
function Iv(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? SN("" + n.key) : e.toString(36)
}
function em(n, e, t, i, r) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case dd:
            case cN:
                o = !0
            }
        }
    if (o)
        return o = n,
        r = r(o),
        n = i === "" ? "." + Iv(o, 0) : i,
        tE(r) ? (t = "",
        n != null && (t = n.replace(nE, "$&/") + "/"),
        em(r, e, t, "", function(f) {
            return f
        })) : r != null && (fS(r) && (r = xN(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(nE, "$&/") + "/") + n)),
        e.push(r)),
        1;
    if (o = 0,
    i = i === "" ? "." : i + ":",
    tE(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = i + Iv(s, a);
            o += em(s, e, t, l, r)
        }
    else if (l = _N(n),
    typeof l == "function")
        for (n = l.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            l = i + Iv(s, a++),
            o += em(s, e, t, l, r);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function zh(n, e, t) {
    if (n == null)
        return n;
    var i = []
      , r = 0;
    return em(n, i, "", "", function(s) {
        return e.call(t, s, r++)
    }),
    i
}
function wN(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var Si = {
    current: null
}
  , tm = {
    transition: null
}
  , MN = {
    ReactCurrentDispatcher: Si,
    ReactCurrentBatchConfig: tm,
    ReactCurrentOwner: uS
};
It.Children = {
    map: zh,
    forEach: function(n, e, t) {
        zh(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return zh(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return zh(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!fS(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
It.Component = iu;
It.Fragment = uN;
It.Profiler = dN;
It.PureComponent = lS;
It.StrictMode = fN;
It.Suspense = gN;
It.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = MN;
It.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var i = XR({}, n.props)
      , r = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = uS.current),
        e.key !== void 0 && (r = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (l in e)
            YR.call(e, l) && !qR.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        i.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var f = 0; f < l; f++)
            a[f] = arguments[f + 2];
        i.children = a
    }
    return {
        $$typeof: dd,
        type: n.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
}
;
It.createContext = function(n) {
    return n = {
        $$typeof: pN,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: hN,
        _context: n
    },
    n.Consumer = n
}
;
It.createElement = KR;
It.createFactory = function(n) {
    var e = KR.bind(null, n);
    return e.type = n,
    e
}
;
It.createRef = function() {
    return {
        current: null
    }
}
;
It.forwardRef = function(n) {
    return {
        $$typeof: mN,
        render: n
    }
}
;
It.isValidElement = fS;
It.lazy = function(n) {
    return {
        $$typeof: yN,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: wN
    }
}
;
It.memo = function(n, e) {
    return {
        $$typeof: vN,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
It.startTransition = function(n) {
    var e = tm.transition;
    tm.transition = {};
    try {
        n()
    } finally {
        tm.transition = e
    }
}
;
It.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
It.useCallback = function(n, e) {
    return Si.current.useCallback(n, e)
}
;
It.useContext = function(n) {
    return Si.current.useContext(n)
}
;
It.useDebugValue = function() {}
;
It.useDeferredValue = function(n) {
    return Si.current.useDeferredValue(n)
}
;
It.useEffect = function(n, e) {
    return Si.current.useEffect(n, e)
}
;
It.useId = function() {
    return Si.current.useId()
}
;
It.useImperativeHandle = function(n, e, t) {
    return Si.current.useImperativeHandle(n, e, t)
}
;
It.useInsertionEffect = function(n, e) {
    return Si.current.useInsertionEffect(n, e)
}
;
It.useLayoutEffect = function(n, e) {
    return Si.current.useLayoutEffect(n, e)
}
;
It.useMemo = function(n, e) {
    return Si.current.useMemo(n, e)
}
;
It.useReducer = function(n, e, t) {
    return Si.current.useReducer(n, e, t)
}
;
It.useRef = function(n) {
    return Si.current.useRef(n)
}
;
It.useState = function(n) {
    return Si.current.useState(n)
}
;
It.useSyncExternalStore = function(n, e, t) {
    return Si.current.useSyncExternalStore(n, e, t)
}
;
It.useTransition = function() {
    return Si.current.useTransition()
}
;
It.version = "18.2.0";
GR.exports = It;
var ke = GR.exports;
const Wt = fd(ke);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EN = ke
  , TN = Symbol.for("react.element")
  , AN = Symbol.for("react.fragment")
  , RN = Object.prototype.hasOwnProperty
  , CN = EN.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , bN = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function ZR(n, e, t) {
    var i, r = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (i in e)
        RN.call(e, i) && !bN.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps)
        for (i in e = n.defaultProps,
        e)
            r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: TN,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: CN.current
    }
}
rg.Fragment = AN;
rg.jsx = ZR;
rg.jsxs = ZR;
HR.exports = rg;
var dS = HR.exports;
const hS = dS.Fragment
  , ct = dS.jsx
  , es = dS.jsxs;
var c_ = {}
  , QR = {
    exports: {}
}
  , er = {}
  , JR = {
    exports: {}
}
  , eC = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(D, j) {
        var X = D.length;
        D.push(j);
        e: for (; 0 < X; ) {
            var ue = X - 1 >>> 1
              , I = D[ue];
            if (0 < r(I, j))
                D[ue] = j,
                D[X] = I,
                X = ue;
            else
                break e
        }
    }
    function t(D) {
        return D.length === 0 ? null : D[0]
    }
    function i(D) {
        if (D.length === 0)
            return null;
        var j = D[0]
          , X = D.pop();
        if (X !== j) {
            D[0] = X;
            e: for (var ue = 0, I = D.length, U = I >>> 1; ue < U; ) {
                var O = 2 * (ue + 1) - 1
                  , J = D[O]
                  , F = O + 1
                  , B = D[F];
                if (0 > r(J, X))
                    F < I && 0 > r(B, J) ? (D[ue] = B,
                    D[F] = X,
                    ue = F) : (D[ue] = J,
                    D[O] = X,
                    ue = O);
                else if (F < I && 0 > r(B, X))
                    D[ue] = B,
                    D[F] = X,
                    ue = F;
                else
                    break e
            }
        }
        return j
    }
    function r(D, j) {
        var X = D.sortIndex - j.sortIndex;
        return X !== 0 ? X : D.id - j.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , f = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , S = !1
      , M = typeof setTimeout == "function" ? setTimeout : null
      , g = typeof clearTimeout == "function" ? clearTimeout : null
      , _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(D) {
        for (var j = t(f); j !== null; ) {
            if (j.callback === null)
                i(f);
            else if (j.startTime <= D)
                i(f),
                j.sortIndex = j.expirationTime,
                e(l, j);
            else
                break;
            j = t(f)
        }
    }
    function T(D) {
        if (S = !1,
        w(D),
        !y)
            if (t(l) !== null)
                y = !0,
                fe(A);
            else {
                var j = t(f);
                j !== null && le(T, j.startTime - D)
            }
    }
    function A(D, j) {
        y = !1,
        S && (S = !1,
        g(N),
        N = -1),
        m = !0;
        var X = p;
        try {
            for (w(j),
            h = t(l); h !== null && (!(h.expirationTime > j) || D && !Y()); ) {
                var ue = h.callback;
                if (typeof ue == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var I = ue(h.expirationTime <= j);
                    j = n.unstable_now(),
                    typeof I == "function" ? h.callback = I : h === t(l) && i(l),
                    w(j)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var U = !0;
            else {
                var O = t(f);
                O !== null && le(T, O.startTime - j),
                U = !1
            }
            return U
        } finally {
            h = null,
            p = X,
            m = !1
        }
    }
    var C = !1
      , P = null
      , N = -1
      , b = 5
      , L = -1;
    function Y() {
        return !(n.unstable_now() - L < b)
    }
    function Z() {
        if (P !== null) {
            var D = n.unstable_now();
            L = D;
            var j = !0;
            try {
                j = P(!0, D)
            } finally {
                j ? $() : (C = !1,
                P = null)
            }
        } else
            C = !1
    }
    var $;
    if (typeof _ == "function")
        $ = function() {
            _(Z)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Q = new MessageChannel
          , ie = Q.port2;
        Q.port1.onmessage = Z,
        $ = function() {
            ie.postMessage(null)
        }
    } else
        $ = function() {
            M(Z, 0)
        }
        ;
    function fe(D) {
        P = D,
        C || (C = !0,
        $())
    }
    function le(D, j) {
        N = M(function() {
            D(n.unstable_now())
        }, j)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(D) {
        D.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        fe(A))
    }
    ,
    n.unstable_forceFrameRate = function(D) {
        0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < D ? Math.floor(1e3 / D) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(D) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var j = 3;
            break;
        default:
            j = p
        }
        var X = p;
        p = j;
        try {
            return D()
        } finally {
            p = X
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(D, j) {
        switch (D) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            D = 3
        }
        var X = p;
        p = D;
        try {
            return j()
        } finally {
            p = X
        }
    }
    ,
    n.unstable_scheduleCallback = function(D, j, X) {
        var ue = n.unstable_now();
        switch (typeof X == "object" && X !== null ? (X = X.delay,
        X = typeof X == "number" && 0 < X ? ue + X : ue) : X = ue,
        D) {
        case 1:
            var I = -1;
            break;
        case 2:
            I = 250;
            break;
        case 5:
            I = 1073741823;
            break;
        case 4:
            I = 1e4;
            break;
        default:
            I = 5e3
        }
        return I = X + I,
        D = {
            id: d++,
            callback: j,
            priorityLevel: D,
            startTime: X,
            expirationTime: I,
            sortIndex: -1
        },
        X > ue ? (D.sortIndex = X,
        e(f, D),
        t(l) === null && D === t(f) && (S ? (g(N),
        N = -1) : S = !0,
        le(T, X - ue))) : (D.sortIndex = I,
        e(l, D),
        y || m || (y = !0,
        fe(A))),
        D
    }
    ,
    n.unstable_shouldYield = Y,
    n.unstable_wrapCallback = function(D) {
        var j = p;
        return function() {
            var X = p;
            p = j;
            try {
                return D.apply(this, arguments)
            } finally {
                p = X
            }
        }
    }
}
)(eC);
JR.exports = eC;
var PN = JR.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tC = ke
  , Ji = PN;
function De(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var nC = new Set
  , kf = {};
function al(n, e) {
    Dc(n, e),
    Dc(n + "Capture", e)
}
function Dc(n, e) {
    for (kf[n] = e,
    n = 0; n < e.length; n++)
        nC.add(e[n])
}
var Zs = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , u_ = Object.prototype.hasOwnProperty
  , LN = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , iE = {}
  , rE = {};
function IN(n) {
    return u_.call(rE, n) ? !0 : u_.call(iE, n) ? !1 : LN.test(n) ? rE[n] = !0 : (iE[n] = !0,
    !1)
}
function NN(n, e, t, i) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function DN(n, e, t, i) {
    if (e === null || typeof e > "u" || NN(n, e, t, i))
        return !0;
    if (i)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function wi(n, e, t, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = i,
    this.attributeNamespace = r,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var ti = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    ti[n] = new wi(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    ti[e] = new wi(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    ti[n] = new wi(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    ti[n] = new wi(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    ti[n] = new wi(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    ti[n] = new wi(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    ti[n] = new wi(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    ti[n] = new wi(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    ti[n] = new wi(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var pS = /[\-:]([a-z])/g;
function mS(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(pS, mS);
    ti[e] = new wi(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(pS, mS);
    ti[e] = new wi(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(pS, mS);
    ti[e] = new wi(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    ti[n] = new wi(n,1,!1,n.toLowerCase(),null,!1,!1)
});
ti.xlinkHref = new wi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    ti[n] = new wi(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function gS(n, e, t, i) {
    var r = ti.hasOwnProperty(e) ? ti[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (DN(e, t, r, i) && (t = null),
    i || r === null ? IN(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName,
    i = r.attributeNamespace,
    t === null ? n.removeAttribute(e) : (r = r.type,
    t = r === 3 || r === 4 && t === !0 ? "" : "" + t,
    i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))))
}
var io = tC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Bh = Symbol.for("react.element")
  , sc = Symbol.for("react.portal")
  , oc = Symbol.for("react.fragment")
  , vS = Symbol.for("react.strict_mode")
  , f_ = Symbol.for("react.profiler")
  , iC = Symbol.for("react.provider")
  , rC = Symbol.for("react.context")
  , yS = Symbol.for("react.forward_ref")
  , d_ = Symbol.for("react.suspense")
  , h_ = Symbol.for("react.suspense_list")
  , _S = Symbol.for("react.memo")
  , Ao = Symbol.for("react.lazy")
  , sC = Symbol.for("react.offscreen")
  , sE = Symbol.iterator;
function ku(n) {
    return n === null || typeof n != "object" ? null : (n = sE && n[sE] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var mn = Object.assign, Nv;
function uf(n) {
    if (Nv === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            Nv = e && e[1] || ""
        }
    return `
` + Nv + n
}
var Dv = !1;
function Uv(n, e) {
    if (!n || Dv)
        return "";
    Dv = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (f) {
                    var i = f
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (f) {
                    i = f
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (f) {
                i = f
            }
            n()
        }
    } catch (f) {
        if (f && i && typeof f.stack == "string") {
            for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Dv = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? uf(n) : ""
}
function UN(n) {
    switch (n.tag) {
    case 5:
        return uf(n.type);
    case 16:
        return uf("Lazy");
    case 13:
        return uf("Suspense");
    case 19:
        return uf("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = Uv(n.type, !1),
        n;
    case 11:
        return n = Uv(n.type.render, !1),
        n;
    case 1:
        return n = Uv(n.type, !0),
        n;
    default:
        return ""
    }
}
function p_(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case oc:
        return "Fragment";
    case sc:
        return "Portal";
    case f_:
        return "Profiler";
    case vS:
        return "StrictMode";
    case d_:
        return "Suspense";
    case h_:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case rC:
            return (n.displayName || "Context") + ".Consumer";
        case iC:
            return (n._context.displayName || "Context") + ".Provider";
        case yS:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case _S:
            return e = n.displayName || null,
            e !== null ? e : p_(n.type) || "Memo";
        case Ao:
            e = n._payload,
            n = n._init;
            try {
                return p_(n(e))
            } catch {}
        }
    return null
}
function kN(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return p_(e);
    case 8:
        return e === vS ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function qo(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function oC(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function ON(n) {
    var e = oC(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , i = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function Vh(n) {
    n._valueTracker || (n._valueTracker = ON(n))
}
function aC(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , i = "";
    return n && (i = oC(n) ? n.checked ? "true" : "false" : n.value),
    n = i,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function wm(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function m_(n, e) {
    var t = e.checked;
    return mn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function oE(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , i = e.checked != null ? e.checked : e.defaultChecked;
    t = qo(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: i,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function lC(n, e) {
    e = e.checked,
    e != null && gS(n, "checked", e, !1)
}
function g_(n, e) {
    lC(n, e);
    var t = qo(e.value)
      , i = e.type;
    if (t != null)
        i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (i === "submit" || i === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? v_(n, e.type, t) : e.hasOwnProperty("defaultValue") && v_(n, e.type, qo(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function aE(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function v_(n, e, t) {
    (e !== "number" || wm(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var ff = Array.isArray;
function wc(n, e, t, i) {
    if (n = n.options,
    e) {
        e = {};
        for (var r = 0; r < t.length; r++)
            e["$" + t[r]] = !0;
        for (t = 0; t < n.length; t++)
            r = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== r && (n[t].selected = r),
            r && i && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + qo(t),
        e = null,
        r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                n[r].selected = !0,
                i && (n[r].defaultSelected = !0);
                return
            }
            e !== null || n[r].disabled || (e = n[r])
        }
        e !== null && (e.selected = !0)
    }
}
function y_(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(De(91));
    return mn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function lE(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(De(92));
            if (ff(t)) {
                if (1 < t.length)
                    throw Error(De(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: qo(t)
    }
}
function cC(n, e) {
    var t = qo(e.value)
      , i = qo(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i)
}
function cE(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function uC(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function __(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? uC(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Hh, fC = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, i, r)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (Hh = Hh || document.createElement("div"),
        Hh.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Hh.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function Of(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var vf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , FN = ["Webkit", "ms", "Moz", "O"];
Object.keys(vf).forEach(function(n) {
    FN.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        vf[e] = vf[n]
    })
});
function dC(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || vf.hasOwnProperty(n) && vf[n] ? ("" + e).trim() : e + "px"
}
function hC(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf("--") === 0
              , r = dC(t, e[t], i);
            t === "float" && (t = "cssFloat"),
            i ? n.setProperty(t, r) : n[t] = r
        }
}
var zN = mn({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function x_(n, e) {
    if (e) {
        if (zN[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(De(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(De(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(De(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(De(62))
    }
}
function S_(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var w_ = null;
function xS(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var M_ = null
  , Mc = null
  , Ec = null;
function uE(n) {
    if (n = md(n)) {
        if (typeof M_ != "function")
            throw Error(De(280));
        var e = n.stateNode;
        e && (e = cg(e),
        M_(n.stateNode, n.type, e))
    }
}
function pC(n) {
    Mc ? Ec ? Ec.push(n) : Ec = [n] : Mc = n
}
function mC() {
    if (Mc) {
        var n = Mc
          , e = Ec;
        if (Ec = Mc = null,
        uE(n),
        e)
            for (n = 0; n < e.length; n++)
                uE(e[n])
    }
}
function gC(n, e) {
    return n(e)
}
function vC() {}
var kv = !1;
function yC(n, e, t) {
    if (kv)
        return n(e, t);
    kv = !0;
    try {
        return gC(n, e, t)
    } finally {
        kv = !1,
        (Mc !== null || Ec !== null) && (vC(),
        mC())
    }
}
function Ff(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var i = cg(t);
    if (i === null)
        return null;
    t = i[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (i = !i.disabled) || (n = n.type,
        i = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !i;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(De(231, e, typeof t));
    return t
}
var E_ = !1;
if (Zs)
    try {
        var Ou = {};
        Object.defineProperty(Ou, "passive", {
            get: function() {
                E_ = !0
            }
        }),
        window.addEventListener("test", Ou, Ou),
        window.removeEventListener("test", Ou, Ou)
    } catch {
        E_ = !1
    }
function BN(n, e, t, i, r, s, o, a, l) {
    var f = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, f)
    } catch (d) {
        this.onError(d)
    }
}
var yf = !1
  , Mm = null
  , Em = !1
  , T_ = null
  , VN = {
    onError: function(n) {
        yf = !0,
        Mm = n
    }
};
function HN(n, e, t, i, r, s, o, a, l) {
    yf = !1,
    Mm = null,
    BN.apply(VN, arguments)
}
function GN(n, e, t, i, r, s, o, a, l) {
    if (HN.apply(this, arguments),
    yf) {
        if (yf) {
            var f = Mm;
            yf = !1,
            Mm = null
        } else
            throw Error(De(198));
        Em || (Em = !0,
        T_ = f)
    }
}
function ll(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function _C(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function fE(n) {
    if (ll(n) !== n)
        throw Error(De(188))
}
function WN(n) {
    var e = n.alternate;
    if (!e) {
        if (e = ll(n),
        e === null)
            throw Error(De(188));
        return e !== n ? null : n
    }
    for (var t = n, i = e; ; ) {
        var r = t.return;
        if (r === null)
            break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return,
            i !== null) {
                t = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s; ) {
                if (s === t)
                    return fE(r),
                    n;
                if (s === i)
                    return fE(r),
                    e;
                s = s.sibling
            }
            throw Error(De(188))
        }
        if (t.return !== i.return)
            t = r,
            i = s;
        else {
            for (var o = !1, a = r.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = r,
                    i = s;
                    break
                }
                if (a === i) {
                    o = !0,
                    i = r,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        i = r;
                        break
                    }
                    if (a === i) {
                        o = !0,
                        i = s,
                        t = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(De(189))
            }
        }
        if (t.alternate !== i)
            throw Error(De(190))
    }
    if (t.tag !== 3)
        throw Error(De(188));
    return t.stateNode.current === t ? n : e
}
function xC(n) {
    return n = WN(n),
    n !== null ? SC(n) : null
}
function SC(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = SC(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var wC = Ji.unstable_scheduleCallback
  , dE = Ji.unstable_cancelCallback
  , XN = Ji.unstable_shouldYield
  , $N = Ji.unstable_requestPaint
  , En = Ji.unstable_now
  , jN = Ji.unstable_getCurrentPriorityLevel
  , SS = Ji.unstable_ImmediatePriority
  , MC = Ji.unstable_UserBlockingPriority
  , Tm = Ji.unstable_NormalPriority
  , YN = Ji.unstable_LowPriority
  , EC = Ji.unstable_IdlePriority
  , sg = null
  , _s = null;
function qN(n) {
    if (_s && typeof _s.onCommitFiberRoot == "function")
        try {
            _s.onCommitFiberRoot(sg, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var jr = Math.clz32 ? Math.clz32 : QN
  , KN = Math.log
  , ZN = Math.LN2;
function QN(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (KN(n) / ZN | 0) | 0
}
var Gh = 64
  , Wh = 4194304;
function df(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function Am(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var i = 0
      , r = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = df(a) : (s &= o,
        s !== 0 && (i = df(s)))
    } else
        o = t & ~r,
        o !== 0 ? i = df(o) : s !== 0 && (i = df(s));
    if (i === 0)
        return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i,
    s = e & -e,
    r >= s || r === 16 && (s & 4194240) !== 0))
        return e;
    if (i & 4 && (i |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= i; 0 < e; )
            t = 31 - jr(e),
            r = 1 << t,
            i |= n[t],
            e &= ~r;
    return i
}
function JN(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function eD(n, e) {
    for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - jr(s)
          , a = 1 << o
          , l = r[o];
        l === -1 ? (!(a & t) || a & i) && (r[o] = JN(a, e)) : l <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function A_(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function TC() {
    var n = Gh;
    return Gh <<= 1,
    !(Gh & 4194240) && (Gh = 64),
    n
}
function Ov(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function hd(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - jr(e),
    n[e] = t
}
function tD(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var r = 31 - jr(t)
          , s = 1 << r;
        e[r] = 0,
        i[r] = -1,
        n[r] = -1,
        t &= ~s
    }
}
function wS(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var i = 31 - jr(t)
          , r = 1 << i;
        r & e | n[i] & e && (n[i] |= e),
        t &= ~r
    }
}
var Xt = 0;
function AC(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var RC, MS, CC, bC, PC, R_ = !1, Xh = [], Oo = null, Fo = null, zo = null, zf = new Map, Bf = new Map, Lo = [], nD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function hE(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        Oo = null;
        break;
    case "dragenter":
    case "dragleave":
        Fo = null;
        break;
    case "mouseover":
    case "mouseout":
        zo = null;
        break;
    case "pointerover":
    case "pointerout":
        zf.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Bf.delete(e.pointerId)
    }
}
function Fu(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    },
    e !== null && (e = md(e),
    e !== null && MS(e)),
    n) : (n.eventSystemFlags |= i,
    e = n.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    n)
}
function iD(n, e, t, i, r) {
    switch (e) {
    case "focusin":
        return Oo = Fu(Oo, n, e, t, i, r),
        !0;
    case "dragenter":
        return Fo = Fu(Fo, n, e, t, i, r),
        !0;
    case "mouseover":
        return zo = Fu(zo, n, e, t, i, r),
        !0;
    case "pointerover":
        var s = r.pointerId;
        return zf.set(s, Fu(zf.get(s) || null, n, e, t, i, r)),
        !0;
    case "gotpointercapture":
        return s = r.pointerId,
        Bf.set(s, Fu(Bf.get(s) || null, n, e, t, i, r)),
        !0
    }
    return !1
}
function LC(n) {
    var e = Ia(n.target);
    if (e !== null) {
        var t = ll(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = _C(t),
                e !== null) {
                    n.blockedOn = e,
                    PC(n.priority, function() {
                        CC(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function nm(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = C_(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type,t);
            w_ = i,
            t.target.dispatchEvent(i),
            w_ = null
        } else
            return e = md(t),
            e !== null && MS(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function pE(n, e, t) {
    nm(n) && t.delete(e)
}
function rD() {
    R_ = !1,
    Oo !== null && nm(Oo) && (Oo = null),
    Fo !== null && nm(Fo) && (Fo = null),
    zo !== null && nm(zo) && (zo = null),
    zf.forEach(pE),
    Bf.forEach(pE)
}
function zu(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    R_ || (R_ = !0,
    Ji.unstable_scheduleCallback(Ji.unstable_NormalPriority, rD)))
}
function Vf(n) {
    function e(r) {
        return zu(r, n)
    }
    if (0 < Xh.length) {
        zu(Xh[0], n);
        for (var t = 1; t < Xh.length; t++) {
            var i = Xh[t];
            i.blockedOn === n && (i.blockedOn = null)
        }
    }
    for (Oo !== null && zu(Oo, n),
    Fo !== null && zu(Fo, n),
    zo !== null && zu(zo, n),
    zf.forEach(e),
    Bf.forEach(e),
    t = 0; t < Lo.length; t++)
        i = Lo[t],
        i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < Lo.length && (t = Lo[0],
    t.blockedOn === null); )
        LC(t),
        t.blockedOn === null && Lo.shift()
}
var Tc = io.ReactCurrentBatchConfig
  , Rm = !0;
function sD(n, e, t, i) {
    var r = Xt
      , s = Tc.transition;
    Tc.transition = null;
    try {
        Xt = 1,
        ES(n, e, t, i)
    } finally {
        Xt = r,
        Tc.transition = s
    }
}
function oD(n, e, t, i) {
    var r = Xt
      , s = Tc.transition;
    Tc.transition = null;
    try {
        Xt = 4,
        ES(n, e, t, i)
    } finally {
        Xt = r,
        Tc.transition = s
    }
}
function ES(n, e, t, i) {
    if (Rm) {
        var r = C_(n, e, t, i);
        if (r === null)
            jv(n, e, i, Cm, t),
            hE(n, i);
        else if (iD(r, n, e, t, i))
            i.stopPropagation();
        else if (hE(n, i),
        e & 4 && -1 < nD.indexOf(n)) {
            for (; r !== null; ) {
                var s = md(r);
                if (s !== null && RC(s),
                s = C_(n, e, t, i),
                s === null && jv(n, e, i, Cm, t),
                s === r)
                    break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else
            jv(n, e, i, null, t)
    }
}
var Cm = null;
function C_(n, e, t, i) {
    if (Cm = null,
    n = xS(i),
    n = Ia(n),
    n !== null)
        if (e = ll(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = _C(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return Cm = n,
    null
}
function IC(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (jN()) {
        case SS:
            return 1;
        case MC:
            return 4;
        case Tm:
        case YN:
            return 16;
        case EC:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var No = null
  , TS = null
  , im = null;
function NC() {
    if (im)
        return im;
    var n, e = TS, t = e.length, i, r = "value"in No ? No.value : No.textContent, s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++)
        ;
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++)
        ;
    return im = r.slice(n, 1 < i ? 1 - i : void 0)
}
function rm(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function $h() {
    return !0
}
function mE() {
    return !1
}
function tr(n) {
    function e(t, i, r, s, o) {
        this._reactName = t,
        this._targetInst = r,
        this.type = i,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? $h : mE,
        this.isPropagationStopped = mE,
        this
    }
    return mn(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = $h)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = $h)
        },
        persist: function() {},
        isPersistent: $h
    }),
    e
}
var ru = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, AS = tr(ru), pd = mn({}, ru, {
    view: 0,
    detail: 0
}), aD = tr(pd), Fv, zv, Bu, og = mn({}, pd, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: RS,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== Bu && (Bu && n.type === "mousemove" ? (Fv = n.screenX - Bu.screenX,
        zv = n.screenY - Bu.screenY) : zv = Fv = 0,
        Bu = n),
        Fv)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : zv
    }
}), gE = tr(og), lD = mn({}, og, {
    dataTransfer: 0
}), cD = tr(lD), uD = mn({}, pd, {
    relatedTarget: 0
}), Bv = tr(uD), fD = mn({}, ru, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), dD = tr(fD), hD = mn({}, ru, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), pD = tr(hD), mD = mn({}, ru, {
    data: 0
}), vE = tr(mD), gD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, vD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, yD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function _D(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = yD[n]) ? !!e[n] : !1
}
function RS() {
    return _D
}
var xD = mn({}, pd, {
    key: function(n) {
        if (n.key) {
            var e = gD[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = rm(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? vD[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: RS,
    charCode: function(n) {
        return n.type === "keypress" ? rm(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? rm(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , SD = tr(xD)
  , wD = mn({}, og, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , yE = tr(wD)
  , MD = mn({}, pd, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: RS
})
  , ED = tr(MD)
  , TD = mn({}, ru, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , AD = tr(TD)
  , RD = mn({}, og, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , CD = tr(RD)
  , bD = [9, 13, 27, 32]
  , CS = Zs && "CompositionEvent"in window
  , _f = null;
Zs && "documentMode"in document && (_f = document.documentMode);
var PD = Zs && "TextEvent"in window && !_f
  , DC = Zs && (!CS || _f && 8 < _f && 11 >= _f)
  , _E = String.fromCharCode(32)
  , xE = !1;
function UC(n, e) {
    switch (n) {
    case "keyup":
        return bD.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function kC(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var ac = !1;
function LD(n, e) {
    switch (n) {
    case "compositionend":
        return kC(e);
    case "keypress":
        return e.which !== 32 ? null : (xE = !0,
        _E);
    case "textInput":
        return n = e.data,
        n === _E && xE ? null : n;
    default:
        return null
    }
}
function ID(n, e) {
    if (ac)
        return n === "compositionend" || !CS && UC(n, e) ? (n = NC(),
        im = TS = No = null,
        ac = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return DC && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var ND = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function SE(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!ND[n.type] : e === "textarea"
}
function OC(n, e, t, i) {
    pC(i),
    e = bm(e, "onChange"),
    0 < e.length && (t = new AS("onChange","change",null,t,i),
    n.push({
        event: t,
        listeners: e
    }))
}
var xf = null
  , Hf = null;
function DD(n) {
    YC(n, 0)
}
function ag(n) {
    var e = uc(n);
    if (aC(e))
        return n
}
function UD(n, e) {
    if (n === "change")
        return e
}
var FC = !1;
if (Zs) {
    var Vv;
    if (Zs) {
        var Hv = "oninput"in document;
        if (!Hv) {
            var wE = document.createElement("div");
            wE.setAttribute("oninput", "return;"),
            Hv = typeof wE.oninput == "function"
        }
        Vv = Hv
    } else
        Vv = !1;
    FC = Vv && (!document.documentMode || 9 < document.documentMode)
}
function ME() {
    xf && (xf.detachEvent("onpropertychange", zC),
    Hf = xf = null)
}
function zC(n) {
    if (n.propertyName === "value" && ag(Hf)) {
        var e = [];
        OC(e, Hf, n, xS(n)),
        yC(DD, e)
    }
}
function kD(n, e, t) {
    n === "focusin" ? (ME(),
    xf = e,
    Hf = t,
    xf.attachEvent("onpropertychange", zC)) : n === "focusout" && ME()
}
function OD(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return ag(Hf)
}
function FD(n, e) {
    if (n === "click")
        return ag(e)
}
function zD(n, e) {
    if (n === "input" || n === "change")
        return ag(e)
}
function BD(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var Kr = typeof Object.is == "function" ? Object.is : BD;
function Gf(n, e) {
    if (Kr(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , i = Object.keys(e);
    if (t.length !== i.length)
        return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!u_.call(e, r) || !Kr(n[r], e[r]))
            return !1
    }
    return !0
}
function EE(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function TE(n, e) {
    var t = EE(n);
    n = 0;
    for (var i; t; ) {
        if (t.nodeType === 3) {
            if (i = n + t.textContent.length,
            n <= e && i >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = i
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = EE(t)
    }
}
function BC(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? BC(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function VC() {
    for (var n = window, e = wm(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = wm(n.document)
    }
    return e
}
function bS(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function VD(n) {
    var e = VC()
      , t = n.focusedElem
      , i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && BC(t.ownerDocument.documentElement, t)) {
        if (i !== null && bS(t)) {
            if (e = i.start,
            n = i.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var r = t.textContent.length
                  , s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r),
                !n.extend && s > i && (r = i,
                i = s,
                s = r),
                r = TE(t, s);
                var o = TE(t, i);
                r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                n.removeAllRanges(),
                s > i ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var HD = Zs && "documentMode"in document && 11 >= document.documentMode
  , lc = null
  , b_ = null
  , Sf = null
  , P_ = !1;
function AE(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    P_ || lc == null || lc !== wm(i) || (i = lc,
    "selectionStart"in i && bS(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(),
    i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }),
    Sf && Gf(Sf, i) || (Sf = i,
    i = bm(b_, "onSelect"),
    0 < i.length && (e = new AS("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: i
    }),
    e.target = lc)))
}
function jh(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var cc = {
    animationend: jh("Animation", "AnimationEnd"),
    animationiteration: jh("Animation", "AnimationIteration"),
    animationstart: jh("Animation", "AnimationStart"),
    transitionend: jh("Transition", "TransitionEnd")
}
  , Gv = {}
  , HC = {};
Zs && (HC = document.createElement("div").style,
"AnimationEvent"in window || (delete cc.animationend.animation,
delete cc.animationiteration.animation,
delete cc.animationstart.animation),
"TransitionEvent"in window || delete cc.transitionend.transition);
function lg(n) {
    if (Gv[n])
        return Gv[n];
    if (!cc[n])
        return n;
    var e = cc[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in HC)
            return Gv[n] = e[t];
    return n
}
var GC = lg("animationend")
  , WC = lg("animationiteration")
  , XC = lg("animationstart")
  , $C = lg("transitionend")
  , jC = new Map
  , RE = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ea(n, e) {
    jC.set(n, e),
    al(e, [n])
}
for (var Wv = 0; Wv < RE.length; Wv++) {
    var Xv = RE[Wv]
      , GD = Xv.toLowerCase()
      , WD = Xv[0].toUpperCase() + Xv.slice(1);
    ea(GD, "on" + WD)
}
ea(GC, "onAnimationEnd");
ea(WC, "onAnimationIteration");
ea(XC, "onAnimationStart");
ea("dblclick", "onDoubleClick");
ea("focusin", "onFocus");
ea("focusout", "onBlur");
ea($C, "onTransitionEnd");
Dc("onMouseEnter", ["mouseout", "mouseover"]);
Dc("onMouseLeave", ["mouseout", "mouseover"]);
Dc("onPointerEnter", ["pointerout", "pointerover"]);
Dc("onPointerLeave", ["pointerout", "pointerover"]);
al("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
al("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
al("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
al("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
al("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
al("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var hf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , XD = new Set("cancel close invalid load scroll toggle".split(" ").concat(hf));
function CE(n, e, t) {
    var i = n.type || "unknown-event";
    n.currentTarget = t,
    GN(i, e, void 0, n),
    n.currentTarget = null
}
function YC(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t]
          , r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o]
                      , l = a.instance
                      , f = a.currentTarget;
                    if (a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    CE(r, a, f),
                    s = l
                }
            else
                for (o = 0; o < i.length; o++) {
                    if (a = i[o],
                    l = a.instance,
                    f = a.currentTarget,
                    a = a.listener,
                    l !== s && r.isPropagationStopped())
                        break e;
                    CE(r, a, f),
                    s = l
                }
        }
    }
    if (Em)
        throw n = T_,
        Em = !1,
        T_ = null,
        n
}
function tn(n, e) {
    var t = e[U_];
    t === void 0 && (t = e[U_] = new Set);
    var i = n + "__bubble";
    t.has(i) || (qC(e, n, 2, !1),
    t.add(i))
}
function $v(n, e, t) {
    var i = 0;
    e && (i |= 4),
    qC(t, n, i, e)
}
var Yh = "_reactListening" + Math.random().toString(36).slice(2);
function Wf(n) {
    if (!n[Yh]) {
        n[Yh] = !0,
        nC.forEach(function(t) {
            t !== "selectionchange" && (XD.has(t) || $v(t, !1, n),
            $v(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[Yh] || (e[Yh] = !0,
        $v("selectionchange", !1, e))
    }
}
function qC(n, e, t, i) {
    switch (IC(e)) {
    case 1:
        var r = sD;
        break;
    case 4:
        r = oD;
        break;
    default:
        r = ES
    }
    t = r.bind(null, e, t, n),
    r = void 0,
    !E_ || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    i ? r !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, {
        passive: r
    }) : n.addEventListener(e, t, !1)
}
function jv(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null)
        e: for (; ; ) {
            if (i === null)
                return;
            var o = i.tag;
            if (o === 3 || o === 4) {
                var a = i.stateNode.containerInfo;
                if (a === r || a.nodeType === 8 && a.parentNode === r)
                    break;
                if (o === 4)
                    for (o = i.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = Ia(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        i = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            i = i.return
        }
    yC(function() {
        var f = s
          , d = xS(t)
          , h = [];
        e: {
            var p = jC.get(n);
            if (p !== void 0) {
                var m = AS
                  , y = n;
                switch (n) {
                case "keypress":
                    if (rm(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    m = SD;
                    break;
                case "focusin":
                    y = "focus",
                    m = Bv;
                    break;
                case "focusout":
                    y = "blur",
                    m = Bv;
                    break;
                case "beforeblur":
                case "afterblur":
                    m = Bv;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    m = gE;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    m = cD;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    m = ED;
                    break;
                case GC:
                case WC:
                case XC:
                    m = dD;
                    break;
                case $C:
                    m = AD;
                    break;
                case "scroll":
                    m = aD;
                    break;
                case "wheel":
                    m = CD;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    m = pD;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    m = yE
                }
                var S = (e & 4) !== 0
                  , M = !S && n === "scroll"
                  , g = S ? p !== null ? p + "Capture" : null : p;
                S = [];
                for (var _ = f, w; _ !== null; ) {
                    w = _;
                    var T = w.stateNode;
                    if (w.tag === 5 && T !== null && (w = T,
                    g !== null && (T = Ff(_, g),
                    T != null && S.push(Xf(_, T, w)))),
                    M)
                        break;
                    _ = _.return
                }
                0 < S.length && (p = new m(p,y,null,t,d),
                h.push({
                    event: p,
                    listeners: S
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = n === "mouseover" || n === "pointerover",
                m = n === "mouseout" || n === "pointerout",
                p && t !== w_ && (y = t.relatedTarget || t.fromElement) && (Ia(y) || y[Qs]))
                    break e;
                if ((m || p) && (p = d.window === d ? d : (p = d.ownerDocument) ? p.defaultView || p.parentWindow : window,
                m ? (y = t.relatedTarget || t.toElement,
                m = f,
                y = y ? Ia(y) : null,
                y !== null && (M = ll(y),
                y !== M || y.tag !== 5 && y.tag !== 6) && (y = null)) : (m = null,
                y = f),
                m !== y)) {
                    if (S = gE,
                    T = "onMouseLeave",
                    g = "onMouseEnter",
                    _ = "mouse",
                    (n === "pointerout" || n === "pointerover") && (S = yE,
                    T = "onPointerLeave",
                    g = "onPointerEnter",
                    _ = "pointer"),
                    M = m == null ? p : uc(m),
                    w = y == null ? p : uc(y),
                    p = new S(T,_ + "leave",m,t,d),
                    p.target = M,
                    p.relatedTarget = w,
                    T = null,
                    Ia(d) === f && (S = new S(g,_ + "enter",y,t,d),
                    S.target = w,
                    S.relatedTarget = M,
                    T = S),
                    M = T,
                    m && y)
                        t: {
                            for (S = m,
                            g = y,
                            _ = 0,
                            w = S; w; w = Pl(w))
                                _++;
                            for (w = 0,
                            T = g; T; T = Pl(T))
                                w++;
                            for (; 0 < _ - w; )
                                S = Pl(S),
                                _--;
                            for (; 0 < w - _; )
                                g = Pl(g),
                                w--;
                            for (; _--; ) {
                                if (S === g || g !== null && S === g.alternate)
                                    break t;
                                S = Pl(S),
                                g = Pl(g)
                            }
                            S = null
                        }
                    else
                        S = null;
                    m !== null && bE(h, p, m, S, !1),
                    y !== null && M !== null && bE(h, M, y, S, !0)
                }
            }
            e: {
                if (p = f ? uc(f) : window,
                m = p.nodeName && p.nodeName.toLowerCase(),
                m === "select" || m === "input" && p.type === "file")
                    var A = UD;
                else if (SE(p))
                    if (FC)
                        A = zD;
                    else {
                        A = OD;
                        var C = kD
                    }
                else
                    (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (A = FD);
                if (A && (A = A(n, f))) {
                    OC(h, A, t, d);
                    break e
                }
                C && C(n, p, f),
                n === "focusout" && (C = p._wrapperState) && C.controlled && p.type === "number" && v_(p, "number", p.value)
            }
            switch (C = f ? uc(f) : window,
            n) {
            case "focusin":
                (SE(C) || C.contentEditable === "true") && (lc = C,
                b_ = f,
                Sf = null);
                break;
            case "focusout":
                Sf = b_ = lc = null;
                break;
            case "mousedown":
                P_ = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                P_ = !1,
                AE(h, t, d);
                break;
            case "selectionchange":
                if (HD)
                    break;
            case "keydown":
            case "keyup":
                AE(h, t, d)
            }
            var P;
            if (CS)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var N = "onCompositionStart";
                        break e;
                    case "compositionend":
                        N = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        N = "onCompositionUpdate";
                        break e
                    }
                    N = void 0
                }
            else
                ac ? UC(n, t) && (N = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (N = "onCompositionStart");
            N && (DC && t.locale !== "ko" && (ac || N !== "onCompositionStart" ? N === "onCompositionEnd" && ac && (P = NC()) : (No = d,
            TS = "value"in No ? No.value : No.textContent,
            ac = !0)),
            C = bm(f, N),
            0 < C.length && (N = new vE(N,n,null,t,d),
            h.push({
                event: N,
                listeners: C
            }),
            P ? N.data = P : (P = kC(t),
            P !== null && (N.data = P)))),
            (P = PD ? LD(n, t) : ID(n, t)) && (f = bm(f, "onBeforeInput"),
            0 < f.length && (d = new vE("onBeforeInput","beforeinput",null,t,d),
            h.push({
                event: d,
                listeners: f
            }),
            d.data = P))
        }
        YC(h, e)
    })
}
function Xf(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function bm(n, e) {
    for (var t = e + "Capture", i = []; n !== null; ) {
        var r = n
          , s = r.stateNode;
        r.tag === 5 && s !== null && (r = s,
        s = Ff(n, t),
        s != null && i.unshift(Xf(n, s, r)),
        s = Ff(n, e),
        s != null && i.push(Xf(n, s, r))),
        n = n.return
    }
    return i
}
function Pl(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function bE(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i; ) {
        var a = t
          , l = a.alternate
          , f = a.stateNode;
        if (l !== null && l === i)
            break;
        a.tag === 5 && f !== null && (a = f,
        r ? (l = Ff(t, s),
        l != null && o.unshift(Xf(t, l, a))) : r || (l = Ff(t, s),
        l != null && o.push(Xf(t, l, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var $D = /\r\n?/g
  , jD = /\u0000|\uFFFD/g;
function PE(n) {
    return (typeof n == "string" ? n : "" + n).replace($D, `
`).replace(jD, "")
}
function qh(n, e, t) {
    if (e = PE(e),
    PE(n) !== e && t)
        throw Error(De(425))
}
function Pm() {}
var L_ = null
  , I_ = null;
function N_(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var D_ = typeof setTimeout == "function" ? setTimeout : void 0
  , YD = typeof clearTimeout == "function" ? clearTimeout : void 0
  , LE = typeof Promise == "function" ? Promise : void 0
  , qD = typeof queueMicrotask == "function" ? queueMicrotask : typeof LE < "u" ? function(n) {
    return LE.resolve(null).then(n).catch(KD)
}
: D_;
function KD(n) {
    setTimeout(function() {
        throw n
    })
}
function Yv(n, e) {
    var t = e
      , i = 0;
    do {
        var r = t.nextSibling;
        if (n.removeChild(t),
        r && r.nodeType === 8)
            if (t = r.data,
            t === "/$") {
                if (i === 0) {
                    n.removeChild(r),
                    Vf(e);
                    return
                }
                i--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || i++;
        t = r
    } while (t);
    Vf(e)
}
function Bo(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function IE(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var su = Math.random().toString(36).slice(2)
  , ys = "__reactFiber$" + su
  , $f = "__reactProps$" + su
  , Qs = "__reactContainer$" + su
  , U_ = "__reactEvents$" + su
  , ZD = "__reactListeners$" + su
  , QD = "__reactHandles$" + su;
function Ia(n) {
    var e = n[ys];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Qs] || t[ys]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = IE(n); n !== null; ) {
                    if (t = n[ys])
                        return t;
                    n = IE(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function md(n) {
    return n = n[ys] || n[Qs],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function uc(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(De(33))
}
function cg(n) {
    return n[$f] || null
}
var k_ = []
  , fc = -1;
function ta(n) {
    return {
        current: n
    }
}
function on(n) {
    0 > fc || (n.current = k_[fc],
    k_[fc] = null,
    fc--)
}
function Jt(n, e) {
    fc++,
    k_[fc] = n.current,
    n.current = e
}
var Ko = {}
  , pi = ta(Ko)
  , Di = ta(!1)
  , $a = Ko;
function Uc(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return Ko;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
        return i.__reactInternalMemoizedMaskedChildContext;
    var r = {}, s;
    for (s in t)
        r[s] = e[s];
    return i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function Ui(n) {
    return n = n.childContextTypes,
    n != null
}
function Lm() {
    on(Di),
    on(pi)
}
function NE(n, e, t) {
    if (pi.current !== Ko)
        throw Error(De(168));
    Jt(pi, e),
    Jt(Di, t)
}
function KC(n, e, t) {
    var i = n.stateNode;
    if (e = e.childContextTypes,
    typeof i.getChildContext != "function")
        return t;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e))
            throw Error(De(108, kN(n) || "Unknown", r));
    return mn({}, t, i)
}
function Im(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Ko,
    $a = pi.current,
    Jt(pi, n),
    Jt(Di, Di.current),
    !0
}
function DE(n, e, t) {
    var i = n.stateNode;
    if (!i)
        throw Error(De(169));
    t ? (n = KC(n, e, $a),
    i.__reactInternalMemoizedMergedChildContext = n,
    on(Di),
    on(pi),
    Jt(pi, n)) : on(Di),
    Jt(Di, t)
}
var Hs = null
  , ug = !1
  , qv = !1;
function ZC(n) {
    Hs === null ? Hs = [n] : Hs.push(n)
}
function JD(n) {
    ug = !0,
    ZC(n)
}
function na() {
    if (!qv && Hs !== null) {
        qv = !0;
        var n = 0
          , e = Xt;
        try {
            var t = Hs;
            for (Xt = 1; n < t.length; n++) {
                var i = t[n];
                do
                    i = i(!0);
                while (i !== null)
            }
            Hs = null,
            ug = !1
        } catch (r) {
            throw Hs !== null && (Hs = Hs.slice(n + 1)),
            wC(SS, na),
            r
        } finally {
            Xt = e,
            qv = !1
        }
    }
    return null
}
var dc = []
  , hc = 0
  , Nm = null
  , Dm = 0
  , mr = []
  , gr = 0
  , ja = null
  , Xs = 1
  , $s = "";
function Aa(n, e) {
    dc[hc++] = Dm,
    dc[hc++] = Nm,
    Nm = n,
    Dm = e
}
function QC(n, e, t) {
    mr[gr++] = Xs,
    mr[gr++] = $s,
    mr[gr++] = ja,
    ja = n;
    var i = Xs;
    n = $s;
    var r = 32 - jr(i) - 1;
    i &= ~(1 << r),
    t += 1;
    var s = 32 - jr(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32),
        i >>= o,
        r -= o,
        Xs = 1 << 32 - jr(e) + r | t << r | i,
        $s = s + n
    } else
        Xs = 1 << s | t << r | i,
        $s = n
}
function PS(n) {
    n.return !== null && (Aa(n, 1),
    QC(n, 1, 0))
}
function LS(n) {
    for (; n === Nm; )
        Nm = dc[--hc],
        dc[hc] = null,
        Dm = dc[--hc],
        dc[hc] = null;
    for (; n === ja; )
        ja = mr[--gr],
        mr[gr] = null,
        $s = mr[--gr],
        mr[gr] = null,
        Xs = mr[--gr],
        mr[gr] = null
}
var Zi = null
  , ji = null
  , ln = !1
  , Wr = null;
function JC(n, e) {
    var t = _r(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function UE(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        Zi = n,
        ji = Bo(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        Zi = n,
        ji = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = ja !== null ? {
            id: Xs,
            overflow: $s
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = _r(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        Zi = n,
        ji = null,
        !0) : !1;
    default:
        return !1
    }
}
function O_(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function F_(n) {
    if (ln) {
        var e = ji;
        if (e) {
            var t = e;
            if (!UE(n, e)) {
                if (O_(n))
                    throw Error(De(418));
                e = Bo(t.nextSibling);
                var i = Zi;
                e && UE(n, e) ? JC(i, t) : (n.flags = n.flags & -4097 | 2,
                ln = !1,
                Zi = n)
            }
        } else {
            if (O_(n))
                throw Error(De(418));
            n.flags = n.flags & -4097 | 2,
            ln = !1,
            Zi = n
        }
    }
}
function kE(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    Zi = n
}
function Kh(n) {
    if (n !== Zi)
        return !1;
    if (!ln)
        return kE(n),
        ln = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !N_(n.type, n.memoizedProps)),
    e && (e = ji)) {
        if (O_(n))
            throw eb(),
            Error(De(418));
        for (; e; )
            JC(n, e),
            e = Bo(e.nextSibling)
    }
    if (kE(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(De(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            ji = Bo(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            ji = null
        }
    } else
        ji = Zi ? Bo(n.stateNode.nextSibling) : null;
    return !0
}
function eb() {
    for (var n = ji; n; )
        n = Bo(n.nextSibling)
}
function kc() {
    ji = Zi = null,
    ln = !1
}
function IS(n) {
    Wr === null ? Wr = [n] : Wr.push(n)
}
var eU = io.ReactCurrentBatchConfig;
function Vr(n, e) {
    if (n && n.defaultProps) {
        e = mn({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
var Um = ta(null)
  , km = null
  , pc = null
  , NS = null;
function DS() {
    NS = pc = km = null
}
function US(n) {
    var e = Um.current;
    on(Um),
    n._currentValue = e
}
function z_(n, e, t) {
    for (; n !== null; ) {
        var i = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function Ac(n, e) {
    km = n,
    NS = pc = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (Ni = !0),
    n.firstContext = null)
}
function wr(n) {
    var e = n._currentValue;
    if (NS !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        pc === null) {
            if (km === null)
                throw Error(De(308));
            pc = n,
            km.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            pc = pc.next = n;
    return e
}
var Na = null;
function kS(n) {
    Na === null ? Na = [n] : Na.push(n)
}
function tb(n, e, t, i) {
    var r = e.interleaved;
    return r === null ? (t.next = t,
    kS(e)) : (t.next = r.next,
    r.next = t),
    e.interleaved = t,
    Js(n, i)
}
function Js(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var Ro = !1;
function OS(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function nb(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function qs(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function Vo(n, e, t) {
    var i = n.updateQueue;
    if (i === null)
        return null;
    if (i = i.shared,
    kt & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        i.pending = e,
        Js(n, t)
    }
    return r = i.interleaved,
    r === null ? (e.next = e,
    kS(i)) : (e.next = r.next,
    r.next = e),
    i.interleaved = e,
    Js(n, t)
}
function sm(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        wS(n, t)
    }
}
function OE(n, e) {
    var t = n.updateQueue
      , i = n.alternate;
    if (i !== null && (i = i.updateQueue,
    t === i)) {
        var r = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? r = s = e : s = s.next = e
        } else
            r = s = e;
        t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function Om(n, e, t, i) {
    var r = n.updateQueue;
    Ro = !1;
    var s = r.firstBaseUpdate
      , o = r.lastBaseUpdate
      , a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a
          , f = l.next;
        l.next = null,
        o === null ? s = f : o.next = f,
        o = l;
        var d = n.alternate;
        d !== null && (d = d.updateQueue,
        a = d.lastBaseUpdate,
        a !== o && (a === null ? d.firstBaseUpdate = f : a.next = f,
        d.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = r.baseState;
        o = 0,
        d = f = l = null,
        a = s;
        do {
            var p = a.lane
              , m = a.eventTime;
            if ((i & p) === p) {
                d !== null && (d = d.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var y = n
                      , S = a;
                    switch (p = e,
                    m = t,
                    S.tag) {
                    case 1:
                        if (y = S.payload,
                        typeof y == "function") {
                            h = y.call(m, h, p);
                            break e
                        }
                        h = y;
                        break e;
                    case 3:
                        y.flags = y.flags & -65537 | 128;
                    case 0:
                        if (y = S.payload,
                        p = typeof y == "function" ? y.call(m, h, p) : y,
                        p == null)
                            break e;
                        h = mn({}, h, p);
                        break e;
                    case 2:
                        Ro = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                p = r.effects,
                p === null ? r.effects = [a] : p.push(a))
            } else
                m = {
                    eventTime: m,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                d === null ? (f = d = m,
                l = h) : d = d.next = m,
                o |= p;
            if (a = a.next,
            a === null) {
                if (a = r.shared.pending,
                a === null)
                    break;
                p = a,
                a = p.next,
                p.next = null,
                r.lastBaseUpdate = p,
                r.shared.pending = null
            }
        } while (1);
        if (d === null && (l = h),
        r.baseState = l,
        r.firstBaseUpdate = f,
        r.lastBaseUpdate = d,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                o |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            s === null && (r.shared.lanes = 0);
        qa |= o,
        n.lanes = o,
        n.memoizedState = h
    }
}
function FE(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var i = n[e]
              , r = i.callback;
            if (r !== null) {
                if (i.callback = null,
                i = t,
                typeof r != "function")
                    throw Error(De(191, r));
                r.call(i)
            }
        }
}
var ib = new tC.Component().refs;
function B_(n, e, t, i) {
    e = n.memoizedState,
    t = t(i, e),
    t = t == null ? e : mn({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var fg = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? ll(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var i = xi()
          , r = Go(n)
          , s = qs(i, r);
        s.payload = e,
        t != null && (s.callback = t),
        e = Vo(n, s, r),
        e !== null && (Yr(e, n, r, i),
        sm(e, n, r))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var i = xi()
          , r = Go(n)
          , s = qs(i, r);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = Vo(n, s, r),
        e !== null && (Yr(e, n, r, i),
        sm(e, n, r))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = xi()
          , i = Go(n)
          , r = qs(t, i);
        r.tag = 2,
        e != null && (r.callback = e),
        e = Vo(n, r, i),
        e !== null && (Yr(e, n, i, t),
        sm(e, n, i))
    }
};
function zE(n, e, t, i, r, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Gf(t, i) || !Gf(r, s) : !0
}
function rb(n, e, t) {
    var i = !1
      , r = Ko
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = wr(s) : (r = Ui(e) ? $a : pi.current,
    i = e.contextTypes,
    s = (i = i != null) ? Uc(n, r) : Ko),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = fg,
    n.stateNode = e,
    e._reactInternals = n,
    i && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = r,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function BE(n, e, t, i) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && fg.enqueueReplaceState(e, e.state, null)
}
function V_(n, e, t, i) {
    var r = n.stateNode;
    r.props = t,
    r.state = n.memoizedState,
    r.refs = ib,
    OS(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = wr(s) : (s = Ui(e) ? $a : pi.current,
    r.context = Uc(n, s)),
    r.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (B_(n, e, s, t),
    r.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && fg.enqueueReplaceState(r, r.state, null),
    Om(n, t, r, i),
    r.state = n.memoizedState),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308)
}
function Vu(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(De(309));
                var i = t.stateNode
            }
            if (!i)
                throw Error(De(147, n));
            var r = i
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                a === ib && (a = r.refs = {}),
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(De(284));
        if (!t._owner)
            throw Error(De(290, n))
    }
    return n
}
function Zh(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(De(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function VE(n) {
    var e = n._init;
    return e(n._payload)
}
function sb(n) {
    function e(g, _) {
        if (n) {
            var w = g.deletions;
            w === null ? (g.deletions = [_],
            g.flags |= 16) : w.push(_)
        }
    }
    function t(g, _) {
        if (!n)
            return null;
        for (; _ !== null; )
            e(g, _),
            _ = _.sibling;
        return null
    }
    function i(g, _) {
        for (g = new Map; _ !== null; )
            _.key !== null ? g.set(_.key, _) : g.set(_.index, _),
            _ = _.sibling;
        return g
    }
    function r(g, _) {
        return g = Wo(g, _),
        g.index = 0,
        g.sibling = null,
        g
    }
    function s(g, _, w) {
        return g.index = w,
        n ? (w = g.alternate,
        w !== null ? (w = w.index,
        w < _ ? (g.flags |= 2,
        _) : w) : (g.flags |= 2,
        _)) : (g.flags |= 1048576,
        _)
    }
    function o(g) {
        return n && g.alternate === null && (g.flags |= 2),
        g
    }
    function a(g, _, w, T) {
        return _ === null || _.tag !== 6 ? (_ = ny(w, g.mode, T),
        _.return = g,
        _) : (_ = r(_, w),
        _.return = g,
        _)
    }
    function l(g, _, w, T) {
        var A = w.type;
        return A === oc ? d(g, _, w.props.children, T, w.key) : _ !== null && (_.elementType === A || typeof A == "object" && A !== null && A.$$typeof === Ao && VE(A) === _.type) ? (T = r(_, w.props),
        T.ref = Vu(g, _, w),
        T.return = g,
        T) : (T = fm(w.type, w.key, w.props, null, g.mode, T),
        T.ref = Vu(g, _, w),
        T.return = g,
        T)
    }
    function f(g, _, w, T) {
        return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== w.containerInfo || _.stateNode.implementation !== w.implementation ? (_ = iy(w, g.mode, T),
        _.return = g,
        _) : (_ = r(_, w.children || []),
        _.return = g,
        _)
    }
    function d(g, _, w, T, A) {
        return _ === null || _.tag !== 7 ? (_ = Ba(w, g.mode, T, A),
        _.return = g,
        _) : (_ = r(_, w),
        _.return = g,
        _)
    }
    function h(g, _, w) {
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return _ = ny("" + _, g.mode, w),
            _.return = g,
            _;
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Bh:
                return w = fm(_.type, _.key, _.props, null, g.mode, w),
                w.ref = Vu(g, null, _),
                w.return = g,
                w;
            case sc:
                return _ = iy(_, g.mode, w),
                _.return = g,
                _;
            case Ao:
                var T = _._init;
                return h(g, T(_._payload), w)
            }
            if (ff(_) || ku(_))
                return _ = Ba(_, g.mode, w, null),
                _.return = g,
                _;
            Zh(g, _)
        }
        return null
    }
    function p(g, _, w, T) {
        var A = _ !== null ? _.key : null;
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return A !== null ? null : a(g, _, "" + w, T);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Bh:
                return w.key === A ? l(g, _, w, T) : null;
            case sc:
                return w.key === A ? f(g, _, w, T) : null;
            case Ao:
                return A = w._init,
                p(g, _, A(w._payload), T)
            }
            if (ff(w) || ku(w))
                return A !== null ? null : d(g, _, w, T, null);
            Zh(g, w)
        }
        return null
    }
    function m(g, _, w, T, A) {
        if (typeof T == "string" && T !== "" || typeof T == "number")
            return g = g.get(w) || null,
            a(_, g, "" + T, A);
        if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
            case Bh:
                return g = g.get(T.key === null ? w : T.key) || null,
                l(_, g, T, A);
            case sc:
                return g = g.get(T.key === null ? w : T.key) || null,
                f(_, g, T, A);
            case Ao:
                var C = T._init;
                return m(g, _, w, C(T._payload), A)
            }
            if (ff(T) || ku(T))
                return g = g.get(w) || null,
                d(_, g, T, A, null);
            Zh(_, T)
        }
        return null
    }
    function y(g, _, w, T) {
        for (var A = null, C = null, P = _, N = _ = 0, b = null; P !== null && N < w.length; N++) {
            P.index > N ? (b = P,
            P = null) : b = P.sibling;
            var L = p(g, P, w[N], T);
            if (L === null) {
                P === null && (P = b);
                break
            }
            n && P && L.alternate === null && e(g, P),
            _ = s(L, _, N),
            C === null ? A = L : C.sibling = L,
            C = L,
            P = b
        }
        if (N === w.length)
            return t(g, P),
            ln && Aa(g, N),
            A;
        if (P === null) {
            for (; N < w.length; N++)
                P = h(g, w[N], T),
                P !== null && (_ = s(P, _, N),
                C === null ? A = P : C.sibling = P,
                C = P);
            return ln && Aa(g, N),
            A
        }
        for (P = i(g, P); N < w.length; N++)
            b = m(P, g, N, w[N], T),
            b !== null && (n && b.alternate !== null && P.delete(b.key === null ? N : b.key),
            _ = s(b, _, N),
            C === null ? A = b : C.sibling = b,
            C = b);
        return n && P.forEach(function(Y) {
            return e(g, Y)
        }),
        ln && Aa(g, N),
        A
    }
    function S(g, _, w, T) {
        var A = ku(w);
        if (typeof A != "function")
            throw Error(De(150));
        if (w = A.call(w),
        w == null)
            throw Error(De(151));
        for (var C = A = null, P = _, N = _ = 0, b = null, L = w.next(); P !== null && !L.done; N++,
        L = w.next()) {
            P.index > N ? (b = P,
            P = null) : b = P.sibling;
            var Y = p(g, P, L.value, T);
            if (Y === null) {
                P === null && (P = b);
                break
            }
            n && P && Y.alternate === null && e(g, P),
            _ = s(Y, _, N),
            C === null ? A = Y : C.sibling = Y,
            C = Y,
            P = b
        }
        if (L.done)
            return t(g, P),
            ln && Aa(g, N),
            A;
        if (P === null) {
            for (; !L.done; N++,
            L = w.next())
                L = h(g, L.value, T),
                L !== null && (_ = s(L, _, N),
                C === null ? A = L : C.sibling = L,
                C = L);
            return ln && Aa(g, N),
            A
        }
        for (P = i(g, P); !L.done; N++,
        L = w.next())
            L = m(P, g, N, L.value, T),
            L !== null && (n && L.alternate !== null && P.delete(L.key === null ? N : L.key),
            _ = s(L, _, N),
            C === null ? A = L : C.sibling = L,
            C = L);
        return n && P.forEach(function(Z) {
            return e(g, Z)
        }),
        ln && Aa(g, N),
        A
    }
    function M(g, _, w, T) {
        if (typeof w == "object" && w !== null && w.type === oc && w.key === null && (w = w.props.children),
        typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Bh:
                e: {
                    for (var A = w.key, C = _; C !== null; ) {
                        if (C.key === A) {
                            if (A = w.type,
                            A === oc) {
                                if (C.tag === 7) {
                                    t(g, C.sibling),
                                    _ = r(C, w.props.children),
                                    _.return = g,
                                    g = _;
                                    break e
                                }
                            } else if (C.elementType === A || typeof A == "object" && A !== null && A.$$typeof === Ao && VE(A) === C.type) {
                                t(g, C.sibling),
                                _ = r(C, w.props),
                                _.ref = Vu(g, C, w),
                                _.return = g,
                                g = _;
                                break e
                            }
                            t(g, C);
                            break
                        } else
                            e(g, C);
                        C = C.sibling
                    }
                    w.type === oc ? (_ = Ba(w.props.children, g.mode, T, w.key),
                    _.return = g,
                    g = _) : (T = fm(w.type, w.key, w.props, null, g.mode, T),
                    T.ref = Vu(g, _, w),
                    T.return = g,
                    g = T)
                }
                return o(g);
            case sc:
                e: {
                    for (C = w.key; _ !== null; ) {
                        if (_.key === C)
                            if (_.tag === 4 && _.stateNode.containerInfo === w.containerInfo && _.stateNode.implementation === w.implementation) {
                                t(g, _.sibling),
                                _ = r(_, w.children || []),
                                _.return = g,
                                g = _;
                                break e
                            } else {
                                t(g, _);
                                break
                            }
                        else
                            e(g, _);
                        _ = _.sibling
                    }
                    _ = iy(w, g.mode, T),
                    _.return = g,
                    g = _
                }
                return o(g);
            case Ao:
                return C = w._init,
                M(g, _, C(w._payload), T)
            }
            if (ff(w))
                return y(g, _, w, T);
            if (ku(w))
                return S(g, _, w, T);
            Zh(g, w)
        }
        return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w,
        _ !== null && _.tag === 6 ? (t(g, _.sibling),
        _ = r(_, w),
        _.return = g,
        g = _) : (t(g, _),
        _ = ny(w, g.mode, T),
        _.return = g,
        g = _),
        o(g)) : t(g, _)
    }
    return M
}
var Oc = sb(!0)
  , ob = sb(!1)
  , gd = {}
  , xs = ta(gd)
  , jf = ta(gd)
  , Yf = ta(gd);
function Da(n) {
    if (n === gd)
        throw Error(De(174));
    return n
}
function FS(n, e) {
    switch (Jt(Yf, e),
    Jt(jf, n),
    Jt(xs, gd),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : __(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = __(e, n)
    }
    on(xs),
    Jt(xs, e)
}
function Fc() {
    on(xs),
    on(jf),
    on(Yf)
}
function ab(n) {
    Da(Yf.current);
    var e = Da(xs.current)
      , t = __(e, n.type);
    e !== t && (Jt(jf, n),
    Jt(xs, t))
}
function zS(n) {
    jf.current === n && (on(xs),
    on(jf))
}
var fn = ta(0);
function Fm(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var Kv = [];
function BS() {
    for (var n = 0; n < Kv.length; n++)
        Kv[n]._workInProgressVersionPrimary = null;
    Kv.length = 0
}
var om = io.ReactCurrentDispatcher
  , Zv = io.ReactCurrentBatchConfig
  , Ya = 0
  , pn = null
  , kn = null
  , $n = null
  , zm = !1
  , wf = !1
  , qf = 0
  , tU = 0;
function li() {
    throw Error(De(321))
}
function VS(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!Kr(n[t], e[t]))
            return !1;
    return !0
}
function HS(n, e, t, i, r, s) {
    if (Ya = s,
    pn = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    om.current = n === null || n.memoizedState === null ? sU : oU,
    n = t(i, r),
    wf) {
        s = 0;
        do {
            if (wf = !1,
            qf = 0,
            25 <= s)
                throw Error(De(301));
            s += 1,
            $n = kn = null,
            e.updateQueue = null,
            om.current = aU,
            n = t(i, r)
        } while (wf)
    }
    if (om.current = Bm,
    e = kn !== null && kn.next !== null,
    Ya = 0,
    $n = kn = pn = null,
    zm = !1,
    e)
        throw Error(De(300));
    return n
}
function GS() {
    var n = qf !== 0;
    return qf = 0,
    n
}
function vs() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return $n === null ? pn.memoizedState = $n = n : $n = $n.next = n,
    $n
}
function Mr() {
    if (kn === null) {
        var n = pn.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = kn.next;
    var e = $n === null ? pn.memoizedState : $n.next;
    if (e !== null)
        $n = e,
        kn = n;
    else {
        if (n === null)
            throw Error(De(310));
        kn = n,
        n = {
            memoizedState: kn.memoizedState,
            baseState: kn.baseState,
            baseQueue: kn.baseQueue,
            queue: kn.queue,
            next: null
        },
        $n === null ? pn.memoizedState = $n = n : $n = $n.next = n
    }
    return $n
}
function Kf(n, e) {
    return typeof e == "function" ? e(n) : e
}
function Qv(n) {
    var e = Mr()
      , t = e.queue;
    if (t === null)
        throw Error(De(311));
    t.lastRenderedReducer = n;
    var i = kn
      , r = i.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next,
            s.next = o
        }
        i.baseQueue = r = s,
        t.pending = null
    }
    if (r !== null) {
        s = r.next,
        i = i.baseState;
        var a = o = null
          , l = null
          , f = s;
        do {
            var d = f.lane;
            if ((Ya & d) === d)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                }),
                i = f.hasEagerState ? f.eagerState : n(i, f.action);
            else {
                var h = {
                    lane: d,
                    action: f.action,
                    hasEagerState: f.hasEagerState,
                    eagerState: f.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = i) : l = l.next = h,
                pn.lanes |= d,
                qa |= d
            }
            f = f.next
        } while (f !== null && f !== s);
        l === null ? o = i : l.next = a,
        Kr(i, e.memoizedState) || (Ni = !0),
        e.memoizedState = i,
        e.baseState = o,
        e.baseQueue = l,
        t.lastRenderedState = i
    }
    if (n = t.interleaved,
    n !== null) {
        r = n;
        do
            s = r.lane,
            pn.lanes |= s,
            qa |= s,
            r = r.next;
        while (r !== n)
    } else
        r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Jv(n) {
    var e = Mr()
      , t = e.queue;
    if (t === null)
        throw Error(De(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch
      , r = t.pending
      , s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = r = r.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== r);
        Kr(s, e.memoizedState) || (Ni = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, i]
}
function lb() {}
function cb(n, e) {
    var t = pn
      , i = Mr()
      , r = e()
      , s = !Kr(i.memoizedState, r);
    if (s && (i.memoizedState = r,
    Ni = !0),
    i = i.queue,
    WS(db.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || $n !== null && $n.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        Zf(9, fb.bind(null, t, i, r, e), void 0, null),
        jn === null)
            throw Error(De(349));
        Ya & 30 || ub(t, e, r)
    }
    return r
}
function ub(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = pn.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    pn.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function fb(n, e, t, i) {
    e.value = t,
    e.getSnapshot = i,
    hb(e) && pb(n)
}
function db(n, e, t) {
    return t(function() {
        hb(e) && pb(n)
    })
}
function hb(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !Kr(n, t)
    } catch {
        return !0
    }
}
function pb(n) {
    var e = Js(n, 1);
    e !== null && Yr(e, n, 1, -1)
}
function HE(n) {
    var e = vs();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Kf,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = rU.bind(null, pn, n),
    [e.memoizedState, n]
}
function Zf(n, e, t, i) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: i,
        next: null
    },
    e = pn.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    pn.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (i = t.next,
    t.next = n,
    n.next = i,
    e.lastEffect = n)),
    n
}
function mb() {
    return Mr().memoizedState
}
function am(n, e, t, i) {
    var r = vs();
    pn.flags |= n,
    r.memoizedState = Zf(1 | e, t, void 0, i === void 0 ? null : i)
}
function dg(n, e, t, i) {
    var r = Mr();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (kn !== null) {
        var o = kn.memoizedState;
        if (s = o.destroy,
        i !== null && VS(i, o.deps)) {
            r.memoizedState = Zf(e, t, s, i);
            return
        }
    }
    pn.flags |= n,
    r.memoizedState = Zf(1 | e, t, s, i)
}
function GE(n, e) {
    return am(8390656, 8, n, e)
}
function WS(n, e) {
    return dg(2048, 8, n, e)
}
function gb(n, e) {
    return dg(4, 2, n, e)
}
function vb(n, e) {
    return dg(4, 4, n, e)
}
function yb(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function _b(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    dg(4, 4, yb.bind(null, e, n), t)
}
function XS() {}
function xb(n, e) {
    var t = Mr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && VS(e, i[1]) ? i[0] : (t.memoizedState = [n, e],
    n)
}
function Sb(n, e) {
    var t = Mr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && VS(e, i[1]) ? i[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function wb(n, e, t) {
    return Ya & 21 ? (Kr(t, e) || (t = TC(),
    pn.lanes |= t,
    qa |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    Ni = !0),
    n.memoizedState = t)
}
function nU(n, e) {
    var t = Xt;
    Xt = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var i = Zv.transition;
    Zv.transition = {};
    try {
        n(!1),
        e()
    } finally {
        Xt = t,
        Zv.transition = i
    }
}
function Mb() {
    return Mr().memoizedState
}
function iU(n, e, t) {
    var i = Go(n);
    if (t = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Eb(n))
        Tb(e, t);
    else if (t = tb(n, e, t, i),
    t !== null) {
        var r = xi();
        Yr(t, n, i, r),
        Ab(t, e, i)
    }
}
function rU(n, e, t) {
    var i = Go(n)
      , r = {
        lane: i,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Eb(n))
        Tb(e, r);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (r.hasEagerState = !0,
                r.eagerState = a,
                Kr(a, o)) {
                    var l = e.interleaved;
                    l === null ? (r.next = r,
                    kS(e)) : (r.next = l.next,
                    l.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        t = tb(n, e, r, i),
        t !== null && (r = xi(),
        Yr(t, n, i, r),
        Ab(t, e, i))
    }
}
function Eb(n) {
    var e = n.alternate;
    return n === pn || e !== null && e === pn
}
function Tb(n, e) {
    wf = zm = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function Ab(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        i &= n.pendingLanes,
        t |= i,
        e.lanes = t,
        wS(n, t)
    }
}
var Bm = {
    readContext: wr,
    useCallback: li,
    useContext: li,
    useEffect: li,
    useImperativeHandle: li,
    useInsertionEffect: li,
    useLayoutEffect: li,
    useMemo: li,
    useReducer: li,
    useRef: li,
    useState: li,
    useDebugValue: li,
    useDeferredValue: li,
    useTransition: li,
    useMutableSource: li,
    useSyncExternalStore: li,
    useId: li,
    unstable_isNewReconciler: !1
}
  , sU = {
    readContext: wr,
    useCallback: function(n, e) {
        return vs().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: wr,
    useEffect: GE,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        am(4194308, 4, yb.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return am(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return am(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = vs();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var i = vs();
        return e = t !== void 0 ? t(e) : e,
        i.memoizedState = i.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        i.queue = n,
        n = n.dispatch = iU.bind(null, pn, n),
        [i.memoizedState, n]
    },
    useRef: function(n) {
        var e = vs();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: HE,
    useDebugValue: XS,
    useDeferredValue: function(n) {
        return vs().memoizedState = n
    },
    useTransition: function() {
        var n = HE(!1)
          , e = n[0];
        return n = nU.bind(null, n[1]),
        vs().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var i = pn
          , r = vs();
        if (ln) {
            if (t === void 0)
                throw Error(De(407));
            t = t()
        } else {
            if (t = e(),
            jn === null)
                throw Error(De(349));
            Ya & 30 || ub(i, e, t)
        }
        r.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return r.queue = s,
        GE(db.bind(null, i, s, n), [n]),
        i.flags |= 2048,
        Zf(9, fb.bind(null, i, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = vs()
          , e = jn.identifierPrefix;
        if (ln) {
            var t = $s
              , i = Xs;
            t = (i & ~(1 << 32 - jr(i) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = qf++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = tU++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , oU = {
    readContext: wr,
    useCallback: xb,
    useContext: wr,
    useEffect: WS,
    useImperativeHandle: _b,
    useInsertionEffect: gb,
    useLayoutEffect: vb,
    useMemo: Sb,
    useReducer: Qv,
    useRef: mb,
    useState: function() {
        return Qv(Kf)
    },
    useDebugValue: XS,
    useDeferredValue: function(n) {
        var e = Mr();
        return wb(e, kn.memoizedState, n)
    },
    useTransition: function() {
        var n = Qv(Kf)[0]
          , e = Mr().memoizedState;
        return [n, e]
    },
    useMutableSource: lb,
    useSyncExternalStore: cb,
    useId: Mb,
    unstable_isNewReconciler: !1
}
  , aU = {
    readContext: wr,
    useCallback: xb,
    useContext: wr,
    useEffect: WS,
    useImperativeHandle: _b,
    useInsertionEffect: gb,
    useLayoutEffect: vb,
    useMemo: Sb,
    useReducer: Jv,
    useRef: mb,
    useState: function() {
        return Jv(Kf)
    },
    useDebugValue: XS,
    useDeferredValue: function(n) {
        var e = Mr();
        return kn === null ? e.memoizedState = n : wb(e, kn.memoizedState, n)
    },
    useTransition: function() {
        var n = Jv(Kf)[0]
          , e = Mr().memoizedState;
        return [n, e]
    },
    useMutableSource: lb,
    useSyncExternalStore: cb,
    useId: Mb,
    unstable_isNewReconciler: !1
};
function zc(n, e) {
    try {
        var t = ""
          , i = e;
        do
            t += UN(i),
            i = i.return;
        while (i);
        var r = t
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: r,
        digest: null
    }
}
function ey(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function H_(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var lU = typeof WeakMap == "function" ? WeakMap : Map;
function Rb(n, e, t) {
    t = qs(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var i = e.value;
    return t.callback = function() {
        Hm || (Hm = !0,
        Q_ = i),
        H_(n, e)
    }
    ,
    t
}
function Cb(n, e, t) {
    t = qs(-1, t),
    t.tag = 3;
    var i = n.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        t.payload = function() {
            return i(r)
        }
        ,
        t.callback = function() {
            H_(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        H_(n, e),
        typeof i != "function" && (Ho === null ? Ho = new Set([this]) : Ho.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function WE(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new lU;
        var r = new Set;
        i.set(e, r)
    } else
        r = i.get(e),
        r === void 0 && (r = new Set,
        i.set(e, r));
    r.has(t) || (r.add(t),
    n = wU.bind(null, n, e, t),
    e.then(n, n))
}
function XE(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function $E(n, e, t, i, r) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = r,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = qs(-1, 1),
    e.tag = 2,
    Vo(t, e, 1))),
    t.lanes |= 1),
    n)
}
var cU = io.ReactCurrentOwner
  , Ni = !1;
function _i(n, e, t, i) {
    e.child = n === null ? ob(e, null, t, i) : Oc(e, n.child, t, i)
}
function jE(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return Ac(e, r),
    i = HS(n, e, t, i, s, r),
    t = GS(),
    n !== null && !Ni ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    eo(n, e, r)) : (ln && t && PS(e),
    e.flags |= 1,
    _i(n, e, i, r),
    e.child)
}
function YE(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !JS(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        bb(n, e, s, i, r)) : (n = fm(t.type, null, i, e, e.mode, r),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & r)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : Gf,
        t(o, i) && n.ref === e.ref)
            return eo(n, e, r)
    }
    return e.flags |= 1,
    n = Wo(s, i),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function bb(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (Gf(s, i) && n.ref === e.ref)
            if (Ni = !1,
            e.pendingProps = i = s,
            (n.lanes & r) !== 0)
                n.flags & 131072 && (Ni = !0);
            else
                return e.lanes = n.lanes,
                eo(n, e, r)
    }
    return G_(n, e, t, i, r)
}
function Pb(n, e, t) {
    var i = e.pendingProps
      , r = i.children
      , s = n !== null ? n.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Jt(gc, $i),
            $i |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                Jt(gc, $i),
                $i |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            i = s !== null ? s.baseLanes : t,
            Jt(gc, $i),
            $i |= i
        }
    else
        s !== null ? (i = s.baseLanes | t,
        e.memoizedState = null) : i = t,
        Jt(gc, $i),
        $i |= i;
    return _i(n, e, r, t),
    e.child
}
function Lb(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function G_(n, e, t, i, r) {
    var s = Ui(t) ? $a : pi.current;
    return s = Uc(e, s),
    Ac(e, r),
    t = HS(n, e, t, i, s, r),
    i = GS(),
    n !== null && !Ni ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~r,
    eo(n, e, r)) : (ln && i && PS(e),
    e.flags |= 1,
    _i(n, e, t, r),
    e.child)
}
function qE(n, e, t, i, r) {
    if (Ui(t)) {
        var s = !0;
        Im(e)
    } else
        s = !1;
    if (Ac(e, r),
    e.stateNode === null)
        lm(n, e),
        rb(e, t, i),
        V_(e, t, i, r),
        i = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , f = t.contextType;
        typeof f == "object" && f !== null ? f = wr(f) : (f = Ui(t) ? $a : pi.current,
        f = Uc(e, f));
        var d = t.getDerivedStateFromProps
          , h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== f) && BE(e, o, i, f),
        Ro = !1;
        var p = e.memoizedState;
        o.state = p,
        Om(e, i, o, r),
        l = e.memoizedState,
        a !== i || p !== l || Di.current || Ro ? (typeof d == "function" && (B_(e, t, d, i),
        l = e.memoizedState),
        (a = Ro || zE(e, t, a, i, p, l, f)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = i,
        e.memoizedState = l),
        o.props = i,
        o.state = l,
        o.context = f,
        i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        i = !1)
    } else {
        o = e.stateNode,
        nb(n, e),
        a = e.memoizedProps,
        f = e.type === e.elementType ? a : Vr(e.type, a),
        o.props = f,
        h = e.pendingProps,
        p = o.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = wr(l) : (l = Ui(t) ? $a : pi.current,
        l = Uc(e, l));
        var m = t.getDerivedStateFromProps;
        (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && BE(e, o, i, l),
        Ro = !1,
        p = e.memoizedState,
        o.state = p,
        Om(e, i, o, r);
        var y = e.memoizedState;
        a !== h || p !== y || Di.current || Ro ? (typeof m == "function" && (B_(e, t, m, i),
        y = e.memoizedState),
        (f = Ro || zE(e, t, f, i, p, y, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, y, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, y, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = i,
        e.memoizedState = y),
        o.props = i,
        o.state = y,
        o.context = l,
        i = f) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024),
        i = !1)
    }
    return W_(n, e, t, i, s, r)
}
function W_(n, e, t, i, r, s) {
    Lb(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o)
        return r && DE(e, t, !1),
        eo(n, e, s);
    i = e.stateNode,
    cU.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = Oc(e, n.child, null, s),
    e.child = Oc(e, null, a, s)) : _i(n, e, a, s),
    e.memoizedState = i.state,
    r && DE(e, t, !0),
    e.child
}
function Ib(n) {
    var e = n.stateNode;
    e.pendingContext ? NE(n, e.pendingContext, e.pendingContext !== e.context) : e.context && NE(n, e.context, !1),
    FS(n, e.containerInfo)
}
function KE(n, e, t, i, r) {
    return kc(),
    IS(r),
    e.flags |= 256,
    _i(n, e, t, i),
    e.child
}
var X_ = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function $_(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function Nb(n, e, t) {
    var i = e.pendingProps, r = fn.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1),
    Jt(fn, r & 1),
    n === null)
        return F_(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = i.children,
        n = i.fallback,
        s ? (i = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(i & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = mg(o, i, 0, null),
        n = Ba(n, i, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = $_(t),
        e.memoizedState = X_,
        n) : $S(e, o));
    if (r = n.memoizedState,
    r !== null && (a = r.dehydrated,
    a !== null))
        return uU(n, e, o, i, a, r, t);
    if (s) {
        s = i.fallback,
        o = e.mode,
        r = n.child,
        a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child,
        i.childLanes = 0,
        i.pendingProps = l,
        e.deletions = null) : (i = Wo(r, l),
        i.subtreeFlags = r.subtreeFlags & 14680064),
        a !== null ? s = Wo(a, s) : (s = Ba(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        i.return = e,
        i.sibling = s,
        e.child = i,
        i = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? $_(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = X_,
        i
    }
    return s = n.child,
    n = s.sibling,
    i = Wo(s, {
        mode: "visible",
        children: i.children
    }),
    !(e.mode & 1) && (i.lanes = t),
    i.return = e,
    i.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = i,
    e.memoizedState = null,
    i
}
function $S(n, e) {
    return e = mg({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function Qh(n, e, t, i) {
    return i !== null && IS(i),
    Oc(e, n.child, null, t),
    n = $S(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function uU(n, e, t, i, r, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        i = ey(Error(De(422))),
        Qh(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = i.fallback,
        r = e.mode,
        i = mg({
            mode: "visible",
            children: i.children
        }, r, 0, null),
        s = Ba(s, r, o, null),
        s.flags |= 2,
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.mode & 1 && Oc(e, n.child, null, o),
        e.child.memoizedState = $_(o),
        e.memoizedState = X_,
        s);
    if (!(e.mode & 1))
        return Qh(n, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset,
        i)
            var a = i.dgst;
        return i = a,
        s = Error(De(419)),
        i = ey(s, i, void 0),
        Qh(n, e, o, i)
    }
    if (a = (o & n.childLanes) !== 0,
    Ni || a) {
        if (i = jn,
        i !== null) {
            switch (o & -o) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r,
            r !== 0 && r !== s.retryLane && (s.retryLane = r,
            Js(n, r),
            Yr(i, n, r, -1))
        }
        return QS(),
        i = ey(Error(De(421))),
        Qh(n, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = MU.bind(null, n),
    r._reactRetry = e,
    null) : (n = s.treeContext,
    ji = Bo(r.nextSibling),
    Zi = e,
    ln = !0,
    Wr = null,
    n !== null && (mr[gr++] = Xs,
    mr[gr++] = $s,
    mr[gr++] = ja,
    Xs = n.id,
    $s = n.overflow,
    ja = e),
    e = $S(e, i.children),
    e.flags |= 4096,
    e)
}
function ZE(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e),
    z_(n.return, e, t)
}
function ty(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = i,
    s.tail = t,
    s.tailMode = r)
}
function Db(n, e, t) {
    var i = e.pendingProps
      , r = i.revealOrder
      , s = i.tail;
    if (_i(n, e, i.children, t),
    i = fn.current,
    i & 2)
        i = i & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && ZE(n, t, e);
                else if (n.tag === 19)
                    ZE(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        i &= 1
    }
    if (Jt(fn, i),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (t = e.child,
            r = null; t !== null; )
                n = t.alternate,
                n !== null && Fm(n) === null && (r = t),
                t = t.sibling;
            t = r,
            t === null ? (r = e.child,
            e.child = null) : (r = t.sibling,
            t.sibling = null),
            ty(e, !1, r, t, s);
            break;
        case "backwards":
            for (t = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (n = r.alternate,
                n !== null && Fm(n) === null) {
                    e.child = r;
                    break
                }
                n = r.sibling,
                r.sibling = t,
                t = r,
                r = n
            }
            ty(e, !0, t, null, s);
            break;
        case "together":
            ty(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function lm(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function eo(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    qa |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(De(153));
    if (e.child !== null) {
        for (n = e.child,
        t = Wo(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = Wo(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function fU(n, e, t) {
    switch (e.tag) {
    case 3:
        Ib(e),
        kc();
        break;
    case 5:
        ab(e);
        break;
    case 1:
        Ui(e.type) && Im(e);
        break;
    case 4:
        FS(e, e.stateNode.containerInfo);
        break;
    case 10:
        var i = e.type._context
          , r = e.memoizedProps.value;
        Jt(Um, i._currentValue),
        i._currentValue = r;
        break;
    case 13:
        if (i = e.memoizedState,
        i !== null)
            return i.dehydrated !== null ? (Jt(fn, fn.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? Nb(n, e, t) : (Jt(fn, fn.current & 1),
            n = eo(n, e, t),
            n !== null ? n.sibling : null);
        Jt(fn, fn.current & 1);
        break;
    case 19:
        if (i = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (i)
                return Db(n, e, t);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        Jt(fn, fn.current),
        i)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        Pb(n, e, t)
    }
    return eo(n, e, t)
}
var Ub, j_, kb, Ob;
Ub = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
j_ = function() {}
;
kb = function(n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        n = e.stateNode,
        Da(xs.current);
        var s = null;
        switch (t) {
        case "input":
            r = m_(n, r),
            i = m_(n, i),
            s = [];
            break;
        case "select":
            r = mn({}, r, {
                value: void 0
            }),
            i = mn({}, i, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            r = y_(n, r),
            i = y_(n, i),
            s = [];
            break;
        default:
            typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Pm)
        }
        x_(t, i);
        var o;
        t = null;
        for (f in r)
            if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null)
                if (f === "style") {
                    var a = r[f];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (kf.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
        for (f in i) {
            var l = i[f];
            if (a = r != null ? r[f] : void 0,
            i.hasOwnProperty(f) && l !== a && (l != null || a != null))
                if (f === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}),
                            t[o] = l[o])
                    } else
                        t || (s || (s = []),
                        s.push(f, t)),
                        t = l;
                else
                    f === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(f, l)) : f === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(f, "" + l) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (kf.hasOwnProperty(f) ? (l != null && f === "onScroll" && tn("scroll", n),
                    s || a === l || (s = [])) : (s = s || []).push(f, l))
        }
        t && (s = s || []).push("style", t);
        var f = s;
        (e.updateQueue = f) && (e.flags |= 4)
    }
}
;
Ob = function(n, e, t, i) {
    t !== i && (e.flags |= 4)
}
;
function Hu(n, e) {
    if (!ln)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var i = null; t !== null; )
                t.alternate !== null && (i = t),
                t = t.sibling;
            i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null
        }
}
function ci(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , i = 0;
    if (e)
        for (var r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags & 14680064,
            i |= r.flags & 14680064,
            r.return = n,
            r = r.sibling;
    else
        for (r = n.child; r !== null; )
            t |= r.lanes | r.childLanes,
            i |= r.subtreeFlags,
            i |= r.flags,
            r.return = n,
            r = r.sibling;
    return n.subtreeFlags |= i,
    n.childLanes = t,
    e
}
function dU(n, e, t) {
    var i = e.pendingProps;
    switch (LS(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return ci(e),
        null;
    case 1:
        return Ui(e.type) && Lm(),
        ci(e),
        null;
    case 3:
        return i = e.stateNode,
        Fc(),
        on(Di),
        on(pi),
        BS(),
        i.pendingContext && (i.context = i.pendingContext,
        i.pendingContext = null),
        (n === null || n.child === null) && (Kh(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        Wr !== null && (tx(Wr),
        Wr = null))),
        j_(n, e),
        ci(e),
        null;
    case 5:
        zS(e);
        var r = Da(Yf.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            kb(n, e, t, i, r),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!i) {
                if (e.stateNode === null)
                    throw Error(De(166));
                return ci(e),
                null
            }
            if (n = Da(xs.current),
            Kh(e)) {
                i = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (i[ys] = e,
                i[$f] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    tn("cancel", i),
                    tn("close", i);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    tn("load", i);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < hf.length; r++)
                        tn(hf[r], i);
                    break;
                case "source":
                    tn("error", i);
                    break;
                case "img":
                case "image":
                case "link":
                    tn("error", i),
                    tn("load", i);
                    break;
                case "details":
                    tn("toggle", i);
                    break;
                case "input":
                    oE(i, s),
                    tn("invalid", i);
                    break;
                case "select":
                    i._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    tn("invalid", i);
                    break;
                case "textarea":
                    lE(i, s),
                    tn("invalid", i)
                }
                x_(t, s),
                r = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && qh(i.textContent, a, n),
                        r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && qh(i.textContent, a, n),
                        r = ["children", "" + a]) : kf.hasOwnProperty(o) && a != null && o === "onScroll" && tn("scroll", i)
                    }
                switch (t) {
                case "input":
                    Vh(i),
                    aE(i, s, !0);
                    break;
                case "textarea":
                    Vh(i),
                    cE(i);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (i.onclick = Pm)
                }
                i = r,
                e.updateQueue = i,
                i !== null && (e.flags |= 4)
            } else {
                o = r.nodeType === 9 ? r : r.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = uC(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, {
                    is: i.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t),
                n[ys] = e,
                n[$f] = i,
                Ub(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = S_(t, i),
                    t) {
                    case "dialog":
                        tn("cancel", n),
                        tn("close", n),
                        r = i;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        tn("load", n),
                        r = i;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < hf.length; r++)
                            tn(hf[r], n);
                        r = i;
                        break;
                    case "source":
                        tn("error", n),
                        r = i;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        tn("error", n),
                        tn("load", n),
                        r = i;
                        break;
                    case "details":
                        tn("toggle", n),
                        r = i;
                        break;
                    case "input":
                        oE(n, i),
                        r = m_(n, i),
                        tn("invalid", n);
                        break;
                    case "option":
                        r = i;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!i.multiple
                        },
                        r = mn({}, i, {
                            value: void 0
                        }),
                        tn("invalid", n);
                        break;
                    case "textarea":
                        lE(n, i),
                        r = y_(n, i),
                        tn("invalid", n);
                        break;
                    default:
                        r = i
                    }
                    x_(t, r),
                    a = r;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? hC(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && fC(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Of(n, l) : typeof l == "number" && Of(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (kf.hasOwnProperty(s) ? l != null && s === "onScroll" && tn("scroll", n) : l != null && gS(n, s, l, o))
                        }
                    switch (t) {
                    case "input":
                        Vh(n),
                        aE(n, i, !1);
                        break;
                    case "textarea":
                        Vh(n),
                        cE(n);
                        break;
                    case "option":
                        i.value != null && n.setAttribute("value", "" + qo(i.value));
                        break;
                    case "select":
                        n.multiple = !!i.multiple,
                        s = i.value,
                        s != null ? wc(n, !!i.multiple, s, !1) : i.defaultValue != null && wc(n, !!i.multiple, i.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (n.onclick = Pm)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!i.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                }
                i && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return ci(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            Ob(n, e, n.memoizedProps, i);
        else {
            if (typeof i != "string" && e.stateNode === null)
                throw Error(De(166));
            if (t = Da(Yf.current),
            Da(xs.current),
            Kh(e)) {
                if (i = e.stateNode,
                t = e.memoizedProps,
                i[ys] = e,
                (s = i.nodeValue !== t) && (n = Zi,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        qh(i.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && qh(i.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i),
                i[ys] = e,
                e.stateNode = i
        }
        return ci(e),
        null;
    case 13:
        if (on(fn),
        i = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (ln && ji !== null && e.mode & 1 && !(e.flags & 128))
                eb(),
                kc(),
                e.flags |= 98560,
                s = !1;
            else if (s = Kh(e),
            i !== null && i.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(De(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(De(317));
                    s[ys] = e
                } else
                    kc(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                ci(e),
                s = !1
            } else
                Wr !== null && (tx(Wr),
                Wr = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (i = i !== null,
        i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || fn.current & 1 ? Fn === 0 && (Fn = 3) : QS())),
        e.updateQueue !== null && (e.flags |= 4),
        ci(e),
        null);
    case 4:
        return Fc(),
        j_(n, e),
        n === null && Wf(e.stateNode.containerInfo),
        ci(e),
        null;
    case 10:
        return US(e.type._context),
        ci(e),
        null;
    case 17:
        return Ui(e.type) && Lm(),
        ci(e),
        null;
    case 19:
        if (on(fn),
        s = e.memoizedState,
        s === null)
            return ci(e),
            null;
        if (i = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (i)
                Hu(s, !1);
            else {
                if (Fn !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = Fm(n),
                        o !== null) {
                            for (e.flags |= 128,
                            Hu(s, !1),
                            i = o.updateQueue,
                            i !== null && (e.updateQueue = i,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            i = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = i,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return Jt(fn, fn.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && En() > Bc && (e.flags |= 128,
                i = !0,
                Hu(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!i)
                if (n = Fm(o),
                n !== null) {
                    if (e.flags |= 128,
                    i = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    Hu(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !ln)
                        return ci(e),
                        null
                } else
                    2 * En() - s.renderingStartTime > Bc && t !== 1073741824 && (e.flags |= 128,
                    i = !0,
                    Hu(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = En(),
        e.sibling = null,
        t = fn.current,
        Jt(fn, i ? t & 1 | 2 : t & 1),
        e) : (ci(e),
        null);
    case 22:
    case 23:
        return ZS(),
        i = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== i && (e.flags |= 8192),
        i && e.mode & 1 ? $i & 1073741824 && (ci(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : ci(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(De(156, e.tag))
}
function hU(n, e) {
    switch (LS(e),
    e.tag) {
    case 1:
        return Ui(e.type) && Lm(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return Fc(),
        on(Di),
        on(pi),
        BS(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return zS(e),
        null;
    case 13:
        if (on(fn),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(De(340));
            kc()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return on(fn),
        null;
    case 4:
        return Fc(),
        null;
    case 10:
        return US(e.type._context),
        null;
    case 22:
    case 23:
        return ZS(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jh = !1
  , di = !1
  , pU = typeof WeakSet == "function" ? WeakSet : Set
  , qe = null;
function mc(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (i) {
                yn(n, e, i)
            }
        else
            t.current = null
}
function Y_(n, e, t) {
    try {
        t()
    } catch (i) {
        yn(n, e, i)
    }
}
var QE = !1;
function mU(n, e) {
    if (L_ = Rm,
    n = VC(),
    bS(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var i = t.getSelection && t.getSelection();
                if (i && i.rangeCount !== 0) {
                    t = i.anchorNode;
                    var r = i.anchorOffset
                      , s = i.focusNode;
                    i = i.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , f = 0
                      , d = 0
                      , h = n
                      , p = null;
                    t: for (; ; ) {
                        for (var m; h !== t || r !== 0 && h.nodeType !== 3 || (a = o + r),
                        h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (m = h.firstChild) !== null; )
                            p = h,
                            h = m;
                        for (; ; ) {
                            if (h === n)
                                break t;
                            if (p === t && ++f === r && (a = o),
                            p === s && ++d === i && (l = o),
                            (m = h.nextSibling) !== null)
                                break;
                            h = p,
                            p = h.parentNode
                        }
                        h = m
                    }
                    t = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (I_ = {
        focusedElem: n,
        selectionRange: t
    },
    Rm = !1,
    qe = e; qe !== null; )
        if (e = qe,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            qe = n;
        else
            for (; qe !== null; ) {
                e = qe;
                try {
                    var y = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (y !== null) {
                                var S = y.memoizedProps
                                  , M = y.memoizedState
                                  , g = e.stateNode
                                  , _ = g.getSnapshotBeforeUpdate(e.elementType === e.type ? S : Vr(e.type, S), M);
                                g.__reactInternalSnapshotBeforeUpdate = _
                            }
                            break;
                        case 3:
                            var w = e.stateNode.containerInfo;
                            w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(De(163))
                        }
                } catch (T) {
                    yn(e, e.return, T)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    qe = n;
                    break
                }
                qe = e.return
            }
    return y = QE,
    QE = !1,
    y
}
function Mf(n, e, t) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null,
    i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                r.destroy = void 0,
                s !== void 0 && Y_(e, t, s)
            }
            r = r.next
        } while (r !== i)
    }
}
function hg(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i()
            }
            t = t.next
        } while (t !== e)
    }
}
function q_(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function Fb(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    Fb(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[ys],
    delete e[$f],
    delete e[U_],
    delete e[ZD],
    delete e[QD])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function zb(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function JE(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || zb(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function K_(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = Pm));
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (K_(n, e, t),
        n = n.sibling; n !== null; )
            K_(n, e, t),
            n = n.sibling
}
function Z_(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && (n = n.child,
    n !== null))
        for (Z_(n, e, t),
        n = n.sibling; n !== null; )
            Z_(n, e, t),
            n = n.sibling
}
var Jn = null
  , Gr = !1;
function yo(n, e, t) {
    for (t = t.child; t !== null; )
        Bb(n, e, t),
        t = t.sibling
}
function Bb(n, e, t) {
    if (_s && typeof _s.onCommitFiberUnmount == "function")
        try {
            _s.onCommitFiberUnmount(sg, t)
        } catch {}
    switch (t.tag) {
    case 5:
        di || mc(t, e);
    case 6:
        var i = Jn
          , r = Gr;
        Jn = null,
        yo(n, e, t),
        Jn = i,
        Gr = r,
        Jn !== null && (Gr ? (n = Jn,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Jn.removeChild(t.stateNode));
        break;
    case 18:
        Jn !== null && (Gr ? (n = Jn,
        t = t.stateNode,
        n.nodeType === 8 ? Yv(n.parentNode, t) : n.nodeType === 1 && Yv(n, t),
        Vf(n)) : Yv(Jn, t.stateNode));
        break;
    case 4:
        i = Jn,
        r = Gr,
        Jn = t.stateNode.containerInfo,
        Gr = !0,
        yo(n, e, t),
        Jn = i,
        Gr = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!di && (i = t.updateQueue,
        i !== null && (i = i.lastEffect,
        i !== null))) {
            r = i = i.next;
            do {
                var s = r
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && Y_(t, e, o),
                r = r.next
            } while (r !== i)
        }
        yo(n, e, t);
        break;
    case 1:
        if (!di && (mc(t, e),
        i = t.stateNode,
        typeof i.componentWillUnmount == "function"))
            try {
                i.props = t.memoizedProps,
                i.state = t.memoizedState,
                i.componentWillUnmount()
            } catch (a) {
                yn(t, e, a)
            }
        yo(n, e, t);
        break;
    case 21:
        yo(n, e, t);
        break;
    case 22:
        t.mode & 1 ? (di = (i = di) || t.memoizedState !== null,
        yo(n, e, t),
        di = i) : yo(n, e, t);
        break;
    default:
        yo(n, e, t)
    }
}
function eT(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new pU),
        e.forEach(function(i) {
            var r = EU.bind(null, n, i);
            t.has(i) || (t.add(i),
            i.then(r, r))
        })
    }
}
function Ur(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        Jn = a.stateNode,
                        Gr = !1;
                        break e;
                    case 3:
                        Jn = a.stateNode.containerInfo,
                        Gr = !0;
                        break e;
                    case 4:
                        Jn = a.stateNode.containerInfo,
                        Gr = !0;
                        break e
                    }
                    a = a.return
                }
                if (Jn === null)
                    throw Error(De(160));
                Bb(s, o, r),
                Jn = null,
                Gr = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (f) {
                yn(r, e, f)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            Vb(e, n),
            e = e.sibling
}
function Vb(n, e) {
    var t = n.alternate
      , i = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Ur(e, n),
        ps(n),
        i & 4) {
            try {
                Mf(3, n, n.return),
                hg(3, n)
            } catch (S) {
                yn(n, n.return, S)
            }
            try {
                Mf(5, n, n.return)
            } catch (S) {
                yn(n, n.return, S)
            }
        }
        break;
    case 1:
        Ur(e, n),
        ps(n),
        i & 512 && t !== null && mc(t, t.return);
        break;
    case 5:
        if (Ur(e, n),
        ps(n),
        i & 512 && t !== null && mc(t, t.return),
        n.flags & 32) {
            var r = n.stateNode;
            try {
                Of(r, "")
            } catch (S) {
                yn(n, n.return, S)
            }
        }
        if (i & 4 && (r = n.stateNode,
        r != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , l = n.updateQueue;
            if (n.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && lC(r, s),
                    S_(a, o);
                    var f = S_(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o]
                          , h = l[o + 1];
                        d === "style" ? hC(r, h) : d === "dangerouslySetInnerHTML" ? fC(r, h) : d === "children" ? Of(r, h) : gS(r, d, h, f)
                    }
                    switch (a) {
                    case "input":
                        g_(r, s);
                        break;
                    case "textarea":
                        cC(r, s);
                        break;
                    case "select":
                        var p = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!s.multiple;
                        var m = s.value;
                        m != null ? wc(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? wc(r, !!s.multiple, s.defaultValue, !0) : wc(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[$f] = s
                } catch (S) {
                    yn(n, n.return, S)
                }
        }
        break;
    case 6:
        if (Ur(e, n),
        ps(n),
        i & 4) {
            if (n.stateNode === null)
                throw Error(De(162));
            r = n.stateNode,
            s = n.memoizedProps;
            try {
                r.nodeValue = s
            } catch (S) {
                yn(n, n.return, S)
            }
        }
        break;
    case 3:
        if (Ur(e, n),
        ps(n),
        i & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                Vf(e.containerInfo)
            } catch (S) {
                yn(n, n.return, S)
            }
        break;
    case 4:
        Ur(e, n),
        ps(n);
        break;
    case 13:
        Ur(e, n),
        ps(n),
        r = n.child,
        r.flags & 8192 && (s = r.memoizedState !== null,
        r.stateNode.isHidden = s,
        !s || r.alternate !== null && r.alternate.memoizedState !== null || (qS = En())),
        i & 4 && eT(n);
        break;
    case 22:
        if (d = t !== null && t.memoizedState !== null,
        n.mode & 1 ? (di = (f = di) || d,
        Ur(e, n),
        di = f) : Ur(e, n),
        ps(n),
        i & 8192) {
            if (f = n.memoizedState !== null,
            (n.stateNode.isHidden = f) && !d && n.mode & 1)
                for (qe = n,
                d = n.child; d !== null; ) {
                    for (h = qe = d; qe !== null; ) {
                        switch (p = qe,
                        m = p.child,
                        p.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Mf(4, p, p.return);
                            break;
                        case 1:
                            mc(p, p.return);
                            var y = p.stateNode;
                            if (typeof y.componentWillUnmount == "function") {
                                i = p,
                                t = p.return;
                                try {
                                    e = i,
                                    y.props = e.memoizedProps,
                                    y.state = e.memoizedState,
                                    y.componentWillUnmount()
                                } catch (S) {
                                    yn(i, t, S)
                                }
                            }
                            break;
                        case 5:
                            mc(p, p.return);
                            break;
                        case 22:
                            if (p.memoizedState !== null) {
                                nT(h);
                                continue
                            }
                        }
                        m !== null ? (m.return = p,
                        qe = m) : nT(h)
                    }
                    d = d.sibling
                }
            e: for (d = null,
            h = n; ; ) {
                if (h.tag === 5) {
                    if (d === null) {
                        d = h;
                        try {
                            r = h.stateNode,
                            f ? (s = r.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = dC("display", o))
                        } catch (S) {
                            yn(n, n.return, S)
                        }
                    }
                } else if (h.tag === 6) {
                    if (d === null)
                        try {
                            h.stateNode.nodeValue = f ? "" : h.memoizedProps
                        } catch (S) {
                            yn(n, n.return, S)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === n)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === n)
                        break e;
                    d === h && (d = null),
                    h = h.return
                }
                d === h && (d = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        Ur(e, n),
        ps(n),
        i & 4 && eT(n);
        break;
    case 21:
        break;
    default:
        Ur(e, n),
        ps(n)
    }
}
function ps(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (zb(t)) {
                        var i = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(De(160))
            }
            switch (i.tag) {
            case 5:
                var r = i.stateNode;
                i.flags & 32 && (Of(r, ""),
                i.flags &= -33);
                var s = JE(n);
                Z_(n, s, r);
                break;
            case 3:
            case 4:
                var o = i.stateNode.containerInfo
                  , a = JE(n);
                K_(n, a, o);
                break;
            default:
                throw Error(De(161))
            }
        } catch (l) {
            yn(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function gU(n, e, t) {
    qe = n,
    Hb(n)
}
function Hb(n, e, t) {
    for (var i = (n.mode & 1) !== 0; qe !== null; ) {
        var r = qe
          , s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Jh;
            if (!o) {
                var a = r.alternate
                  , l = a !== null && a.memoizedState !== null || di;
                a = Jh;
                var f = di;
                if (Jh = o,
                (di = l) && !f)
                    for (qe = r; qe !== null; )
                        o = qe,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? iT(r) : l !== null ? (l.return = o,
                        qe = l) : iT(r);
                for (; s !== null; )
                    qe = s,
                    Hb(s),
                    s = s.sibling;
                qe = r,
                Jh = a,
                di = f
            }
            tT(n)
        } else
            r.subtreeFlags & 8772 && s !== null ? (s.return = r,
            qe = s) : tT(n)
    }
}
function tT(n) {
    for (; qe !== null; ) {
        var e = qe;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        di || hg(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !di)
                            if (t === null)
                                i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : Vr(e.type, t.memoizedProps);
                                i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && FE(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            FE(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var f = e.alternate;
                            if (f !== null) {
                                var d = f.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && Vf(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(De(163))
                    }
                di || e.flags & 512 && q_(e)
            } catch (p) {
                yn(e, e.return, p)
            }
        }
        if (e === n) {
            qe = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            qe = t;
            break
        }
        qe = e.return
    }
}
function nT(n) {
    for (; qe !== null; ) {
        var e = qe;
        if (e === n) {
            qe = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            qe = t;
            break
        }
        qe = e.return
    }
}
function iT(n) {
    for (; qe !== null; ) {
        var e = qe;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    hg(4, e)
                } catch (l) {
                    yn(e, t, l)
                }
                break;
            case 1:
                var i = e.stateNode;
                if (typeof i.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        i.componentDidMount()
                    } catch (l) {
                        yn(e, r, l)
                    }
                }
                var s = e.return;
                try {
                    q_(e)
                } catch (l) {
                    yn(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    q_(e)
                } catch (l) {
                    yn(e, o, l)
                }
            }
        } catch (l) {
            yn(e, e.return, l)
        }
        if (e === n) {
            qe = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            qe = a;
            break
        }
        qe = e.return
    }
}
var vU = Math.ceil
  , Vm = io.ReactCurrentDispatcher
  , jS = io.ReactCurrentOwner
  , Sr = io.ReactCurrentBatchConfig
  , kt = 0
  , jn = null
  , Ln = null
  , ei = 0
  , $i = 0
  , gc = ta(0)
  , Fn = 0
  , Qf = null
  , qa = 0
  , pg = 0
  , YS = 0
  , Ef = null
  , Pi = null
  , qS = 0
  , Bc = 1 / 0
  , Vs = null
  , Hm = !1
  , Q_ = null
  , Ho = null
  , ep = !1
  , Do = null
  , Gm = 0
  , Tf = 0
  , J_ = null
  , cm = -1
  , um = 0;
function xi() {
    return kt & 6 ? En() : cm !== -1 ? cm : cm = En()
}
function Go(n) {
    return n.mode & 1 ? kt & 2 && ei !== 0 ? ei & -ei : eU.transition !== null ? (um === 0 && (um = TC()),
    um) : (n = Xt,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : IC(n.type)),
    n) : 1
}
function Yr(n, e, t, i) {
    if (50 < Tf)
        throw Tf = 0,
        J_ = null,
        Error(De(185));
    hd(n, t, i),
    (!(kt & 2) || n !== jn) && (n === jn && (!(kt & 2) && (pg |= t),
    Fn === 4 && Io(n, ei)),
    ki(n, i),
    t === 1 && kt === 0 && !(e.mode & 1) && (Bc = En() + 500,
    ug && na()))
}
function ki(n, e) {
    var t = n.callbackNode;
    eD(n, e);
    var i = Am(n, n === jn ? ei : 0);
    if (i === 0)
        t !== null && dE(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = i & -i,
    n.callbackPriority !== e) {
        if (t != null && dE(t),
        e === 1)
            n.tag === 0 ? JD(rT.bind(null, n)) : ZC(rT.bind(null, n)),
            qD(function() {
                !(kt & 6) && na()
            }),
            t = null;
        else {
            switch (AC(i)) {
            case 1:
                t = SS;
                break;
            case 4:
                t = MC;
                break;
            case 16:
                t = Tm;
                break;
            case 536870912:
                t = EC;
                break;
            default:
                t = Tm
            }
            t = Kb(t, Gb.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function Gb(n, e) {
    if (cm = -1,
    um = 0,
    kt & 6)
        throw Error(De(327));
    var t = n.callbackNode;
    if (Rc() && n.callbackNode !== t)
        return null;
    var i = Am(n, n === jn ? ei : 0);
    if (i === 0)
        return null;
    if (i & 30 || i & n.expiredLanes || e)
        e = Wm(n, i);
    else {
        e = i;
        var r = kt;
        kt |= 2;
        var s = Xb();
        (jn !== n || ei !== e) && (Vs = null,
        Bc = En() + 500,
        za(n, e));
        do
            try {
                xU();
                break
            } catch (a) {
                Wb(n, a)
            }
        while (1);
        DS(),
        Vm.current = s,
        kt = r,
        Ln !== null ? e = 0 : (jn = null,
        ei = 0,
        e = Fn)
    }
    if (e !== 0) {
        if (e === 2 && (r = A_(n),
        r !== 0 && (i = r,
        e = ex(n, r))),
        e === 1)
            throw t = Qf,
            za(n, 0),
            Io(n, i),
            ki(n, En()),
            t;
        if (e === 6)
            Io(n, i);
        else {
            if (r = n.current.alternate,
            !(i & 30) && !yU(r) && (e = Wm(n, i),
            e === 2 && (s = A_(n),
            s !== 0 && (i = s,
            e = ex(n, s))),
            e === 1))
                throw t = Qf,
                za(n, 0),
                Io(n, i),
                ki(n, En()),
                t;
            switch (n.finishedWork = r,
            n.finishedLanes = i,
            e) {
            case 0:
            case 1:
                throw Error(De(345));
            case 2:
                Ra(n, Pi, Vs);
                break;
            case 3:
                if (Io(n, i),
                (i & 130023424) === i && (e = qS + 500 - En(),
                10 < e)) {
                    if (Am(n, 0) !== 0)
                        break;
                    if (r = n.suspendedLanes,
                    (r & i) !== i) {
                        xi(),
                        n.pingedLanes |= n.suspendedLanes & r;
                        break
                    }
                    n.timeoutHandle = D_(Ra.bind(null, n, Pi, Vs), e);
                    break
                }
                Ra(n, Pi, Vs);
                break;
            case 4:
                if (Io(n, i),
                (i & 4194240) === i)
                    break;
                for (e = n.eventTimes,
                r = -1; 0 < i; ) {
                    var o = 31 - jr(i);
                    s = 1 << o,
                    o = e[o],
                    o > r && (r = o),
                    i &= ~s
                }
                if (i = r,
                i = En() - i,
                i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * vU(i / 1960)) - i,
                10 < i) {
                    n.timeoutHandle = D_(Ra.bind(null, n, Pi, Vs), i);
                    break
                }
                Ra(n, Pi, Vs);
                break;
            case 5:
                Ra(n, Pi, Vs);
                break;
            default:
                throw Error(De(329))
            }
        }
    }
    return ki(n, En()),
    n.callbackNode === t ? Gb.bind(null, n) : null
}
function ex(n, e) {
    var t = Ef;
    return n.current.memoizedState.isDehydrated && (za(n, e).flags |= 256),
    n = Wm(n, e),
    n !== 2 && (e = Pi,
    Pi = t,
    e !== null && tx(e)),
    n
}
function tx(n) {
    Pi === null ? Pi = n : Pi.push.apply(Pi, n)
}
function yU(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i]
                      , s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!Kr(s(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Io(n, e) {
    for (e &= ~YS,
    e &= ~pg,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - jr(e)
          , i = 1 << t;
        n[t] = -1,
        e &= ~i
    }
}
function rT(n) {
    if (kt & 6)
        throw Error(De(327));
    Rc();
    var e = Am(n, 0);
    if (!(e & 1))
        return ki(n, En()),
        null;
    var t = Wm(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = A_(n);
        i !== 0 && (e = i,
        t = ex(n, i))
    }
    if (t === 1)
        throw t = Qf,
        za(n, 0),
        Io(n, e),
        ki(n, En()),
        t;
    if (t === 6)
        throw Error(De(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    Ra(n, Pi, Vs),
    ki(n, En()),
    null
}
function KS(n, e) {
    var t = kt;
    kt |= 1;
    try {
        return n(e)
    } finally {
        kt = t,
        kt === 0 && (Bc = En() + 500,
        ug && na())
    }
}
function Ka(n) {
    Do !== null && Do.tag === 0 && !(kt & 6) && Rc();
    var e = kt;
    kt |= 1;
    var t = Sr.transition
      , i = Xt;
    try {
        if (Sr.transition = null,
        Xt = 1,
        n)
            return n()
    } finally {
        Xt = i,
        Sr.transition = t,
        kt = e,
        !(kt & 6) && na()
    }
}
function ZS() {
    $i = gc.current,
    on(gc)
}
function za(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    YD(t)),
    Ln !== null)
        for (t = Ln.return; t !== null; ) {
            var i = t;
            switch (LS(i),
            i.tag) {
            case 1:
                i = i.type.childContextTypes,
                i != null && Lm();
                break;
            case 3:
                Fc(),
                on(Di),
                on(pi),
                BS();
                break;
            case 5:
                zS(i);
                break;
            case 4:
                Fc();
                break;
            case 13:
                on(fn);
                break;
            case 19:
                on(fn);
                break;
            case 10:
                US(i.type._context);
                break;
            case 22:
            case 23:
                ZS()
            }
            t = t.return
        }
    if (jn = n,
    Ln = n = Wo(n.current, null),
    ei = $i = e,
    Fn = 0,
    Qf = null,
    YS = pg = qa = 0,
    Pi = Ef = null,
    Na !== null) {
        for (e = 0; e < Na.length; e++)
            if (t = Na[e],
            i = t.interleaved,
            i !== null) {
                t.interleaved = null;
                var r = i.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r,
                    i.next = o
                }
                t.pending = i
            }
        Na = null
    }
    return n
}
function Wb(n, e) {
    do {
        var t = Ln;
        try {
            if (DS(),
            om.current = Bm,
            zm) {
                for (var i = pn.memoizedState; i !== null; ) {
                    var r = i.queue;
                    r !== null && (r.pending = null),
                    i = i.next
                }
                zm = !1
            }
            if (Ya = 0,
            $n = kn = pn = null,
            wf = !1,
            qf = 0,
            jS.current = null,
            t === null || t.return === null) {
                Fn = 1,
                Qf = e,
                Ln = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , l = e;
                if (e = ei,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var f = l
                      , d = a
                      , h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = d.alternate;
                        p ? (d.updateQueue = p.updateQueue,
                        d.memoizedState = p.memoizedState,
                        d.lanes = p.lanes) : (d.updateQueue = null,
                        d.memoizedState = null)
                    }
                    var m = XE(o);
                    if (m !== null) {
                        m.flags &= -257,
                        $E(m, o, a, s, e),
                        m.mode & 1 && WE(s, f, e),
                        e = m,
                        l = f;
                        var y = e.updateQueue;
                        if (y === null) {
                            var S = new Set;
                            S.add(l),
                            e.updateQueue = S
                        } else
                            y.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            WE(s, f, e),
                            QS();
                            break e
                        }
                        l = Error(De(426))
                    }
                } else if (ln && a.mode & 1) {
                    var M = XE(o);
                    if (M !== null) {
                        !(M.flags & 65536) && (M.flags |= 256),
                        $E(M, o, a, s, e),
                        IS(zc(l, a));
                        break e
                    }
                }
                s = l = zc(l, a),
                Fn !== 4 && (Fn = 2),
                Ef === null ? Ef = [s] : Ef.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var g = Rb(s, l, e);
                        OE(s, g);
                        break e;
                    case 1:
                        a = l;
                        var _ = s.type
                          , w = s.stateNode;
                        if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (Ho === null || !Ho.has(w)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var T = Cb(s, a, e);
                            OE(s, T);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            jb(t)
        } catch (A) {
            e = A,
            Ln === t && t !== null && (Ln = t = t.return);
            continue
        }
        break
    } while (1)
}
function Xb() {
    var n = Vm.current;
    return Vm.current = Bm,
    n === null ? Bm : n
}
function QS() {
    (Fn === 0 || Fn === 3 || Fn === 2) && (Fn = 4),
    jn === null || !(qa & 268435455) && !(pg & 268435455) || Io(jn, ei)
}
function Wm(n, e) {
    var t = kt;
    kt |= 2;
    var i = Xb();
    (jn !== n || ei !== e) && (Vs = null,
    za(n, e));
    do
        try {
            _U();
            break
        } catch (r) {
            Wb(n, r)
        }
    while (1);
    if (DS(),
    kt = t,
    Vm.current = i,
    Ln !== null)
        throw Error(De(261));
    return jn = null,
    ei = 0,
    Fn
}
function _U() {
    for (; Ln !== null; )
        $b(Ln)
}
function xU() {
    for (; Ln !== null && !XN(); )
        $b(Ln)
}
function $b(n) {
    var e = qb(n.alternate, n, $i);
    n.memoizedProps = n.pendingProps,
    e === null ? jb(n) : Ln = e,
    jS.current = null
}
function jb(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = hU(t, e),
            t !== null) {
                t.flags &= 32767,
                Ln = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                Fn = 6,
                Ln = null;
                return
            }
        } else if (t = dU(t, e, $i),
        t !== null) {
            Ln = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Ln = e;
            return
        }
        Ln = e = n
    } while (e !== null);
    Fn === 0 && (Fn = 5)
}
function Ra(n, e, t) {
    var i = Xt
      , r = Sr.transition;
    try {
        Sr.transition = null,
        Xt = 1,
        SU(n, e, t, i)
    } finally {
        Sr.transition = r,
        Xt = i
    }
    return null
}
function SU(n, e, t, i) {
    do
        Rc();
    while (Do !== null);
    if (kt & 6)
        throw Error(De(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(De(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (tD(n, s),
    n === jn && (Ln = jn = null,
    ei = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || ep || (ep = !0,
    Kb(Tm, function() {
        return Rc(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = Sr.transition,
        Sr.transition = null;
        var o = Xt;
        Xt = 1;
        var a = kt;
        kt |= 4,
        jS.current = null,
        mU(n, t),
        Vb(t, n),
        VD(I_),
        Rm = !!L_,
        I_ = L_ = null,
        n.current = t,
        gU(t),
        $N(),
        kt = a,
        Xt = o,
        Sr.transition = s
    } else
        n.current = t;
    if (ep && (ep = !1,
    Do = n,
    Gm = r),
    s = n.pendingLanes,
    s === 0 && (Ho = null),
    qN(t.stateNode),
    ki(n, En()),
    e !== null)
        for (i = n.onRecoverableError,
        t = 0; t < e.length; t++)
            r = e[t],
            i(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (Hm)
        throw Hm = !1,
        n = Q_,
        Q_ = null,
        n;
    return Gm & 1 && n.tag !== 0 && Rc(),
    s = n.pendingLanes,
    s & 1 ? n === J_ ? Tf++ : (Tf = 0,
    J_ = n) : Tf = 0,
    na(),
    null
}
function Rc() {
    if (Do !== null) {
        var n = AC(Gm)
          , e = Sr.transition
          , t = Xt;
        try {
            if (Sr.transition = null,
            Xt = 16 > n ? 16 : n,
            Do === null)
                var i = !1;
            else {
                if (n = Do,
                Do = null,
                Gm = 0,
                kt & 6)
                    throw Error(De(331));
                var r = kt;
                for (kt |= 4,
                qe = n.current; qe !== null; ) {
                    var s = qe
                      , o = s.child;
                    if (qe.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var f = a[l];
                                for (qe = f; qe !== null; ) {
                                    var d = qe;
                                    switch (d.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Mf(8, d, s)
                                    }
                                    var h = d.child;
                                    if (h !== null)
                                        h.return = d,
                                        qe = h;
                                    else
                                        for (; qe !== null; ) {
                                            d = qe;
                                            var p = d.sibling
                                              , m = d.return;
                                            if (Fb(d),
                                            d === f) {
                                                qe = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = m,
                                                qe = p;
                                                break
                                            }
                                            qe = m
                                        }
                                }
                            }
                            var y = s.alternate;
                            if (y !== null) {
                                var S = y.child;
                                if (S !== null) {
                                    y.child = null;
                                    do {
                                        var M = S.sibling;
                                        S.sibling = null,
                                        S = M
                                    } while (S !== null)
                                }
                            }
                            qe = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        qe = o;
                    else
                        e: for (; qe !== null; ) {
                            if (s = qe,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Mf(9, s, s.return)
                                }
                            var g = s.sibling;
                            if (g !== null) {
                                g.return = s.return,
                                qe = g;
                                break e
                            }
                            qe = s.return
                        }
                }
                var _ = n.current;
                for (qe = _; qe !== null; ) {
                    o = qe;
                    var w = o.child;
                    if (o.subtreeFlags & 2064 && w !== null)
                        w.return = o,
                        qe = w;
                    else
                        e: for (o = _; qe !== null; ) {
                            if (a = qe,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        hg(9, a)
                                    }
                                } catch (A) {
                                    yn(a, a.return, A)
                                }
                            if (a === o) {
                                qe = null;
                                break e
                            }
                            var T = a.sibling;
                            if (T !== null) {
                                T.return = a.return,
                                qe = T;
                                break e
                            }
                            qe = a.return
                        }
                }
                if (kt = r,
                na(),
                _s && typeof _s.onPostCommitFiberRoot == "function")
                    try {
                        _s.onPostCommitFiberRoot(sg, n)
                    } catch {}
                i = !0
            }
            return i
        } finally {
            Xt = t,
            Sr.transition = e
        }
    }
    return !1
}
function sT(n, e, t) {
    e = zc(t, e),
    e = Rb(n, e, 1),
    n = Vo(n, e, 1),
    e = xi(),
    n !== null && (hd(n, 1, e),
    ki(n, e))
}
function yn(n, e, t) {
    if (n.tag === 3)
        sT(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                sT(e, n, t);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Ho === null || !Ho.has(i))) {
                    n = zc(t, n),
                    n = Cb(e, n, 1),
                    e = Vo(e, n, 1),
                    n = xi(),
                    e !== null && (hd(e, 1, n),
                    ki(e, n));
                    break
                }
            }
            e = e.return
        }
}
function wU(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e),
    e = xi(),
    n.pingedLanes |= n.suspendedLanes & t,
    jn === n && (ei & t) === t && (Fn === 4 || Fn === 3 && (ei & 130023424) === ei && 500 > En() - qS ? za(n, 0) : YS |= t),
    ki(n, e)
}
function Yb(n, e) {
    e === 0 && (n.mode & 1 ? (e = Wh,
    Wh <<= 1,
    !(Wh & 130023424) && (Wh = 4194304)) : e = 1);
    var t = xi();
    n = Js(n, e),
    n !== null && (hd(n, e, t),
    ki(n, t))
}
function MU(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    Yb(n, t)
}
function EU(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var i = n.stateNode
          , r = n.memoizedState;
        r !== null && (t = r.retryLane);
        break;
    case 19:
        i = n.stateNode;
        break;
    default:
        throw Error(De(314))
    }
    i !== null && i.delete(e),
    Yb(n, t)
}
var qb;
qb = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || Di.current)
            Ni = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return Ni = !1,
                fU(n, e, t);
            Ni = !!(n.flags & 131072)
        }
    else
        Ni = !1,
        ln && e.flags & 1048576 && QC(e, Dm, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var i = e.type;
        lm(n, e),
        n = e.pendingProps;
        var r = Uc(e, pi.current);
        Ac(e, t),
        r = HS(null, e, i, n, r, t);
        var s = GS();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Ui(i) ? (s = !0,
        Im(e)) : s = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        OS(e),
        r.updater = fg,
        e.stateNode = r,
        r._reactInternals = e,
        V_(e, i, n, t),
        e = W_(null, e, i, !0, s, t)) : (e.tag = 0,
        ln && s && PS(e),
        _i(null, e, r, t),
        e = e.child),
        e;
    case 16:
        i = e.elementType;
        e: {
            switch (lm(n, e),
            n = e.pendingProps,
            r = i._init,
            i = r(i._payload),
            e.type = i,
            r = e.tag = AU(i),
            n = Vr(i, n),
            r) {
            case 0:
                e = G_(null, e, i, n, t);
                break e;
            case 1:
                e = qE(null, e, i, n, t);
                break e;
            case 11:
                e = jE(null, e, i, n, t);
                break e;
            case 14:
                e = YE(null, e, i, Vr(i.type, n), t);
                break e
            }
            throw Error(De(306, i, ""))
        }
        return e;
    case 0:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Vr(i, r),
        G_(n, e, i, r, t);
    case 1:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Vr(i, r),
        qE(n, e, i, r, t);
    case 3:
        e: {
            if (Ib(e),
            n === null)
                throw Error(De(387));
            i = e.pendingProps,
            s = e.memoizedState,
            r = s.element,
            nb(n, e),
            Om(e, i, null, t);
            var o = e.memoizedState;
            if (i = o.element,
            s.isDehydrated)
                if (s = {
                    element: i,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    r = zc(Error(De(423)), e),
                    e = KE(n, e, i, t, r);
                    break e
                } else if (i !== r) {
                    r = zc(Error(De(424)), e),
                    e = KE(n, e, i, t, r);
                    break e
                } else
                    for (ji = Bo(e.stateNode.containerInfo.firstChild),
                    Zi = e,
                    ln = !0,
                    Wr = null,
                    t = ob(e, null, i, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (kc(),
                i === r) {
                    e = eo(n, e, t);
                    break e
                }
                _i(n, e, i, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return ab(e),
        n === null && F_(e),
        i = e.type,
        r = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = r.children,
        N_(i, r) ? o = null : s !== null && N_(i, s) && (e.flags |= 32),
        Lb(n, e),
        _i(n, e, o, t),
        e.child;
    case 6:
        return n === null && F_(e),
        null;
    case 13:
        return Nb(n, e, t);
    case 4:
        return FS(e, e.stateNode.containerInfo),
        i = e.pendingProps,
        n === null ? e.child = Oc(e, null, i, t) : _i(n, e, i, t),
        e.child;
    case 11:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Vr(i, r),
        jE(n, e, i, r, t);
    case 7:
        return _i(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return _i(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return _i(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (i = e.type._context,
            r = e.pendingProps,
            s = e.memoizedProps,
            o = r.value,
            Jt(Um, i._currentValue),
            i._currentValue = o,
            s !== null)
                if (Kr(s.value, o)) {
                    if (s.children === r.children && !Di.current) {
                        e = eo(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === i) {
                                    if (s.tag === 1) {
                                        l = qs(-1, t & -t),
                                        l.tag = 2;
                                        var f = s.updateQueue;
                                        if (f !== null) {
                                            f = f.shared;
                                            var d = f.pending;
                                            d === null ? l.next = l : (l.next = d.next,
                                            d.next = l),
                                            f.pending = l
                                        }
                                    }
                                    s.lanes |= t,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= t),
                                    z_(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(De(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            z_(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            _i(n, e, r.children, t),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        i = e.pendingProps.children,
        Ac(e, t),
        r = wr(r),
        i = i(r),
        e.flags |= 1,
        _i(n, e, i, t),
        e.child;
    case 14:
        return i = e.type,
        r = Vr(i, e.pendingProps),
        r = Vr(i.type, r),
        YE(n, e, i, r, t);
    case 15:
        return bb(n, e, e.type, e.pendingProps, t);
    case 17:
        return i = e.type,
        r = e.pendingProps,
        r = e.elementType === i ? r : Vr(i, r),
        lm(n, e),
        e.tag = 1,
        Ui(i) ? (n = !0,
        Im(e)) : n = !1,
        Ac(e, t),
        rb(e, i, r),
        V_(e, i, r, t),
        W_(null, e, i, !0, n, t);
    case 19:
        return Db(n, e, t);
    case 22:
        return Pb(n, e, t)
    }
    throw Error(De(156, e.tag))
}
;
function Kb(n, e) {
    return wC(n, e)
}
function TU(n, e, t, i) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = i,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function _r(n, e, t, i) {
    return new TU(n,e,t,i)
}
function JS(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function AU(n) {
    if (typeof n == "function")
        return JS(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === yS)
            return 11;
        if (n === _S)
            return 14
    }
    return 2
}
function Wo(n, e) {
    var t = n.alternate;
    return t === null ? (t = _r(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function fm(n, e, t, i, r, s) {
    var o = 2;
    if (i = n,
    typeof n == "function")
        JS(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case oc:
            return Ba(t.children, r, s, e);
        case vS:
            o = 8,
            r |= 8;
            break;
        case f_:
            return n = _r(12, t, e, r | 2),
            n.elementType = f_,
            n.lanes = s,
            n;
        case d_:
            return n = _r(13, t, e, r),
            n.elementType = d_,
            n.lanes = s,
            n;
        case h_:
            return n = _r(19, t, e, r),
            n.elementType = h_,
            n.lanes = s,
            n;
        case sC:
            return mg(t, r, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case iC:
                    o = 10;
                    break e;
                case rC:
                    o = 9;
                    break e;
                case yS:
                    o = 11;
                    break e;
                case _S:
                    o = 14;
                    break e;
                case Ao:
                    o = 16,
                    i = null;
                    break e
                }
            throw Error(De(130, n == null ? n : typeof n, ""))
        }
    return e = _r(o, t, e, r),
    e.elementType = n,
    e.type = i,
    e.lanes = s,
    e
}
function Ba(n, e, t, i) {
    return n = _r(7, n, i, e),
    n.lanes = t,
    n
}
function mg(n, e, t, i) {
    return n = _r(22, n, i, e),
    n.elementType = sC,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function ny(n, e, t) {
    return n = _r(6, n, null, e),
    n.lanes = t,
    n
}
function iy(n, e, t) {
    return e = _r(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function RU(n, e, t, i, r) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Ov(0),
    this.expirationTimes = Ov(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Ov(0),
    this.identifierPrefix = i,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function e1(n, e, t, i, r, s, o, a, l) {
    return n = new RU(n,e,t,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = _r(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: i,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    OS(s),
    n
}
function CU(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: sc,
        key: i == null ? null : "" + i,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function Zb(n) {
    if (!n)
        return Ko;
    n = n._reactInternals;
    e: {
        if (ll(n) !== n || n.tag !== 1)
            throw Error(De(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Ui(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(De(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (Ui(t))
            return KC(n, t, e)
    }
    return e
}
function Qb(n, e, t, i, r, s, o, a, l) {
    return n = e1(t, i, !0, n, r, s, o, a, l),
    n.context = Zb(null),
    t = n.current,
    i = xi(),
    r = Go(t),
    s = qs(i, r),
    s.callback = e ?? null,
    Vo(t, s, r),
    n.current.lanes = r,
    hd(n, r, i),
    ki(n, i),
    n
}
function gg(n, e, t, i) {
    var r = e.current
      , s = xi()
      , o = Go(r);
    return t = Zb(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = qs(s, o),
    e.payload = {
        element: n
    },
    i = i === void 0 ? null : i,
    i !== null && (e.callback = i),
    n = Vo(r, e, o),
    n !== null && (Yr(n, r, o, s),
    sm(n, r, o)),
    o
}
function Xm(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function oT(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function t1(n, e) {
    oT(n, e),
    (n = n.alternate) && oT(n, e)
}
function bU() {
    return null
}
var Jb = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function n1(n) {
    this._internalRoot = n
}
vg.prototype.render = n1.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(De(409));
    gg(n, e, null, null)
}
;
vg.prototype.unmount = n1.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        Ka(function() {
            gg(null, n, null, null)
        }),
        e[Qs] = null
    }
}
;
function vg(n) {
    this._internalRoot = n
}
vg.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = bC();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < Lo.length && e !== 0 && e < Lo[t].priority; t++)
            ;
        Lo.splice(t, 0, n),
        t === 0 && LC(n)
    }
}
;
function i1(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function yg(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function aT() {}
function PU(n, e, t, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var f = Xm(o);
                s.call(f)
            }
        }
        var o = Qb(e, i, n, 0, null, !1, !1, "", aT);
        return n._reactRootContainer = o,
        n[Qs] = o.current,
        Wf(n.nodeType === 8 ? n.parentNode : n),
        Ka(),
        o
    }
    for (; r = n.lastChild; )
        n.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var f = Xm(l);
            a.call(f)
        }
    }
    var l = e1(n, 0, !1, null, null, !1, !1, "", aT);
    return n._reactRootContainer = l,
    n[Qs] = l.current,
    Wf(n.nodeType === 8 ? n.parentNode : n),
    Ka(function() {
        gg(e, l, t, i)
    }),
    l
}
function _g(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = Xm(o);
                a.call(l)
            }
        }
        gg(e, o, n, r)
    } else
        o = PU(t, e, n, r, i);
    return Xm(o)
}
RC = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = df(e.pendingLanes);
            t !== 0 && (wS(e, t | 1),
            ki(e, En()),
            !(kt & 6) && (Bc = En() + 500,
            na()))
        }
        break;
    case 13:
        Ka(function() {
            var i = Js(n, 1);
            if (i !== null) {
                var r = xi();
                Yr(i, n, 1, r)
            }
        }),
        t1(n, 1)
    }
}
;
MS = function(n) {
    if (n.tag === 13) {
        var e = Js(n, 134217728);
        if (e !== null) {
            var t = xi();
            Yr(e, n, 134217728, t)
        }
        t1(n, 134217728)
    }
}
;
CC = function(n) {
    if (n.tag === 13) {
        var e = Go(n)
          , t = Js(n, e);
        if (t !== null) {
            var i = xi();
            Yr(t, n, e, i)
        }
        t1(n, e)
    }
}
;
bC = function() {
    return Xt
}
;
PC = function(n, e) {
    var t = Xt;
    try {
        return Xt = n,
        e()
    } finally {
        Xt = t
    }
}
;
M_ = function(n, e, t) {
    switch (e) {
    case "input":
        if (g_(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var i = t[e];
                if (i !== n && i.form === n.form) {
                    var r = cg(i);
                    if (!r)
                        throw Error(De(90));
                    aC(i),
                    g_(i, r)
                }
            }
        }
        break;
    case "textarea":
        cC(n, t);
        break;
    case "select":
        e = t.value,
        e != null && wc(n, !!t.multiple, e, !1)
    }
}
;
gC = KS;
vC = Ka;
var LU = {
    usingClientEntryPoint: !1,
    Events: [md, uc, cg, pC, mC, KS]
}
  , Gu = {
    findFiberByHostInstance: Ia,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , IU = {
    bundleType: Gu.bundleType,
    version: Gu.version,
    rendererPackageName: Gu.rendererPackageName,
    rendererConfig: Gu.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: io.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = xC(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: Gu.findFiberByHostInstance || bU,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var tp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!tp.isDisabled && tp.supportsFiber)
        try {
            sg = tp.inject(IU),
            _s = tp
        } catch {}
}
er.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LU;
er.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!i1(e))
        throw Error(De(200));
    return CU(n, e, null, t)
}
;
er.createRoot = function(n, e) {
    if (!i1(n))
        throw Error(De(299));
    var t = !1
      , i = ""
      , r = Jb;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = e1(n, 1, !1, null, null, t, !1, i, r),
    n[Qs] = e.current,
    Wf(n.nodeType === 8 ? n.parentNode : n),
    new n1(e)
}
;
er.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(De(188)) : (n = Object.keys(n).join(","),
        Error(De(268, n)));
    return n = xC(e),
    n = n === null ? null : n.stateNode,
    n
}
;
er.flushSync = function(n) {
    return Ka(n)
}
;
er.hydrate = function(n, e, t) {
    if (!yg(e))
        throw Error(De(200));
    return _g(null, n, e, !0, t)
}
;
er.hydrateRoot = function(n, e, t) {
    if (!i1(n))
        throw Error(De(405));
    var i = t != null && t.hydratedSources || null
      , r = !1
      , s = ""
      , o = Jb;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = Qb(e, null, n, 1, t ?? null, r, !1, s, o),
    n[Qs] = e.current,
    Wf(n),
    i)
        for (n = 0; n < i.length; n++)
            t = i[n],
            r = t._getVersion,
            r = r(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new vg(e)
}
;
er.render = function(n, e, t) {
    if (!yg(e))
        throw Error(De(200));
    return _g(null, n, e, !1, t)
}
;
er.unmountComponentAtNode = function(n) {
    if (!yg(n))
        throw Error(De(40));
    return n._reactRootContainer ? (Ka(function() {
        _g(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Qs] = null
        })
    }),
    !0) : !1
}
;
er.unstable_batchedUpdates = KS;
er.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
    if (!yg(t))
        throw Error(De(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(De(38));
    return _g(n, e, t, !1, i)
}
;
er.version = "18.2.0-next-9e3b772b8-20220608";
function e2() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e2)
        } catch (n) {
            console.error(n)
        }
}
e2(),
QR.exports = er;
var t2 = QR.exports;
const NU = fd(t2);
var lT = t2;
c_.createRoot = lT.createRoot,
c_.hydrateRoot = lT.hydrateRoot;
var n2 = {
    exports: {}
}
  , $t = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var r1 = Symbol.for("react.element"), s1 = Symbol.for("react.portal"), xg = Symbol.for("react.fragment"), Sg = Symbol.for("react.strict_mode"), wg = Symbol.for("react.profiler"), Mg = Symbol.for("react.provider"), Eg = Symbol.for("react.context"), DU = Symbol.for("react.server_context"), Tg = Symbol.for("react.forward_ref"), Ag = Symbol.for("react.suspense"), Rg = Symbol.for("react.suspense_list"), Cg = Symbol.for("react.memo"), bg = Symbol.for("react.lazy"), UU = Symbol.for("react.offscreen"), i2;
i2 = Symbol.for("react.module.reference");
function Tr(n) {
    if (typeof n == "object" && n !== null) {
        var e = n.$$typeof;
        switch (e) {
        case r1:
            switch (n = n.type,
            n) {
            case xg:
            case wg:
            case Sg:
            case Ag:
            case Rg:
                return n;
            default:
                switch (n = n && n.$$typeof,
                n) {
                case DU:
                case Eg:
                case Tg:
                case bg:
                case Cg:
                case Mg:
                    return n;
                default:
                    return e
                }
            }
        case s1:
            return e
        }
    }
}
$t.ContextConsumer = Eg;
$t.ContextProvider = Mg;
$t.Element = r1;
$t.ForwardRef = Tg;
$t.Fragment = xg;
$t.Lazy = bg;
$t.Memo = Cg;
$t.Portal = s1;
$t.Profiler = wg;
$t.StrictMode = Sg;
$t.Suspense = Ag;
$t.SuspenseList = Rg;
$t.isAsyncMode = function() {
    return !1
}
;
$t.isConcurrentMode = function() {
    return !1
}
;
$t.isContextConsumer = function(n) {
    return Tr(n) === Eg
}
;
$t.isContextProvider = function(n) {
    return Tr(n) === Mg
}
;
$t.isElement = function(n) {
    return typeof n == "object" && n !== null && n.$$typeof === r1
}
;
$t.isForwardRef = function(n) {
    return Tr(n) === Tg
}
;
$t.isFragment = function(n) {
    return Tr(n) === xg
}
;
$t.isLazy = function(n) {
    return Tr(n) === bg
}
;
$t.isMemo = function(n) {
    return Tr(n) === Cg
}
;
$t.isPortal = function(n) {
    return Tr(n) === s1
}
;
$t.isProfiler = function(n) {
    return Tr(n) === wg
}
;
$t.isStrictMode = function(n) {
    return Tr(n) === Sg
}
;
$t.isSuspense = function(n) {
    return Tr(n) === Ag
}
;
$t.isSuspenseList = function(n) {
    return Tr(n) === Rg
}
;
$t.isValidElementType = function(n) {
    return typeof n == "string" || typeof n == "function" || n === xg || n === wg || n === Sg || n === Ag || n === Rg || n === UU || typeof n == "object" && n !== null && (n.$$typeof === bg || n.$$typeof === Cg || n.$$typeof === Mg || n.$$typeof === Eg || n.$$typeof === Tg || n.$$typeof === i2 || n.getModuleId !== void 0)
}
;
$t.typeOf = Tr;
n2.exports = $t;
var r2 = n2.exports;
function kU(n) {
    function e(I, U, O, J, F) {
        for (var B = 0, ae = 0, _e = 0, pe = 0, Ee, se, oe = 0, ve = 0, Ce, Re = Ce = Ee = 0, Le = 0, Be = 0, Ze = 0, Ye = 0, pt = O.length, G = pt - 1, k, ee = "", we = "", Ie = "", Fe = "", Je; Le < pt; ) {
            if (se = O.charCodeAt(Le),
            Le === G && ae + pe + _e + B !== 0 && (ae !== 0 && (se = ae === 47 ? 10 : 47),
            pe = _e = B = 0,
            pt++,
            G++),
            ae + pe + _e + B === 0) {
                if (Le === G && (0 < Be && (ee = ee.replace(p, "")),
                0 < ee.trim().length)) {
                    switch (se) {
                    case 32:
                    case 9:
                    case 59:
                    case 13:
                    case 10:
                        break;
                    default:
                        ee += O.charAt(Le)
                    }
                    se = 59
                }
                switch (se) {
                case 123:
                    for (ee = ee.trim(),
                    Ee = ee.charCodeAt(0),
                    Ce = 1,
                    Ye = ++Le; Le < pt; ) {
                        switch (se = O.charCodeAt(Le)) {
                        case 123:
                            Ce++;
                            break;
                        case 125:
                            Ce--;
                            break;
                        case 47:
                            switch (se = O.charCodeAt(Le + 1)) {
                            case 42:
                            case 47:
                                e: {
                                    for (Re = Le + 1; Re < G; ++Re)
                                        switch (O.charCodeAt(Re)) {
                                        case 47:
                                            if (se === 42 && O.charCodeAt(Re - 1) === 42 && Le + 2 !== Re) {
                                                Le = Re + 1;
                                                break e
                                            }
                                            break;
                                        case 10:
                                            if (se === 47) {
                                                Le = Re + 1;
                                                break e
                                            }
                                        }
                                    Le = Re
                                }
                            }
                            break;
                        case 91:
                            se++;
                        case 40:
                            se++;
                        case 34:
                        case 39:
                            for (; Le++ < G && O.charCodeAt(Le) !== se; )
                                ;
                        }
                        if (Ce === 0)
                            break;
                        Le++
                    }
                    switch (Ce = O.substring(Ye, Le),
                    Ee === 0 && (Ee = (ee = ee.replace(h, "").trim()).charCodeAt(0)),
                    Ee) {
                    case 64:
                        switch (0 < Be && (ee = ee.replace(p, "")),
                        se = ee.charCodeAt(1),
                        se) {
                        case 100:
                        case 109:
                        case 115:
                        case 45:
                            Be = U;
                            break;
                        default:
                            Be = fe
                        }
                        if (Ce = e(U, Be, Ce, se, F + 1),
                        Ye = Ce.length,
                        0 < D && (Be = t(fe, ee, Ze),
                        Je = a(3, Ce, Be, U, $, Z, Ye, se, F, J),
                        ee = Be.join(""),
                        Je !== void 0 && (Ye = (Ce = Je.trim()).length) === 0 && (se = 0,
                        Ce = "")),
                        0 < Ye)
                            switch (se) {
                            case 115:
                                ee = ee.replace(C, o);
                            case 100:
                            case 109:
                            case 45:
                                Ce = ee + "{" + Ce + "}";
                                break;
                            case 107:
                                ee = ee.replace(_, "$1 $2"),
                                Ce = ee + "{" + Ce + "}",
                                Ce = ie === 1 || ie === 2 && s("@" + Ce, 3) ? "@-webkit-" + Ce + "@" + Ce : "@" + Ce;
                                break;
                            default:
                                Ce = ee + Ce,
                                J === 112 && (Ce = (we += Ce,
                                ""))
                            }
                        else
                            Ce = "";
                        break;
                    default:
                        Ce = e(U, t(U, ee, Ze), Ce, J, F + 1)
                    }
                    Ie += Ce,
                    Ce = Ze = Be = Re = Ee = 0,
                    ee = "",
                    se = O.charCodeAt(++Le);
                    break;
                case 125:
                case 59:
                    if (ee = (0 < Be ? ee.replace(p, "") : ee).trim(),
                    1 < (Ye = ee.length))
                        switch (Re === 0 && (Ee = ee.charCodeAt(0),
                        Ee === 45 || 96 < Ee && 123 > Ee) && (Ye = (ee = ee.replace(" ", ":")).length),
                        0 < D && (Je = a(1, ee, U, I, $, Z, we.length, J, F, J)) !== void 0 && (Ye = (ee = Je.trim()).length) === 0 && (ee = "\0\0"),
                        Ee = ee.charCodeAt(0),
                        se = ee.charCodeAt(1),
                        Ee) {
                        case 0:
                            break;
                        case 64:
                            if (se === 105 || se === 99) {
                                Fe += ee + O.charAt(Le);
                                break
                            }
                        default:
                            ee.charCodeAt(Ye - 1) !== 58 && (we += r(ee, Ee, se, ee.charCodeAt(2)))
                        }
                    Ze = Be = Re = Ee = 0,
                    ee = "",
                    se = O.charCodeAt(++Le)
                }
            }
            switch (se) {
            case 13:
            case 10:
                ae === 47 ? ae = 0 : 1 + Ee === 0 && J !== 107 && 0 < ee.length && (Be = 1,
                ee += "\0"),
                0 < D * X && a(0, ee, U, I, $, Z, we.length, J, F, J),
                Z = 1,
                $++;
                break;
            case 59:
            case 125:
                if (ae + pe + _e + B === 0) {
                    Z++;
                    break
                }
            default:
                switch (Z++,
                k = O.charAt(Le),
                se) {
                case 9:
                case 32:
                    if (pe + B + ae === 0)
                        switch (oe) {
                        case 44:
                        case 58:
                        case 9:
                        case 32:
                            k = "";
                            break;
                        default:
                            se !== 32 && (k = " ")
                        }
                    break;
                case 0:
                    k = "\\0";
                    break;
                case 12:
                    k = "\\f";
                    break;
                case 11:
                    k = "\\v";
                    break;
                case 38:
                    pe + ae + B === 0 && (Be = Ze = 1,
                    k = "\f" + k);
                    break;
                case 108:
                    if (pe + ae + B + Q === 0 && 0 < Re)
                        switch (Le - Re) {
                        case 2:
                            oe === 112 && O.charCodeAt(Le - 3) === 58 && (Q = oe);
                        case 8:
                            ve === 111 && (Q = ve)
                        }
                    break;
                case 58:
                    pe + ae + B === 0 && (Re = Le);
                    break;
                case 44:
                    ae + _e + pe + B === 0 && (Be = 1,
                    k += "\r");
                    break;
                case 34:
                case 39:
                    ae === 0 && (pe = pe === se ? 0 : pe === 0 ? se : pe);
                    break;
                case 91:
                    pe + ae + _e === 0 && B++;
                    break;
                case 93:
                    pe + ae + _e === 0 && B--;
                    break;
                case 41:
                    pe + ae + B === 0 && _e--;
                    break;
                case 40:
                    if (pe + ae + B === 0) {
                        if (Ee === 0)
                            switch (2 * oe + 3 * ve) {
                            case 533:
                                break;
                            default:
                                Ee = 1
                            }
                        _e++
                    }
                    break;
                case 64:
                    ae + _e + pe + B + Re + Ce === 0 && (Ce = 1);
                    break;
                case 42:
                case 47:
                    if (!(0 < pe + B + _e))
                        switch (ae) {
                        case 0:
                            switch (2 * se + 3 * O.charCodeAt(Le + 1)) {
                            case 235:
                                ae = 47;
                                break;
                            case 220:
                                Ye = Le,
                                ae = 42
                            }
                            break;
                        case 42:
                            se === 47 && oe === 42 && Ye + 2 !== Le && (O.charCodeAt(Ye + 2) === 33 && (we += O.substring(Ye, Le + 1)),
                            k = "",
                            ae = 0)
                        }
                }
                ae === 0 && (ee += k)
            }
            ve = oe,
            oe = se,
            Le++
        }
        if (Ye = we.length,
        0 < Ye) {
            if (Be = U,
            0 < D && (Je = a(2, we, Be, I, $, Z, Ye, J, F, J),
            Je !== void 0 && (we = Je).length === 0))
                return Fe + we + Ie;
            if (we = Be.join(",") + "{" + we + "}",
            ie * Q !== 0) {
                switch (ie !== 2 || s(we, 2) || (Q = 0),
                Q) {
                case 111:
                    we = we.replace(T, ":-moz-$1") + we;
                    break;
                case 112:
                    we = we.replace(w, "::-webkit-input-$1") + we.replace(w, "::-moz-$1") + we.replace(w, ":-ms-input-$1") + we
                }
                Q = 0
            }
        }
        return Fe + we + Ie
    }
    function t(I, U, O) {
        var J = U.trim().split(M);
        U = J;
        var F = J.length
          , B = I.length;
        switch (B) {
        case 0:
        case 1:
            var ae = 0;
            for (I = B === 0 ? "" : I[0] + " "; ae < F; ++ae)
                U[ae] = i(I, U[ae], O).trim();
            break;
        default:
            var _e = ae = 0;
            for (U = []; ae < F; ++ae)
                for (var pe = 0; pe < B; ++pe)
                    U[_e++] = i(I[pe] + " ", J[ae], O).trim()
        }
        return U
    }
    function i(I, U, O) {
        var J = U.charCodeAt(0);
        switch (33 > J && (J = (U = U.trim()).charCodeAt(0)),
        J) {
        case 38:
            return U.replace(g, "$1" + I.trim());
        case 58:
            return I.trim() + U.replace(g, "$1" + I.trim());
        default:
            if (0 < 1 * O && 0 < U.indexOf("\f"))
                return U.replace(g, (I.charCodeAt(0) === 58 ? "" : "$1") + I.trim())
        }
        return I + U
    }
    function r(I, U, O, J) {
        var F = I + ";"
          , B = 2 * U + 3 * O + 4 * J;
        if (B === 944) {
            I = F.indexOf(":", 9) + 1;
            var ae = F.substring(I, F.length - 1).trim();
            return ae = F.substring(0, I).trim() + ae + ";",
            ie === 1 || ie === 2 && s(ae, 1) ? "-webkit-" + ae + ae : ae
        }
        if (ie === 0 || ie === 2 && !s(F, 1))
            return F;
        switch (B) {
        case 1015:
            return F.charCodeAt(10) === 97 ? "-webkit-" + F + F : F;
        case 951:
            return F.charCodeAt(3) === 116 ? "-webkit-" + F + F : F;
        case 963:
            return F.charCodeAt(5) === 110 ? "-webkit-" + F + F : F;
        case 1009:
            if (F.charCodeAt(4) !== 100)
                break;
        case 969:
        case 942:
            return "-webkit-" + F + F;
        case 978:
            return "-webkit-" + F + "-moz-" + F + F;
        case 1019:
        case 983:
            return "-webkit-" + F + "-moz-" + F + "-ms-" + F + F;
        case 883:
            if (F.charCodeAt(8) === 45)
                return "-webkit-" + F + F;
            if (0 < F.indexOf("image-set(", 11))
                return F.replace(Y, "$1-webkit-$2") + F;
            break;
        case 932:
            if (F.charCodeAt(4) === 45)
                switch (F.charCodeAt(5)) {
                case 103:
                    return "-webkit-box-" + F.replace("-grow", "") + "-webkit-" + F + "-ms-" + F.replace("grow", "positive") + F;
                case 115:
                    return "-webkit-" + F + "-ms-" + F.replace("shrink", "negative") + F;
                case 98:
                    return "-webkit-" + F + "-ms-" + F.replace("basis", "preferred-size") + F
                }
            return "-webkit-" + F + "-ms-" + F + F;
        case 964:
            return "-webkit-" + F + "-ms-flex-" + F + F;
        case 1023:
            if (F.charCodeAt(8) !== 99)
                break;
            return ae = F.substring(F.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"),
            "-webkit-box-pack" + ae + "-webkit-" + F + "-ms-flex-pack" + ae + F;
        case 1005:
            return y.test(F) ? F.replace(m, ":-webkit-") + F.replace(m, ":-moz-") + F : F;
        case 1e3:
            switch (ae = F.substring(13).trim(),
            U = ae.indexOf("-") + 1,
            ae.charCodeAt(0) + ae.charCodeAt(U)) {
            case 226:
                ae = F.replace(A, "tb");
                break;
            case 232:
                ae = F.replace(A, "tb-rl");
                break;
            case 220:
                ae = F.replace(A, "lr");
                break;
            default:
                return F
            }
            return "-webkit-" + F + "-ms-" + ae + F;
        case 1017:
            if (F.indexOf("sticky", 9) === -1)
                break;
        case 975:
            switch (U = (F = I).length - 10,
            ae = (F.charCodeAt(U) === 33 ? F.substring(0, U) : F).substring(I.indexOf(":", 7) + 1).trim(),
            B = ae.charCodeAt(0) + (ae.charCodeAt(7) | 0)) {
            case 203:
                if (111 > ae.charCodeAt(8))
                    break;
            case 115:
                F = F.replace(ae, "-webkit-" + ae) + ";" + F;
                break;
            case 207:
            case 102:
                F = F.replace(ae, "-webkit-" + (102 < B ? "inline-" : "") + "box") + ";" + F.replace(ae, "-webkit-" + ae) + ";" + F.replace(ae, "-ms-" + ae + "box") + ";" + F
            }
            return F + ";";
        case 938:
            if (F.charCodeAt(5) === 45)
                switch (F.charCodeAt(6)) {
                case 105:
                    return ae = F.replace("-items", ""),
                    "-webkit-" + F + "-webkit-box-" + ae + "-ms-flex-" + ae + F;
                case 115:
                    return "-webkit-" + F + "-ms-flex-item-" + F.replace(N, "") + F;
                default:
                    return "-webkit-" + F + "-ms-flex-line-pack" + F.replace("align-content", "").replace(N, "") + F
                }
            break;
        case 973:
        case 989:
            if (F.charCodeAt(3) !== 45 || F.charCodeAt(4) === 122)
                break;
        case 931:
        case 953:
            if (L.test(I) === !0)
                return (ae = I.substring(I.indexOf(":") + 1)).charCodeAt(0) === 115 ? r(I.replace("stretch", "fill-available"), U, O, J).replace(":fill-available", ":stretch") : F.replace(ae, "-webkit-" + ae) + F.replace(ae, "-moz-" + ae.replace("fill-", "")) + F;
            break;
        case 962:
            if (F = "-webkit-" + F + (F.charCodeAt(5) === 102 ? "-ms-" + F : "") + F,
            O + J === 211 && F.charCodeAt(13) === 105 && 0 < F.indexOf("transform", 10))
                return F.substring(0, F.indexOf(";", 27) + 1).replace(S, "$1-webkit-$2") + F
        }
        return F
    }
    function s(I, U) {
        var O = I.indexOf(U === 1 ? ":" : "{")
          , J = I.substring(0, U !== 3 ? O : 10);
        return O = I.substring(O + 1, I.length - 1),
        j(U !== 2 ? J : J.replace(b, "$1"), O, U)
    }
    function o(I, U) {
        var O = r(U, U.charCodeAt(0), U.charCodeAt(1), U.charCodeAt(2));
        return O !== U + ";" ? O.replace(P, " or ($1)").substring(4) : "(" + U + ")"
    }
    function a(I, U, O, J, F, B, ae, _e, pe, Ee) {
        for (var se = 0, oe = U, ve; se < D; ++se)
            switch (ve = le[se].call(d, I, oe, O, J, F, B, ae, _e, pe, Ee)) {
            case void 0:
            case !1:
            case !0:
            case null:
                break;
            default:
                oe = ve
            }
        if (oe !== U)
            return oe
    }
    function l(I) {
        switch (I) {
        case void 0:
        case null:
            D = le.length = 0;
            break;
        default:
            if (typeof I == "function")
                le[D++] = I;
            else if (typeof I == "object")
                for (var U = 0, O = I.length; U < O; ++U)
                    l(I[U]);
            else
                X = !!I | 0
        }
        return l
    }
    function f(I) {
        return I = I.prefix,
        I !== void 0 && (j = null,
        I ? typeof I != "function" ? ie = 1 : (ie = 2,
        j = I) : ie = 0),
        f
    }
    function d(I, U) {
        var O = I;
        if (33 > O.charCodeAt(0) && (O = O.trim()),
        ue = O,
        O = [ue],
        0 < D) {
            var J = a(-1, U, O, O, $, Z, 0, 0, 0, 0);
            J !== void 0 && typeof J == "string" && (U = J)
        }
        var F = e(fe, O, U, 0, 0);
        return 0 < D && (J = a(-2, F, O, O, $, Z, F.length, 0, 0, 0),
        J !== void 0 && (F = J)),
        ue = "",
        Q = 0,
        Z = $ = 1,
        F
    }
    var h = /^\0+/g
      , p = /[\0\r\f]/g
      , m = /: */g
      , y = /zoo|gra/
      , S = /([,: ])(transform)/g
      , M = /,\r+?/g
      , g = /([\t\r\n ])*\f?&/g
      , _ = /@(k\w+)\s*(\S*)\s*/
      , w = /::(place)/g
      , T = /:(read-only)/g
      , A = /[svh]\w+-[tblr]{2}/
      , C = /\(\s*(.*)\s*\)/g
      , P = /([\s\S]*?);/g
      , N = /-self|flex-/g
      , b = /[^]*?(:[rp][el]a[\w-]+)[^]*/
      , L = /stretch|:\s*\w+\-(?:conte|avail)/
      , Y = /([^-])(image-set\()/
      , Z = 1
      , $ = 1
      , Q = 0
      , ie = 1
      , fe = []
      , le = []
      , D = 0
      , j = null
      , X = 0
      , ue = "";
    return d.use = l,
    d.set = f,
    n !== void 0 && f(n),
    d
}
var OU = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
};
function FU(n) {
    var e = Object.create(null);
    return function(t) {
        return e[t] === void 0 && (e[t] = n(t)),
        e[t]
    }
}
var zU = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , cT = FU(function(n) {
    return zU.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91
})
  , s2 = {
    exports: {}
}
  , jt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qn = typeof Symbol == "function" && Symbol.for
  , o1 = qn ? Symbol.for("react.element") : 60103
  , a1 = qn ? Symbol.for("react.portal") : 60106
  , Pg = qn ? Symbol.for("react.fragment") : 60107
  , Lg = qn ? Symbol.for("react.strict_mode") : 60108
  , Ig = qn ? Symbol.for("react.profiler") : 60114
  , Ng = qn ? Symbol.for("react.provider") : 60109
  , Dg = qn ? Symbol.for("react.context") : 60110
  , l1 = qn ? Symbol.for("react.async_mode") : 60111
  , Ug = qn ? Symbol.for("react.concurrent_mode") : 60111
  , kg = qn ? Symbol.for("react.forward_ref") : 60112
  , Og = qn ? Symbol.for("react.suspense") : 60113
  , BU = qn ? Symbol.for("react.suspense_list") : 60120
  , Fg = qn ? Symbol.for("react.memo") : 60115
  , zg = qn ? Symbol.for("react.lazy") : 60116
  , VU = qn ? Symbol.for("react.block") : 60121
  , HU = qn ? Symbol.for("react.fundamental") : 60117
  , GU = qn ? Symbol.for("react.responder") : 60118
  , WU = qn ? Symbol.for("react.scope") : 60119;
function nr(n) {
    if (typeof n == "object" && n !== null) {
        var e = n.$$typeof;
        switch (e) {
        case o1:
            switch (n = n.type,
            n) {
            case l1:
            case Ug:
            case Pg:
            case Ig:
            case Lg:
            case Og:
                return n;
            default:
                switch (n = n && n.$$typeof,
                n) {
                case Dg:
                case kg:
                case zg:
                case Fg:
                case Ng:
                    return n;
                default:
                    return e
                }
            }
        case a1:
            return e
        }
    }
}
function o2(n) {
    return nr(n) === Ug
}
jt.AsyncMode = l1;
jt.ConcurrentMode = Ug;
jt.ContextConsumer = Dg;
jt.ContextProvider = Ng;
jt.Element = o1;
jt.ForwardRef = kg;
jt.Fragment = Pg;
jt.Lazy = zg;
jt.Memo = Fg;
jt.Portal = a1;
jt.Profiler = Ig;
jt.StrictMode = Lg;
jt.Suspense = Og;
jt.isAsyncMode = function(n) {
    return o2(n) || nr(n) === l1
}
;
jt.isConcurrentMode = o2;
jt.isContextConsumer = function(n) {
    return nr(n) === Dg
}
;
jt.isContextProvider = function(n) {
    return nr(n) === Ng
}
;
jt.isElement = function(n) {
    return typeof n == "object" && n !== null && n.$$typeof === o1
}
;
jt.isForwardRef = function(n) {
    return nr(n) === kg
}
;
jt.isFragment = function(n) {
    return nr(n) === Pg
}
;
jt.isLazy = function(n) {
    return nr(n) === zg
}
;
jt.isMemo = function(n) {
    return nr(n) === Fg
}
;
jt.isPortal = function(n) {
    return nr(n) === a1
}
;
jt.isProfiler = function(n) {
    return nr(n) === Ig
}
;
jt.isStrictMode = function(n) {
    return nr(n) === Lg
}
;
jt.isSuspense = function(n) {
    return nr(n) === Og
}
;
jt.isValidElementType = function(n) {
    return typeof n == "string" || typeof n == "function" || n === Pg || n === Ug || n === Ig || n === Lg || n === Og || n === BU || typeof n == "object" && n !== null && (n.$$typeof === zg || n.$$typeof === Fg || n.$$typeof === Ng || n.$$typeof === Dg || n.$$typeof === kg || n.$$typeof === HU || n.$$typeof === GU || n.$$typeof === WU || n.$$typeof === VU)
}
;
jt.typeOf = nr;
s2.exports = jt;
var XU = s2.exports
  , c1 = XU
  , $U = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
}
  , jU = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
}
  , YU = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
}
  , a2 = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
}
  , u1 = {};
u1[c1.ForwardRef] = YU;
u1[c1.Memo] = a2;
function uT(n) {
    return c1.isMemo(n) ? a2 : u1[n.$$typeof] || $U
}
var qU = Object.defineProperty
  , KU = Object.getOwnPropertyNames
  , fT = Object.getOwnPropertySymbols
  , ZU = Object.getOwnPropertyDescriptor
  , QU = Object.getPrototypeOf
  , dT = Object.prototype;
function l2(n, e, t) {
    if (typeof e != "string") {
        if (dT) {
            var i = QU(e);
            i && i !== dT && l2(n, i, t)
        }
        var r = KU(e);
        fT && (r = r.concat(fT(e)));
        for (var s = uT(n), o = uT(e), a = 0; a < r.length; ++a) {
            var l = r[a];
            if (!jU[l] && !(t && t[l]) && !(o && o[l]) && !(s && s[l])) {
                var f = ZU(e, l);
                try {
                    qU(n, l, f)
                } catch {}
            }
        }
    }
    return n
}
var JU = l2;
const ek = fd(JU);
function js() {
    return (js = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ).apply(this, arguments)
}
var hT = function(n, e) {
    for (var t = [n[0]], i = 0, r = e.length; i < r; i += 1)
        t.push(e[i], n[i + 1]);
    return t
}
  , nx = function(n) {
    return n !== null && typeof n == "object" && (n.toString ? n.toString() : Object.prototype.toString.call(n)) === "[object Object]" && !r2.typeOf(n)
}
  , $m = Object.freeze([])
  , Xo = Object.freeze({});
function Jf(n) {
    return typeof n == "function"
}
function pT(n) {
    return n.displayName || n.name || "Component"
}
function f1(n) {
    return n && typeof n.styledComponentId == "string"
}
var Vc = typeof process < "u" && process.env !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled"
  , d1 = typeof window < "u" && "HTMLElement"in window
  , tk = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && ({}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" && {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY));
function vd(n) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
        t[i - 1] = arguments[i];
    throw new Error("An error occurred. See https://git.io/JUIaE#" + n + " for more information." + (t.length > 0 ? " Args: " + t.join(", ") : ""))
}
var nk = function() {
    function n(t) {
        this.groupSizes = new Uint32Array(512),
        this.length = 512,
        this.tag = t
    }
    var e = n.prototype;
    return e.indexOfGroup = function(t) {
        for (var i = 0, r = 0; r < t; r++)
            i += this.groupSizes[r];
        return i
    }
    ,
    e.insertRules = function(t, i) {
        if (t >= this.groupSizes.length) {
            for (var r = this.groupSizes, s = r.length, o = s; t >= o; )
                (o <<= 1) < 0 && vd(16, "" + t);
            this.groupSizes = new Uint32Array(o),
            this.groupSizes.set(r),
            this.length = o;
            for (var a = s; a < o; a++)
                this.groupSizes[a] = 0
        }
        for (var l = this.indexOfGroup(t + 1), f = 0, d = i.length; f < d; f++)
            this.tag.insertRule(l, i[f]) && (this.groupSizes[t]++,
            l++)
    }
    ,
    e.clearGroup = function(t) {
        if (t < this.length) {
            var i = this.groupSizes[t]
              , r = this.indexOfGroup(t)
              , s = r + i;
            this.groupSizes[t] = 0;
            for (var o = r; o < s; o++)
                this.tag.deleteRule(r)
        }
    }
    ,
    e.getGroup = function(t) {
        var i = "";
        if (t >= this.length || this.groupSizes[t] === 0)
            return i;
        for (var r = this.groupSizes[t], s = this.indexOfGroup(t), o = s + r, a = s; a < o; a++)
            i += this.tag.getRule(a) + `/*!sc*/
`;
        return i
    }
    ,
    n
}()
  , dm = new Map
  , jm = new Map
  , Af = 1
  , np = function(n) {
    if (dm.has(n))
        return dm.get(n);
    for (; jm.has(Af); )
        Af++;
    var e = Af++;
    return dm.set(n, e),
    jm.set(e, n),
    e
}
  , ik = function(n) {
    return jm.get(n)
}
  , rk = function(n, e) {
    e >= Af && (Af = e + 1),
    dm.set(n, e),
    jm.set(e, n)
}
  , sk = "style[" + Vc + '][data-styled-version="5.3.10"]'
  , ok = new RegExp("^" + Vc + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')
  , ak = function(n, e, t) {
    for (var i, r = t.split(","), s = 0, o = r.length; s < o; s++)
        (i = r[s]) && n.registerName(e, i)
}
  , lk = function(n, e) {
    for (var t = (e.textContent || "").split(`/*!sc*/
`), i = [], r = 0, s = t.length; r < s; r++) {
        var o = t[r].trim();
        if (o) {
            var a = o.match(ok);
            if (a) {
                var l = 0 | parseInt(a[1], 10)
                  , f = a[2];
                l !== 0 && (rk(f, l),
                ak(n, f, a[3]),
                n.getTag().insertRules(l, i)),
                i.length = 0
            } else
                i.push(o)
        }
    }
}
  , ck = function() {
    return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null
}
  , c2 = function(n) {
    var e = document.head
      , t = n || e
      , i = document.createElement("style")
      , r = function(a) {
        for (var l = a.childNodes, f = l.length; f >= 0; f--) {
            var d = l[f];
            if (d && d.nodeType === 1 && d.hasAttribute(Vc))
                return d
        }
    }(t)
      , s = r !== void 0 ? r.nextSibling : null;
    i.setAttribute(Vc, "active"),
    i.setAttribute("data-styled-version", "5.3.10");
    var o = ck();
    return o && i.setAttribute("nonce", o),
    t.insertBefore(i, s),
    i
}
  , uk = function() {
    function n(t) {
        var i = this.element = c2(t);
        i.appendChild(document.createTextNode("")),
        this.sheet = function(r) {
            if (r.sheet)
                return r.sheet;
            for (var s = document.styleSheets, o = 0, a = s.length; o < a; o++) {
                var l = s[o];
                if (l.ownerNode === r)
                    return l
            }
            vd(17)
        }(i),
        this.length = 0
    }
    var e = n.prototype;
    return e.insertRule = function(t, i) {
        try {
            return this.sheet.insertRule(i, t),
            this.length++,
            !0
        } catch {
            return !1
        }
    }
    ,
    e.deleteRule = function(t) {
        this.sheet.deleteRule(t),
        this.length--
    }
    ,
    e.getRule = function(t) {
        var i = this.sheet.cssRules[t];
        return i !== void 0 && typeof i.cssText == "string" ? i.cssText : ""
    }
    ,
    n
}()
  , fk = function() {
    function n(t) {
        var i = this.element = c2(t);
        this.nodes = i.childNodes,
        this.length = 0
    }
    var e = n.prototype;
    return e.insertRule = function(t, i) {
        if (t <= this.length && t >= 0) {
            var r = document.createTextNode(i)
              , s = this.nodes[t];
            return this.element.insertBefore(r, s || null),
            this.length++,
            !0
        }
        return !1
    }
    ,
    e.deleteRule = function(t) {
        this.element.removeChild(this.nodes[t]),
        this.length--
    }
    ,
    e.getRule = function(t) {
        return t < this.length ? this.nodes[t].textContent : ""
    }
    ,
    n
}()
  , dk = function() {
    function n(t) {
        this.rules = [],
        this.length = 0
    }
    var e = n.prototype;
    return e.insertRule = function(t, i) {
        return t <= this.length && (this.rules.splice(t, 0, i),
        this.length++,
        !0)
    }
    ,
    e.deleteRule = function(t) {
        this.rules.splice(t, 1),
        this.length--
    }
    ,
    e.getRule = function(t) {
        return t < this.length ? this.rules[t] : ""
    }
    ,
    n
}()
  , mT = d1
  , hk = {
    isServer: !d1,
    useCSSOMInjection: !tk
}
  , u2 = function() {
    function n(t, i, r) {
        t === void 0 && (t = Xo),
        i === void 0 && (i = {}),
        this.options = js({}, hk, {}, t),
        this.gs = i,
        this.names = new Map(r),
        this.server = !!t.isServer,
        !this.server && d1 && mT && (mT = !1,
        function(s) {
            for (var o = document.querySelectorAll(sk), a = 0, l = o.length; a < l; a++) {
                var f = o[a];
                f && f.getAttribute(Vc) !== "active" && (lk(s, f),
                f.parentNode && f.parentNode.removeChild(f))
            }
        }(this))
    }
    n.registerId = function(t) {
        return np(t)
    }
    ;
    var e = n.prototype;
    return e.reconstructWithOptions = function(t, i) {
        return i === void 0 && (i = !0),
        new n(js({}, this.options, {}, t),this.gs,i && this.names || void 0)
    }
    ,
    e.allocateGSInstance = function(t) {
        return this.gs[t] = (this.gs[t] || 0) + 1
    }
    ,
    e.getTag = function() {
        return this.tag || (this.tag = (r = (i = this.options).isServer,
        s = i.useCSSOMInjection,
        o = i.target,
        t = r ? new dk(o) : s ? new uk(o) : new fk(o),
        new nk(t)));
        var t, i, r, s, o
    }
    ,
    e.hasNameForId = function(t, i) {
        return this.names.has(t) && this.names.get(t).has(i)
    }
    ,
    e.registerName = function(t, i) {
        if (np(t),
        this.names.has(t))
            this.names.get(t).add(i);
        else {
            var r = new Set;
            r.add(i),
            this.names.set(t, r)
        }
    }
    ,
    e.insertRules = function(t, i, r) {
        this.registerName(t, i),
        this.getTag().insertRules(np(t), r)
    }
    ,
    e.clearNames = function(t) {
        this.names.has(t) && this.names.get(t).clear()
    }
    ,
    e.clearRules = function(t) {
        this.getTag().clearGroup(np(t)),
        this.clearNames(t)
    }
    ,
    e.clearTag = function() {
        this.tag = void 0
    }
    ,
    e.toString = function() {
        return function(t) {
            for (var i = t.getTag(), r = i.length, s = "", o = 0; o < r; o++) {
                var a = ik(o);
                if (a !== void 0) {
                    var l = t.names.get(a)
                      , f = i.getGroup(o);
                    if (l && f && l.size) {
                        var d = Vc + ".g" + o + '[id="' + a + '"]'
                          , h = "";
                        l !== void 0 && l.forEach(function(p) {
                            p.length > 0 && (h += p + ",")
                        }),
                        s += "" + f + d + '{content:"' + h + `"}/*!sc*/
`
                    }
                }
            }
            return s
        }(this)
    }
    ,
    n
}()
  , pk = /(a)(d)/gi
  , gT = function(n) {
    return String.fromCharCode(n + (n > 25 ? 39 : 97))
};
function ix(n) {
    var e, t = "";
    for (e = Math.abs(n); e > 52; e = e / 52 | 0)
        t = gT(e % 52) + t;
    return (gT(e % 52) + t).replace(pk, "$1-$2")
}
var vc = function(n, e) {
    for (var t = e.length; t; )
        n = 33 * n ^ e.charCodeAt(--t);
    return n
}
  , f2 = function(n) {
    return vc(5381, n)
};
function mk(n) {
    for (var e = 0; e < n.length; e += 1) {
        var t = n[e];
        if (Jf(t) && !f1(t))
            return !1
    }
    return !0
}
var gk = f2("5.3.10")
  , vk = function() {
    function n(e, t, i) {
        this.rules = e,
        this.staticRulesId = "",
        this.isStatic = (i === void 0 || i.isStatic) && mk(e),
        this.componentId = t,
        this.baseHash = vc(gk, t),
        this.baseStyle = i,
        u2.registerId(t)
    }
    return n.prototype.generateAndInjectStyles = function(e, t, i) {
        var r = this.componentId
          , s = [];
        if (this.baseStyle && s.push(this.baseStyle.generateAndInjectStyles(e, t, i)),
        this.isStatic && !i.hash)
            if (this.staticRulesId && t.hasNameForId(r, this.staticRulesId))
                s.push(this.staticRulesId);
            else {
                var o = Hc(this.rules, e, t, i).join("")
                  , a = ix(vc(this.baseHash, o) >>> 0);
                if (!t.hasNameForId(r, a)) {
                    var l = i(o, "." + a, void 0, r);
                    t.insertRules(r, a, l)
                }
                s.push(a),
                this.staticRulesId = a
            }
        else {
            for (var f = this.rules.length, d = vc(this.baseHash, i.hash), h = "", p = 0; p < f; p++) {
                var m = this.rules[p];
                if (typeof m == "string")
                    h += m;
                else if (m) {
                    var y = Hc(m, e, t, i)
                      , S = Array.isArray(y) ? y.join("") : y;
                    d = vc(d, S + p),
                    h += S
                }
            }
            if (h) {
                var M = ix(d >>> 0);
                if (!t.hasNameForId(r, M)) {
                    var g = i(h, "." + M, void 0, r);
                    t.insertRules(r, M, g)
                }
                s.push(M)
            }
        }
        return s.join(" ")
    }
    ,
    n
}()
  , yk = /^\s*\/\/.*$/gm
  , _k = [":", "[", ".", "#"];
function xk(n) {
    var e, t, i, r, s = n === void 0 ? Xo : n, o = s.options, a = o === void 0 ? Xo : o, l = s.plugins, f = l === void 0 ? $m : l, d = new kU(a), h = [], p = function(S) {
        function M(g) {
            if (g)
                try {
                    S(g + "}")
                } catch {}
        }
        return function(g, _, w, T, A, C, P, N, b, L) {
            switch (g) {
            case 1:
                if (b === 0 && _.charCodeAt(0) === 64)
                    return S(_ + ";"),
                    "";
                break;
            case 2:
                if (N === 0)
                    return _ + "/*|*/";
                break;
            case 3:
                switch (N) {
                case 102:
                case 112:
                    return S(w[0] + _),
                    "";
                default:
                    return _ + (L === 0 ? "/*|*/" : "")
                }
            case -2:
                _.split("/*|*/}").forEach(M)
            }
        }
    }(function(S) {
        h.push(S)
    }), m = function(S, M, g) {
        return M === 0 && _k.indexOf(g[t.length]) !== -1 || g.match(r) ? S : "." + e
    };
    function y(S, M, g, _) {
        _ === void 0 && (_ = "&");
        var w = S.replace(yk, "")
          , T = M && g ? g + " " + M + " { " + w + " }" : w;
        return e = _,
        t = M,
        i = new RegExp("\\" + t + "\\b","g"),
        r = new RegExp("(\\" + t + "\\b){2,}"),
        d(g || !M ? "" : M, T)
    }
    return d.use([].concat(f, [function(S, M, g) {
        S === 2 && g.length && g[0].lastIndexOf(t) > 0 && (g[0] = g[0].replace(i, m))
    }
    , p, function(S) {
        if (S === -2) {
            var M = h;
            return h = [],
            M
        }
    }
    ])),
    y.hash = f.length ? f.reduce(function(S, M) {
        return M.name || vd(15),
        vc(S, M.name)
    }, 5381).toString() : "",
    y
}
var d2 = Wt.createContext();
d2.Consumer;
var h2 = Wt.createContext()
  , Sk = (h2.Consumer,
new u2)
  , rx = xk();
function wk() {
    return ke.useContext(d2) || Sk
}
function Mk() {
    return ke.useContext(h2) || rx
}
var Ek = function() {
    function n(e, t) {
        var i = this;
        this.inject = function(r, s) {
            s === void 0 && (s = rx);
            var o = i.name + s.hash;
            r.hasNameForId(i.id, o) || r.insertRules(i.id, o, s(i.rules, o, "@keyframes"))
        }
        ,
        this.toString = function() {
            return vd(12, String(i.name))
        }
        ,
        this.name = e,
        this.id = "sc-keyframes-" + e,
        this.rules = t
    }
    return n.prototype.getName = function(e) {
        return e === void 0 && (e = rx),
        this.name + e.hash
    }
    ,
    n
}()
  , Tk = /([A-Z])/
  , Ak = /([A-Z])/g
  , Rk = /^ms-/
  , Ck = function(n) {
    return "-" + n.toLowerCase()
};
function vT(n) {
    return Tk.test(n) ? n.replace(Ak, Ck).replace(Rk, "-ms-") : n
}
var yT = function(n) {
    return n == null || n === !1 || n === ""
};
function Hc(n, e, t, i) {
    if (Array.isArray(n)) {
        for (var r, s = [], o = 0, a = n.length; o < a; o += 1)
            (r = Hc(n[o], e, t, i)) !== "" && (Array.isArray(r) ? s.push.apply(s, r) : s.push(r));
        return s
    }
    if (yT(n))
        return "";
    if (f1(n))
        return "." + n.styledComponentId;
    if (Jf(n)) {
        if (typeof (f = n) != "function" || f.prototype && f.prototype.isReactComponent || !e)
            return n;
        var l = n(e);
        return Hc(l, e, t, i)
    }
    var f;
    return n instanceof Ek ? t ? (n.inject(t, i),
    n.getName(i)) : n : nx(n) ? function d(h, p) {
        var m, y, S = [];
        for (var M in h)
            h.hasOwnProperty(M) && !yT(h[M]) && (Array.isArray(h[M]) && h[M].isCss || Jf(h[M]) ? S.push(vT(M) + ":", h[M], ";") : nx(h[M]) ? S.push.apply(S, d(h[M], M)) : S.push(vT(M) + ": " + (m = M,
            (y = h[M]) == null || typeof y == "boolean" || y === "" ? "" : typeof y != "number" || y === 0 || m in OU || m.startsWith("--") ? String(y).trim() : y + "px") + ";"));
        return p ? [p + " {"].concat(S, ["}"]) : S
    }(n) : n.toString()
}
var _T = function(n) {
    return Array.isArray(n) && (n.isCss = !0),
    n
};
function bk(n) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
        t[i - 1] = arguments[i];
    return Jf(n) || nx(n) ? _T(Hc(hT($m, [n].concat(t)))) : t.length === 0 && n.length === 1 && typeof n[0] == "string" ? n : _T(Hc(hT(n, t)))
}
var Pk = function(n, e, t) {
    return t === void 0 && (t = Xo),
    n.theme !== t.theme && n.theme || e || t.theme
}
  , Lk = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g
  , Ik = /(^-|-$)/g;
function ry(n) {
    return n.replace(Lk, "-").replace(Ik, "")
}
var Nk = function(n) {
    return ix(f2(n) >>> 0)
};
function ip(n) {
    return typeof n == "string" && !0
}
var sx = function(n) {
    return typeof n == "function" || typeof n == "object" && n !== null && !Array.isArray(n)
}
  , Dk = function(n) {
    return n !== "__proto__" && n !== "constructor" && n !== "prototype"
};
function Uk(n, e, t) {
    var i = n[t];
    sx(e) && sx(i) ? p2(i, e) : n[t] = e
}
function p2(n) {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
        t[i - 1] = arguments[i];
    for (var r = 0, s = t; r < s.length; r++) {
        var o = s[r];
        if (sx(o))
            for (var a in o)
                Dk(a) && Uk(n, o[a], a)
    }
    return n
}
var m2 = Wt.createContext();
m2.Consumer;
var sy = {};
function g2(n, e, t) {
    var i = f1(n)
      , r = !ip(n)
      , s = e.attrs
      , o = s === void 0 ? $m : s
      , a = e.componentId
      , l = a === void 0 ? function(_, w) {
        var T = typeof _ != "string" ? "sc" : ry(_);
        sy[T] = (sy[T] || 0) + 1;
        var A = T + "-" + Nk("5.3.10" + T + sy[T]);
        return w ? w + "-" + A : A
    }(e.displayName, e.parentComponentId) : a
      , f = e.displayName
      , d = f === void 0 ? function(_) {
        return ip(_) ? "styled." + _ : "Styled(" + pT(_) + ")"
    }(n) : f
      , h = e.displayName && e.componentId ? ry(e.displayName) + "-" + e.componentId : e.componentId || l
      , p = i && n.attrs ? Array.prototype.concat(n.attrs, o).filter(Boolean) : o
      , m = e.shouldForwardProp;
    i && n.shouldForwardProp && (m = e.shouldForwardProp ? function(_, w, T) {
        return n.shouldForwardProp(_, w, T) && e.shouldForwardProp(_, w, T)
    }
    : n.shouldForwardProp);
    var y, S = new vk(t,h,i ? n.componentStyle : void 0), M = S.isStatic && o.length === 0, g = function(_, w) {
        return function(T, A, C, P) {
            var N = T.attrs
              , b = T.componentStyle
              , L = T.defaultProps
              , Y = T.foldedComponentIds
              , Z = T.shouldForwardProp
              , $ = T.styledComponentId
              , Q = T.target
              , ie = function(J, F, B) {
                J === void 0 && (J = Xo);
                var ae = js({}, F, {
                    theme: J
                })
                  , _e = {};
                return B.forEach(function(pe) {
                    var Ee, se, oe, ve = pe;
                    for (Ee in Jf(ve) && (ve = ve(ae)),
                    ve)
                        ae[Ee] = _e[Ee] = Ee === "className" ? (se = _e[Ee],
                        oe = ve[Ee],
                        se && oe ? se + " " + oe : se || oe) : ve[Ee]
                }),
                [ae, _e]
            }(Pk(A, ke.useContext(m2), L) || Xo, A, N)
              , fe = ie[0]
              , le = ie[1]
              , D = function(J, F, B, ae) {
                var _e = wk()
                  , pe = Mk()
                  , Ee = F ? J.generateAndInjectStyles(Xo, _e, pe) : J.generateAndInjectStyles(B, _e, pe);
                return Ee
            }(b, P, fe)
              , j = C
              , X = le.$as || A.$as || le.as || A.as || Q
              , ue = ip(X)
              , I = le !== A ? js({}, A, {}, le) : A
              , U = {};
            for (var O in I)
                O[0] !== "$" && O !== "as" && (O === "forwardedAs" ? U.as = I[O] : (Z ? Z(O, cT, X) : !ue || cT(O)) && (U[O] = I[O]));
            return A.style && le.style !== A.style && (U.style = js({}, A.style, {}, le.style)),
            U.className = Array.prototype.concat(Y, $, D !== $ ? D : null, A.className, le.className).filter(Boolean).join(" "),
            U.ref = j,
            ke.createElement(X, U)
        }(y, _, w, M)
    };
    return g.displayName = d,
    (y = Wt.forwardRef(g)).attrs = p,
    y.componentStyle = S,
    y.displayName = d,
    y.shouldForwardProp = m,
    y.foldedComponentIds = i ? Array.prototype.concat(n.foldedComponentIds, n.styledComponentId) : $m,
    y.styledComponentId = h,
    y.target = i ? n.target : n,
    y.withComponent = function(_) {
        var w = e.componentId
          , T = function(C, P) {
            if (C == null)
                return {};
            var N, b, L = {}, Y = Object.keys(C);
            for (b = 0; b < Y.length; b++)
                N = Y[b],
                P.indexOf(N) >= 0 || (L[N] = C[N]);
            return L
        }(e, ["componentId"])
          , A = w && w + "-" + (ip(_) ? _ : ry(pT(_)));
        return g2(_, js({}, T, {
            attrs: p,
            componentId: A
        }), t)
    }
    ,
    Object.defineProperty(y, "defaultProps", {
        get: function() {
            return this._foldedDefaultProps
        },
        set: function(_) {
            this._foldedDefaultProps = i ? p2({}, n.defaultProps, _) : _
        }
    }),
    Object.defineProperty(y, "toString", {
        value: function() {
            return "." + y.styledComponentId
        }
    }),
    r && ek(y, n, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
        withComponent: !0
    }),
    y
}
var ox = function(n) {
    return function e(t, i, r) {
        if (r === void 0 && (r = Xo),
        !r2.isValidElementType(i))
            return vd(1, String(i));
        var s = function() {
            return t(i, r, bk.apply(void 0, arguments))
        };
        return s.withConfig = function(o) {
            return e(t, i, js({}, r, {}, o))
        }
        ,
        s.attrs = function(o) {
            return e(t, i, js({}, r, {
                attrs: Array.prototype.concat(r.attrs, o).filter(Boolean)
            }))
        }
        ,
        s
    }(g2, n)
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(n) {
    ox[n] = ox(n)
});
const cl = ox;
function kk(n) {
    const e = new Error(n);
    if (e.stack === void 0)
        try {
            throw e
        } catch {}
    return e
}
var Ok = kk
  , St = Ok;
function Fk(n) {
    return !!n && typeof n.then == "function"
}
var rn = Fk;
function zk(n, e) {
    if (n != null)
        return n;
    throw St(e ?? "Got unexpected null or undefined")
}
var cn = zk;
function vt(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
class Bg {
    getValue() {
        throw St("BaseLoadable")
    }
    toPromise() {
        throw St("BaseLoadable")
    }
    valueMaybe() {
        throw St("BaseLoadable")
    }
    valueOrThrow() {
        throw St(`Loadable expected value, but in "${this.state}" state`)
    }
    promiseMaybe() {
        throw St("BaseLoadable")
    }
    promiseOrThrow() {
        throw St(`Loadable expected promise, but in "${this.state}" state`)
    }
    errorMaybe() {
        throw St("BaseLoadable")
    }
    errorOrThrow() {
        throw St(`Loadable expected error, but in "${this.state}" state`)
    }
    is(e) {
        return e.state === this.state && e.contents === this.contents
    }
    map(e) {
        throw St("BaseLoadable")
    }
}
class Bk extends Bg {
    constructor(e) {
        super(),
        vt(this, "state", "hasValue"),
        vt(this, "contents", void 0),
        this.contents = e
    }
    getValue() {
        return this.contents
    }
    toPromise() {
        return Promise.resolve(this.contents)
    }
    valueMaybe() {
        return this.contents
    }
    valueOrThrow() {
        return this.contents
    }
    promiseMaybe() {}
    errorMaybe() {}
    map(e) {
        try {
            const t = e(this.contents);
            return rn(t) ? Za(t) : Gc(t) ? t : yd(t)
        } catch (t) {
            return rn(t) ? Za(t.next(()=>this.map(e))) : Vg(t)
        }
    }
}
class Vk extends Bg {
    constructor(e) {
        super(),
        vt(this, "state", "hasError"),
        vt(this, "contents", void 0),
        this.contents = e
    }
    getValue() {
        throw this.contents
    }
    toPromise() {
        return Promise.reject(this.contents)
    }
    valueMaybe() {}
    promiseMaybe() {}
    errorMaybe() {
        return this.contents
    }
    errorOrThrow() {
        return this.contents
    }
    map(e) {
        return this
    }
}
class v2 extends Bg {
    constructor(e) {
        super(),
        vt(this, "state", "loading"),
        vt(this, "contents", void 0),
        this.contents = e
    }
    getValue() {
        throw this.contents
    }
    toPromise() {
        return this.contents
    }
    valueMaybe() {}
    promiseMaybe() {
        return this.contents
    }
    promiseOrThrow() {
        return this.contents
    }
    errorMaybe() {}
    map(e) {
        return Za(this.contents.then(t=>{
            const i = e(t);
            if (Gc(i)) {
                const r = i;
                switch (r.state) {
                case "hasValue":
                    return r.contents;
                case "hasError":
                    throw r.contents;
                case "loading":
                    return r.contents
                }
            }
            return i
        }
        ).catch(t=>{
            if (rn(t))
                return t.then(()=>this.map(e).contents);
            throw t
        }
        ))
    }
}
function yd(n) {
    return Object.freeze(new Bk(n))
}
function Vg(n) {
    return Object.freeze(new Vk(n))
}
function Za(n) {
    return Object.freeze(new v2(n))
}
function y2() {
    return Object.freeze(new v2(new Promise(()=>{}
    )))
}
function Hk(n) {
    return n.every(e=>e.state === "hasValue") ? yd(n.map(e=>e.contents)) : n.some(e=>e.state === "hasError") ? Vg(cn(n.find(e=>e.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : Za(Promise.all(n.map(e=>e.contents)))
}
function _2(n) {
    const t = (Array.isArray(n) ? n : Object.getOwnPropertyNames(n).map(r=>n[r])).map(r=>Gc(r) ? r : rn(r) ? Za(r) : yd(r))
      , i = Hk(t);
    return Array.isArray(n) ? i : i.map(r=>Object.getOwnPropertyNames(n).reduce((s,o,a)=>({
        ...s,
        [o]: r[a]
    }), {}))
}
function Gc(n) {
    return n instanceof Bg
}
const Gk = {
    of: n=>rn(n) ? Za(n) : Gc(n) ? n : yd(n),
    error: n=>Vg(n),
    loading: ()=>y2(),
    all: _2,
    isLoadable: Gc
};
var ul = {
    loadableWithValue: yd,
    loadableWithError: Vg,
    loadableWithPromise: Za,
    loadableLoading: y2,
    loadableAll: _2,
    isLoadable: Gc,
    RecoilLoadable: Gk
}
  , Wk = ul.loadableWithValue
  , Xk = ul.loadableWithError
  , $k = ul.loadableWithPromise
  , jk = ul.loadableLoading
  , Yk = ul.loadableAll
  , qk = ul.isLoadable
  , Kk = ul.RecoilLoadable
  , _d = Object.freeze({
    __proto__: null,
    loadableWithValue: Wk,
    loadableWithError: Xk,
    loadableWithPromise: $k,
    loadableLoading: jk,
    loadableAll: Yk,
    isLoadable: qk,
    RecoilLoadable: Kk
});
const ax = {
    RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: !0,
    RECOIL_GKS_ENABLED: new Set(["recoil_hamt_2020", "recoil_sync_external_store", "recoil_suppress_rerender_in_callback", "recoil_memory_managament_2020"])
};
function Zk(n, e) {
    var t, i;
    const r = (t = process.env[n]) === null || t === void 0 || (i = t.toLowerCase()) === null || i === void 0 ? void 0 : i.trim();
    if (r == null || r === "")
        return;
    if (!["true", "false"].includes(r))
        throw St(`({}).${n} value must be 'true', 'false', or empty: ${r}`);
    e(r === "true")
}
function Qk(n, e) {
    var t;
    const i = (t = process.env[n]) === null || t === void 0 ? void 0 : t.trim();
    i == null || i === "" || e(i.split(/\s*,\s*|\s+/))
}
function Jk() {
    var n;
    typeof process > "u" || ((n = process) === null || n === void 0 ? void 0 : n.env) != null && (Zk("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED", e=>{
        ax.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = e
    }
    ),
    Qk("RECOIL_GKS_ENABLED", e=>{
        e.forEach(t=>{
            ax.RECOIL_GKS_ENABLED.add(t)
        }
        )
    }
    ))
}
Jk();
var ou = ax;
function Hg(n) {
    return ou.RECOIL_GKS_ENABLED.has(n)
}
Hg.setPass = n=>{
    ou.RECOIL_GKS_ENABLED.add(n)
}
;
Hg.setFail = n=>{
    ou.RECOIL_GKS_ENABLED.delete(n)
}
;
Hg.clear = ()=>{
    ou.RECOIL_GKS_ENABLED.clear()
}
;
var Zt = Hg;
function eO(n, e, {error: t}={}) {
    return null
}
var tO = eO, h1 = tO, oy, ay, ly;
const nO = (oy = Wt.createMutableSource) !== null && oy !== void 0 ? oy : Wt.unstable_createMutableSource
  , x2 = (ay = Wt.useMutableSource) !== null && ay !== void 0 ? ay : Wt.unstable_useMutableSource
  , S2 = (ly = Wt.useSyncExternalStore) !== null && ly !== void 0 ? ly : Wt.unstable_useSyncExternalStore;
function iO() {
    var n;
    const {ReactCurrentDispatcher: e, ReactCurrentOwner: t} = Wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    return ((n = e == null ? void 0 : e.current) !== null && n !== void 0 ? n : t.currentDispatcher).useSyncExternalStore != null
}
function rO() {
    return Zt("recoil_transition_support") ? {
        mode: "TRANSITION_SUPPORT",
        early: !0,
        concurrent: !0
    } : Zt("recoil_sync_external_store") && S2 != null ? {
        mode: "SYNC_EXTERNAL_STORE",
        early: !0,
        concurrent: !1
    } : Zt("recoil_mutable_source") && x2 != null && typeof window < "u" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE ? Zt("recoil_suppress_rerender_in_callback") ? {
        mode: "MUTABLE_SOURCE",
        early: !0,
        concurrent: !0
    } : {
        mode: "MUTABLE_SOURCE",
        early: !1,
        concurrent: !1
    } : Zt("recoil_suppress_rerender_in_callback") ? {
        mode: "LEGACY",
        early: !0,
        concurrent: !1
    } : {
        mode: "LEGACY",
        early: !1,
        concurrent: !1
    }
}
function sO() {
    return !1
}
var xd = {
    createMutableSource: nO,
    useMutableSource: x2,
    useSyncExternalStore: S2,
    currentRendererSupportsUseSyncExternalStore: iO,
    reactMode: rO,
    isFastRefreshEnabled: sO
};
class p1 {
    constructor(e) {
        vt(this, "key", void 0),
        this.key = e
    }
    toJSON() {
        return {
            key: this.key
        }
    }
}
class w2 extends p1 {
}
class M2 extends p1 {
}
function oO(n) {
    return n instanceof w2 || n instanceof M2
}
var Gg = {
    AbstractRecoilValue: p1,
    RecoilState: w2,
    RecoilValueReadOnly: M2,
    isRecoilValue: oO
}
  , aO = Gg.AbstractRecoilValue
  , lO = Gg.RecoilState
  , cO = Gg.RecoilValueReadOnly
  , uO = Gg.isRecoilValue
  , Wc = Object.freeze({
    __proto__: null,
    AbstractRecoilValue: aO,
    RecoilState: lO,
    RecoilValueReadOnly: cO,
    isRecoilValue: uO
});
function fO(n, e) {
    return function*() {
        let t = 0;
        for (const i of n)
            yield e(i, t++)
    }()
}
var Wg = fO;
class E2 {
}
const dO = new E2
  , Qa = new Map
  , m1 = new Map;
function hO(n) {
    return Wg(n, e=>cn(m1.get(e)))
}
function pO(n) {
    if (Qa.has(n)) {
        const e = `Duplicate atom key "${n}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;
        console.warn(e)
    }
}
function mO(n) {
    ou.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED && pO(n.key),
    Qa.set(n.key, n);
    const e = n.set == null ? new Wc.RecoilValueReadOnly(n.key) : new Wc.RecoilState(n.key);
    return m1.set(n.key, e),
    e
}
class T2 extends Error {
}
function gO(n) {
    const e = Qa.get(n);
    if (e == null)
        throw new T2(`Missing definition for RecoilValue: "${n}""`);
    return e
}
function vO(n) {
    return Qa.get(n)
}
const Ym = new Map;
function yO(n) {
    var e;
    if (!Zt("recoil_memory_managament_2020"))
        return;
    const t = Qa.get(n);
    if (t != null && (e = t.shouldDeleteConfigOnRelease) !== null && e !== void 0 && e.call(t)) {
        var i;
        Qa.delete(n),
        (i = A2(n)) === null || i === void 0 || i(),
        Ym.delete(n)
    }
}
function _O(n, e) {
    Zt("recoil_memory_managament_2020") && (e === void 0 ? Ym.delete(n) : Ym.set(n, e))
}
function A2(n) {
    return Ym.get(n)
}
var Fi = {
    nodes: Qa,
    recoilValues: m1,
    registerNode: mO,
    getNode: gO,
    getNodeMaybe: vO,
    deleteNodeConfigIfPossible: yO,
    setConfigDeletionHandler: _O,
    getConfigDeletionHandler: A2,
    recoilValuesForKeys: hO,
    NodeMissingError: T2,
    DefaultValue: E2,
    DEFAULT_VALUE: dO
};
function xO(n, e) {
    e()
}
var SO = {
    enqueueExecution: xO
};
function wO(n, e) {
    return e = {
        exports: {}
    },
    n(e, e.exports),
    e.exports
}
var MO = wO(function(n) {
    var e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
        return typeof K
    }
    : function(K) {
        return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K
    }
      , t = {}
      , i = 5
      , r = Math.pow(2, i)
      , s = r - 1
      , o = r / 2
      , a = r / 4
      , l = {}
      , f = function(q) {
        return function() {
            return q
        }
    }
      , d = t.hash = function(K) {
        var q = typeof K > "u" ? "undefined" : e(K);
        if (q === "number")
            return K;
        q !== "string" && (K += "");
        for (var xe = 0, Ne = 0, H = K.length; Ne < H; ++Ne) {
            var te = K.charCodeAt(Ne);
            xe = (xe << 5) - xe + te | 0
        }
        return xe
    }
      , h = function(q) {
        return q -= q >> 1 & 1431655765,
        q = (q & 858993459) + (q >> 2 & 858993459),
        q = q + (q >> 4) & 252645135,
        q += q >> 8,
        q += q >> 16,
        q & 127
    }
      , p = function(q, xe) {
        return xe >>> q & s
    }
      , m = function(q) {
        return 1 << q
    }
      , y = function(q, xe) {
        return h(q & xe - 1)
    }
      , S = function(q, xe, Ne, H) {
        var te = H;
        if (!q) {
            var me = H.length;
            te = new Array(me);
            for (var Te = 0; Te < me; ++Te)
                te[Te] = H[Te]
        }
        return te[xe] = Ne,
        te
    }
      , M = function(q, xe, Ne) {
        var H = Ne.length - 1
          , te = 0
          , me = 0
          , Te = Ne;
        if (q)
            te = me = xe;
        else
            for (Te = new Array(H); te < xe; )
                Te[me++] = Ne[te++];
        for (++te; te <= H; )
            Te[me++] = Ne[te++];
        return q && (Te.length = H),
        Te
    }
      , g = function(q, xe, Ne, H) {
        var te = H.length;
        if (q) {
            for (var me = te; me >= xe; )
                H[me--] = H[me];
            return H[xe] = Ne,
            H
        }
        for (var Te = 0, Pe = 0, Ge = new Array(te + 1); Te < xe; )
            Ge[Pe++] = H[Te++];
        for (Ge[xe] = Ne; Te < te; )
            Ge[++Pe] = H[Te++];
        return Ge
    }
      , _ = 1
      , w = 2
      , T = 3
      , A = 4
      , C = {
        __hamt_isEmpty: !0
    }
      , P = function(q) {
        return q === C || q && q.__hamt_isEmpty
    }
      , N = function(q, xe, Ne, H) {
        return {
            type: _,
            edit: q,
            hash: xe,
            key: Ne,
            value: H,
            _modify: D
        }
    }
      , b = function(q, xe, Ne) {
        return {
            type: w,
            edit: q,
            hash: xe,
            children: Ne,
            _modify: j
        }
    }
      , L = function(q, xe, Ne) {
        return {
            type: T,
            edit: q,
            mask: xe,
            children: Ne,
            _modify: X
        }
    }
      , Y = function(q, xe, Ne) {
        return {
            type: A,
            edit: q,
            size: xe,
            children: Ne,
            _modify: ue
        }
    }
      , Z = function(q) {
        return q === C || q.type === _ || q.type === w
    }
      , $ = function(q, xe, Ne, H, te) {
        for (var me = [], Te = H, Pe = 0, Ge = 0; Te; ++Ge)
            Te & 1 && (me[Ge] = te[Pe++]),
            Te >>>= 1;
        return me[xe] = Ne,
        Y(q, Pe + 1, me)
    }
      , Q = function(q, xe, Ne, H) {
        for (var te = new Array(xe - 1), me = 0, Te = 0, Pe = 0, Ge = H.length; Pe < Ge; ++Pe)
            if (Pe !== Ne) {
                var it = H[Pe];
                it && !P(it) && (te[me++] = it,
                Te |= 1 << Pe)
            }
        return L(q, Te, te)
    }
      , ie = function K(q, xe, Ne, H, te, me) {
        if (Ne === te)
            return b(q, Ne, [me, H]);
        var Te = p(xe, Ne)
          , Pe = p(xe, te);
        return L(q, m(Te) | m(Pe), Te === Pe ? [K(q, xe + i, Ne, H, te, me)] : Te < Pe ? [H, me] : [me, H])
    }
      , fe = function(q, xe, Ne, H, te, me, Te, Pe) {
        for (var Ge = te.length, it = 0; it < Ge; ++it) {
            var Dt = te[it];
            if (Ne(Te, Dt.key)) {
                var Bt = Dt.value
                  , bt = me(Bt);
                return bt === Bt ? te : bt === l ? (--Pe.value,
                M(q, it, te)) : S(q, it, N(xe, H, Te, bt), te)
            }
        }
        var qt = me();
        return qt === l ? te : (++Pe.value,
        S(q, Ge, N(xe, H, Te, qt), te))
    }
      , le = function(q, xe) {
        return q === xe.edit
    }
      , D = function(q, xe, Ne, H, te, me, Te) {
        if (xe(me, this.key)) {
            var Pe = H(this.value);
            return Pe === this.value ? this : Pe === l ? (--Te.value,
            C) : le(q, this) ? (this.value = Pe,
            this) : N(q, te, me, Pe)
        }
        var Ge = H();
        return Ge === l ? this : (++Te.value,
        ie(q, Ne, this.hash, this, te, N(q, te, me, Ge)))
    }
      , j = function(q, xe, Ne, H, te, me, Te) {
        if (te === this.hash) {
            var Pe = le(q, this)
              , Ge = fe(Pe, q, xe, this.hash, this.children, H, me, Te);
            return Ge === this.children ? this : Ge.length > 1 ? b(q, this.hash, Ge) : Ge[0]
        }
        var it = H();
        return it === l ? this : (++Te.value,
        ie(q, Ne, this.hash, this, te, N(q, te, me, it)))
    }
      , X = function(q, xe, Ne, H, te, me, Te) {
        var Pe = this.mask
          , Ge = this.children
          , it = p(Ne, te)
          , Dt = m(it)
          , Bt = y(Pe, Dt)
          , bt = Pe & Dt
          , qt = bt ? Ge[Bt] : C
          , Dn = qt._modify(q, xe, Ne + i, H, te, me, Te);
        if (qt === Dn)
            return this;
        var Cr = le(q, this)
          , ss = Pe
          , os = void 0;
        if (bt && P(Dn)) {
            if (ss &= ~Dt,
            !ss)
                return C;
            if (Ge.length <= 2 && Z(Ge[Bt ^ 1]))
                return Ge[Bt ^ 1];
            os = M(Cr, Bt, Ge)
        } else if (!bt && !P(Dn)) {
            if (Ge.length >= o)
                return $(q, it, Dn, Pe, Ge);
            ss |= Dt,
            os = g(Cr, Bt, Dn, Ge)
        } else
            os = S(Cr, Bt, Dn, Ge);
        return Cr ? (this.mask = ss,
        this.children = os,
        this) : L(q, ss, os)
    }
      , ue = function(q, xe, Ne, H, te, me, Te) {
        var Pe = this.size
          , Ge = this.children
          , it = p(Ne, te)
          , Dt = Ge[it]
          , Bt = (Dt || C)._modify(q, xe, Ne + i, H, te, me, Te);
        if (Dt === Bt)
            return this;
        var bt = le(q, this)
          , qt = void 0;
        if (P(Dt) && !P(Bt))
            ++Pe,
            qt = S(bt, it, Bt, Ge);
        else if (!P(Dt) && P(Bt)) {
            if (--Pe,
            Pe <= a)
                return Q(q, Pe, it, Ge);
            qt = S(bt, it, C, Ge)
        } else
            qt = S(bt, it, Bt, Ge);
        return bt ? (this.size = Pe,
        this.children = qt,
        this) : Y(q, Pe, qt)
    };
    C._modify = function(K, q, xe, Ne, H, te, me) {
        var Te = Ne();
        return Te === l ? C : (++me.value,
        N(K, H, te, Te))
    }
    ;
    function I(K, q, xe, Ne, H) {
        this._editable = K,
        this._edit = q,
        this._config = xe,
        this._root = Ne,
        this._size = H
    }
    I.prototype.setTree = function(K, q) {
        return this._editable ? (this._root = K,
        this._size = q,
        this) : K === this._root ? this : new I(this._editable,this._edit,this._config,K,q)
    }
    ;
    var U = t.tryGetHash = function(K, q, xe, Ne) {
        for (var H = Ne._root, te = 0, me = Ne._config.keyEq; ; )
            switch (H.type) {
            case _:
                return me(xe, H.key) ? H.value : K;
            case w:
                {
                    if (q === H.hash)
                        for (var Te = H.children, Pe = 0, Ge = Te.length; Pe < Ge; ++Pe) {
                            var it = Te[Pe];
                            if (me(xe, it.key))
                                return it.value
                        }
                    return K
                }
            case T:
                {
                    var Dt = p(te, q)
                      , Bt = m(Dt);
                    if (H.mask & Bt) {
                        H = H.children[y(H.mask, Bt)],
                        te += i;
                        break
                    }
                    return K
                }
            case A:
                {
                    if (H = H.children[p(te, q)],
                    H) {
                        te += i;
                        break
                    }
                    return K
                }
            default:
                return K
            }
    }
    ;
    I.prototype.tryGetHash = function(K, q, xe) {
        return U(K, q, xe, this)
    }
    ;
    var O = t.tryGet = function(K, q, xe) {
        return U(K, xe._config.hash(q), q, xe)
    }
    ;
    I.prototype.tryGet = function(K, q) {
        return O(K, q, this)
    }
    ;
    var J = t.getHash = function(K, q, xe) {
        return U(void 0, K, q, xe)
    }
    ;
    I.prototype.getHash = function(K, q) {
        return J(K, q, this)
    }
    ,
    t.get = function(K, q) {
        return U(void 0, q._config.hash(K), K, q)
    }
    ,
    I.prototype.get = function(K, q) {
        return O(q, K, this)
    }
    ;
    var F = t.has = function(K, q, xe) {
        return U(l, K, q, xe) !== l
    }
    ;
    I.prototype.hasHash = function(K, q) {
        return F(K, q, this)
    }
    ;
    var B = t.has = function(K, q) {
        return F(q._config.hash(K), K, q)
    }
    ;
    I.prototype.has = function(K) {
        return B(K, this)
    }
    ;
    var ae = function(q, xe) {
        return q === xe
    };
    t.make = function(K) {
        return new I(0,0,{
            keyEq: K && K.keyEq || ae,
            hash: K && K.hash || d
        },C,0)
    }
    ,
    t.empty = t.make();
    var _e = t.isEmpty = function(K) {
        return K && !!P(K._root)
    }
    ;
    I.prototype.isEmpty = function() {
        return _e(this)
    }
    ;
    var pe = t.modifyHash = function(K, q, xe, Ne) {
        var H = {
            value: Ne._size
        }
          , te = Ne._root._modify(Ne._editable ? Ne._edit : NaN, Ne._config.keyEq, 0, K, q, xe, H);
        return Ne.setTree(te, H.value)
    }
    ;
    I.prototype.modifyHash = function(K, q, xe) {
        return pe(xe, K, q, this)
    }
    ;
    var Ee = t.modify = function(K, q, xe) {
        return pe(K, xe._config.hash(q), q, xe)
    }
    ;
    I.prototype.modify = function(K, q) {
        return Ee(q, K, this)
    }
    ;
    var se = t.setHash = function(K, q, xe, Ne) {
        return pe(f(xe), K, q, Ne)
    }
    ;
    I.prototype.setHash = function(K, q, xe) {
        return se(K, q, xe, this)
    }
    ;
    var oe = t.set = function(K, q, xe) {
        return se(xe._config.hash(K), K, q, xe)
    }
    ;
    I.prototype.set = function(K, q) {
        return oe(K, q, this)
    }
    ;
    var ve = f(l)
      , Ce = t.removeHash = function(K, q, xe) {
        return pe(ve, K, q, xe)
    }
    ;
    I.prototype.removeHash = I.prototype.deleteHash = function(K, q) {
        return Ce(K, q, this)
    }
    ;
    var Re = t.remove = function(K, q) {
        return Ce(q._config.hash(K), K, q)
    }
    ;
    I.prototype.remove = I.prototype.delete = function(K) {
        return Re(K, this)
    }
    ;
    var Le = t.beginMutation = function(K) {
        return new I(K._editable + 1,K._edit + 1,K._config,K._root,K._size)
    }
    ;
    I.prototype.beginMutation = function() {
        return Le(this)
    }
    ;
    var Be = t.endMutation = function(K) {
        return K._editable = K._editable && K._editable - 1,
        K
    }
    ;
    I.prototype.endMutation = function() {
        return Be(this)
    }
    ;
    var Ze = t.mutate = function(K, q) {
        var xe = Le(q);
        return K(xe),
        Be(xe)
    }
    ;
    I.prototype.mutate = function(K) {
        return Ze(K, this)
    }
    ;
    var Ye = function(q) {
        return q && pt(q[0], q[1], q[2], q[3], q[4])
    }
      , pt = function(q, xe, Ne, H, te) {
        for (; Ne < q; ) {
            var me = xe[Ne++];
            if (me && !P(me))
                return G(me, H, [q, xe, Ne, H, te])
        }
        return Ye(te)
    }
      , G = function(q, xe, Ne) {
        switch (q.type) {
        case _:
            return {
                value: xe(q),
                rest: Ne
            };
        case w:
        case A:
        case T:
            var H = q.children;
            return pt(H.length, H, 0, xe, Ne);
        default:
            return Ye(Ne)
        }
    }
      , k = {
        done: !0
    };
    function ee(K) {
        this.v = K
    }
    ee.prototype.next = function() {
        if (!this.v)
            return k;
        var K = this.v;
        return this.v = Ye(K.rest),
        K
    }
    ,
    ee.prototype[Symbol.iterator] = function() {
        return this
    }
    ;
    var we = function(q, xe) {
        return new ee(G(q._root, xe))
    }
      , Ie = function(q) {
        return [q.key, q.value]
    }
      , Fe = t.entries = function(K) {
        return we(K, Ie)
    }
    ;
    I.prototype.entries = I.prototype[Symbol.iterator] = function() {
        return Fe(this)
    }
    ;
    var Je = function(q) {
        return q.key
    }
      , We = t.keys = function(K) {
        return we(K, Je)
    }
    ;
    I.prototype.keys = function() {
        return We(this)
    }
    ;
    var Me = function(q) {
        return q.value
    }
      , Qe = t.values = I.prototype.values = function(K) {
        return we(K, Me)
    }
    ;
    I.prototype.values = function() {
        return Qe(this)
    }
    ;
    var tt = t.fold = function(K, q, xe) {
        var Ne = xe._root;
        if (Ne.type === _)
            return K(q, Ne.value, Ne.key);
        for (var H = [Ne.children], te = void 0; te = H.pop(); )
            for (var me = 0, Te = te.length; me < Te; ) {
                var Pe = te[me++];
                Pe && Pe.type && (Pe.type === _ ? q = K(q, Pe.value, Pe.key) : H.push(Pe.children))
            }
        return q
    }
    ;
    I.prototype.fold = function(K, q) {
        return tt(K, q, this)
    }
    ;
    var st = t.forEach = function(K, q) {
        return tt(function(xe, Ne, H) {
            return K(Ne, H, q)
        }, null, q)
    }
    ;
    I.prototype.forEach = function(K) {
        return st(K, this)
    }
    ;
    var Xe = t.count = function(K) {
        return K._size
    }
    ;
    I.prototype.count = function() {
        return Xe(this)
    }
    ,
    Object.defineProperty(I.prototype, "size", {
        get: I.prototype.count
    }),
    n.exports ? n.exports = t : (void 0).hamt = t
});
class EO {
    constructor(e) {
        vt(this, "_map", void 0),
        this._map = new Map(e == null ? void 0 : e.entries())
    }
    keys() {
        return this._map.keys()
    }
    entries() {
        return this._map.entries()
    }
    get(e) {
        return this._map.get(e)
    }
    has(e) {
        return this._map.has(e)
    }
    set(e, t) {
        return this._map.set(e, t),
        this
    }
    delete(e) {
        return this._map.delete(e),
        this
    }
    clone() {
        return v1(this)
    }
    toMap() {
        return new Map(this._map)
    }
}
class g1 {
    constructor(e) {
        if (vt(this, "_hamt", MO.empty.beginMutation()),
        e instanceof g1) {
            const t = e._hamt.endMutation();
            e._hamt = t.beginMutation(),
            this._hamt = t.beginMutation()
        } else if (e)
            for (const [t,i] of e.entries())
                this._hamt.set(t, i)
    }
    keys() {
        return this._hamt.keys()
    }
    entries() {
        return this._hamt.entries()
    }
    get(e) {
        return this._hamt.get(e)
    }
    has(e) {
        return this._hamt.has(e)
    }
    set(e, t) {
        return this._hamt.set(e, t),
        this
    }
    delete(e) {
        return this._hamt.delete(e),
        this
    }
    clone() {
        return v1(this)
    }
    toMap() {
        return new Map(this._hamt)
    }
}
function v1(n) {
    return Zt("recoil_hamt_2020") ? new g1(n) : new EO(n)
}
var TO = {
    persistentMap: v1
}
  , AO = TO.persistentMap
  , RO = Object.freeze({
    __proto__: null,
    persistentMap: AO
});
function CO(n, ...e) {
    const t = new Set;
    e: for (const i of n) {
        for (const r of e)
            if (r.has(i))
                continue e;
        t.add(i)
    }
    return t
}
var Rf = CO;
function bO(n, e) {
    const t = new Map;
    return n.forEach((i,r)=>{
        t.set(r, e(i, r))
    }
    ),
    t
}
var qm = bO;
function PO() {
    return {
        nodeDeps: new Map,
        nodeToNodeSubscriptions: new Map
    }
}
function LO(n) {
    return {
        nodeDeps: qm(n.nodeDeps, e=>new Set(e)),
        nodeToNodeSubscriptions: qm(n.nodeToNodeSubscriptions, e=>new Set(e))
    }
}
function cy(n, e, t, i) {
    const {nodeDeps: r, nodeToNodeSubscriptions: s} = t
      , o = r.get(n);
    if (o && i && o !== i.nodeDeps.get(n))
        return;
    r.set(n, e);
    const a = o == null ? e : Rf(e, o);
    for (const l of a)
        s.has(l) || s.set(l, new Set),
        cn(s.get(l)).add(n);
    if (o) {
        const l = Rf(o, e);
        for (const f of l) {
            if (!s.has(f))
                return;
            const d = cn(s.get(f));
            d.delete(n),
            d.size === 0 && s.delete(f)
        }
    }
}
function IO(n, e, t, i) {
    var r, s, o, a;
    const l = t.getState();
    i === l.currentTree.version || i === ((r = l.nextTree) === null || r === void 0 ? void 0 : r.version) || ((s = l.previousTree) === null || s === void 0 || s.version);
    const f = t.getGraph(i);
    if (cy(n, e, f),
    i === ((o = l.previousTree) === null || o === void 0 ? void 0 : o.version)) {
        const h = t.getGraph(l.currentTree.version);
        cy(n, e, h, f)
    }
    if (i === ((a = l.previousTree) === null || a === void 0 ? void 0 : a.version) || i === l.currentTree.version) {
        var d;
        const h = (d = l.nextTree) === null || d === void 0 ? void 0 : d.version;
        if (h !== void 0) {
            const p = t.getGraph(h);
            cy(n, e, p, f)
        }
    }
}
var Sd = {
    cloneGraph: LO,
    graph: PO,
    saveDepsToStore: IO
};
let NO = 0;
const DO = ()=>NO++;
let UO = 0;
const kO = ()=>UO++;
let OO = 0;
const FO = ()=>OO++;
var Xg = {
    getNextTreeStateVersion: DO,
    getNextStoreID: kO,
    getNextComponentID: FO
};
const {persistentMap: xT} = RO
  , {graph: zO} = Sd
  , {getNextTreeStateVersion: R2} = Xg;
function C2() {
    const n = R2();
    return {
        version: n,
        stateID: n,
        transactionMetadata: {},
        dirtyAtoms: new Set,
        atomValues: xT(),
        nonvalidatedAtoms: xT()
    }
}
function BO() {
    const n = C2();
    return {
        currentTree: n,
        nextTree: null,
        previousTree: null,
        commitDepth: 0,
        knownAtoms: new Set,
        knownSelectors: new Set,
        transactionSubscriptions: new Map,
        nodeTransactionSubscriptions: new Map,
        nodeToComponentSubscriptions: new Map,
        queuedComponentCallbacks_DEPRECATED: [],
        suspendedComponentResolvers: new Set,
        graphsByVersion: new Map().set(n.version, zO()),
        retention: {
            referenceCounts: new Map,
            nodesRetainedByZone: new Map,
            retainablesToCheckForRelease: new Set
        },
        nodeCleanupFunctions: new Map
    }
}
var b2 = {
    makeEmptyTreeState: C2,
    makeEmptyStoreState: BO,
    getNextTreeStateVersion: R2
};
class P2 {
}
function VO() {
    return new P2
}
var $g = {
    RetentionZone: P2,
    retentionZone: VO
};
function HO(n, e) {
    const t = new Set(n);
    return t.add(e),
    t
}
function GO(n, e) {
    const t = new Set(n);
    return t.delete(e),
    t
}
function WO(n, e, t) {
    const i = new Map(n);
    return i.set(e, t),
    i
}
function XO(n, e, t) {
    const i = new Map(n);
    return i.set(e, t(i.get(e))),
    i
}
function $O(n, e) {
    const t = new Map(n);
    return t.delete(e),
    t
}
function jO(n, e) {
    const t = new Map(n);
    return e.forEach(i=>t.delete(i)),
    t
}
var L2 = {
    setByAddingToSet: HO,
    setByDeletingFromSet: GO,
    mapBySettingInMap: WO,
    mapByUpdatingInMap: XO,
    mapByDeletingFromMap: $O,
    mapByDeletingMultipleFromMap: jO
};
function *YO(n, e) {
    let t = 0;
    for (const i of n)
        e(i, t++) && (yield i)
}
var y1 = YO;
function qO(n, e) {
    return new Proxy(n,{
        get: (i,r)=>(!(r in i) && r in e && (i[r] = e[r]()),
        i[r]),
        ownKeys: i=>Object.keys(i)
    })
}
var I2 = qO;
const {getNode: wd, getNodeMaybe: KO, recoilValuesForKeys: ST} = Fi
  , {RetentionZone: wT} = $g
  , {setByAddingToSet: ZO} = L2
  , QO = Object.freeze(new Set);
class JO extends Error {
}
function eF(n, e, t) {
    if (!Zt("recoil_memory_managament_2020"))
        return ()=>{}
        ;
    const {nodesRetainedByZone: i} = n.getState().retention;
    function r(s) {
        let o = i.get(s);
        o || i.set(s, o = new Set),
        o.add(e)
    }
    if (t instanceof wT)
        r(t);
    else if (Array.isArray(t))
        for (const s of t)
            r(s);
    return ()=>{
        if (!Zt("recoil_memory_managament_2020"))
            return;
        const {retention: s} = n.getState();
        function o(a) {
            const l = s.nodesRetainedByZone.get(a);
            l == null || l.delete(e),
            l && l.size === 0 && s.nodesRetainedByZone.delete(a)
        }
        if (t instanceof wT)
            o(t);
        else if (Array.isArray(t))
            for (const a of t)
                o(a)
    }
}
function _1(n, e, t, i) {
    const r = n.getState();
    if (r.nodeCleanupFunctions.has(t))
        return;
    const s = wd(t)
      , o = eF(n, t, s.retainedBy)
      , a = s.init(n, e, i);
    r.nodeCleanupFunctions.set(t, ()=>{
        a(),
        o()
    }
    )
}
function tF(n, e, t) {
    _1(n, n.getState().currentTree, e, t)
}
function nF(n, e) {
    var t;
    const i = n.getState();
    (t = i.nodeCleanupFunctions.get(e)) === null || t === void 0 || t(),
    i.nodeCleanupFunctions.delete(e)
}
function iF(n, e, t) {
    return _1(n, e, t, "get"),
    wd(t).get(n, e)
}
function N2(n, e, t) {
    return wd(t).peek(n, e)
}
function rF(n, e, t) {
    var i;
    const r = KO(e);
    return r == null || (i = r.invalidate) === null || i === void 0 || i.call(r, n),
    {
        ...n,
        atomValues: n.atomValues.clone().delete(e),
        nonvalidatedAtoms: n.nonvalidatedAtoms.clone().set(e, t),
        dirtyAtoms: ZO(n.dirtyAtoms, e)
    }
}
function sF(n, e, t, i) {
    const r = wd(t);
    if (r.set == null)
        throw new JO(`Attempt to set read-only RecoilValue: ${t}`);
    const s = r.set;
    return _1(n, e, t, "set"),
    s(n, e, i)
}
function oF(n, e, t) {
    const i = n.getState()
      , r = n.getGraph(e.version)
      , s = wd(t).nodeType;
    return I2({
        type: s
    }, {
        loadable: ()=>N2(n, e, t),
        isActive: ()=>i.knownAtoms.has(t) || i.knownSelectors.has(t),
        isSet: ()=>s === "selector" ? !1 : e.atomValues.has(t),
        isModified: ()=>e.dirtyAtoms.has(t),
        deps: ()=>{
            var o;
            return ST((o = r.nodeDeps.get(t)) !== null && o !== void 0 ? o : [])
        }
        ,
        subscribers: ()=>{
            var o, a;
            return {
                nodes: ST(y1(D2(n, e, new Set([t])), l=>l !== t)),
                components: Wg((o = (a = i.nodeToComponentSubscriptions.get(t)) === null || a === void 0 ? void 0 : a.values()) !== null && o !== void 0 ? o : [], ([l])=>({
                    name: l
                }))
            }
        }
    })
}
function D2(n, e, t) {
    const i = new Set
      , r = Array.from(t)
      , s = n.getGraph(e.version);
    for (let a = r.pop(); a; a = r.pop()) {
        var o;
        i.add(a);
        const l = (o = s.nodeToNodeSubscriptions.get(a)) !== null && o !== void 0 ? o : QO;
        for (const f of l)
            i.has(f) || r.push(f)
    }
    return i
}
var ia = {
    getNodeLoadable: iF,
    peekNodeLoadable: N2,
    setNodeValue: sF,
    initializeNode: tF,
    cleanUpNode: nF,
    setUnvalidatedAtomValue_DEPRECATED: rF,
    peekNodeInfo: oF,
    getDownstreamNodes: D2
};
let U2 = null;
function aF(n) {
    U2 = n
}
function lF() {
    var n;
    (n = U2) === null || n === void 0 || n()
}
var k2 = {
    setInvalidateMemoizedSnapshot: aF,
    invalidateMemoizedSnapshot: lF
};
const {getDownstreamNodes: cF, getNodeLoadable: O2, setNodeValue: uF} = ia
  , {getNextComponentID: fF} = Xg
  , {getNode: dF, getNodeMaybe: F2} = Fi
  , {DefaultValue: x1} = Fi
  , {reactMode: hF} = xd
  , {AbstractRecoilValue: pF, RecoilState: mF, RecoilValueReadOnly: gF, isRecoilValue: vF} = Wc
  , {invalidateMemoizedSnapshot: yF} = k2;
function _F(n, {key: e}, t=n.getState().currentTree) {
    var i, r;
    const s = n.getState();
    t.version === s.currentTree.version || t.version === ((i = s.nextTree) === null || i === void 0 ? void 0 : i.version) || (t.version,
    (r = s.previousTree) === null || r === void 0 || r.version);
    const o = O2(n, t, e);
    return o.state === "loading" && o.contents.catch(()=>{}
    ),
    o
}
function xF(n, e) {
    const t = n.clone();
    return e.forEach((i,r)=>{
        i.state === "hasValue" && i.contents instanceof x1 ? t.delete(r) : t.set(r, i)
    }
    ),
    t
}
function SF(n, e, {key: t}, i) {
    if (typeof i == "function") {
        const r = O2(n, e, t);
        if (r.state === "loading") {
            const s = `Tried to set atom or selector "${t}" using an updater function while the current state is pending, this is not currently supported.`;
            throw St(s)
        } else if (r.state === "hasError")
            throw r.contents;
        return i(r.contents)
    } else
        return i
}
function wF(n, e, t) {
    if (t.type === "set") {
        const {recoilValue: r, valueOrUpdater: s} = t
          , o = SF(n, e, r, s)
          , a = uF(n, e, r.key, o);
        for (const [l,f] of a.entries())
            lx(e, l, f)
    } else if (t.type === "setLoadable") {
        const {recoilValue: {key: r}, loadable: s} = t;
        lx(e, r, s)
    } else if (t.type === "markModified") {
        const {recoilValue: {key: r}} = t;
        e.dirtyAtoms.add(r)
    } else if (t.type === "setUnvalidated") {
        var i;
        const {recoilValue: {key: r}, unvalidatedValue: s} = t
          , o = F2(r);
        o == null || (i = o.invalidate) === null || i === void 0 || i.call(o, e),
        e.atomValues.delete(r),
        e.nonvalidatedAtoms.set(r, s),
        e.dirtyAtoms.add(r)
    } else
        h1(`Unknown action ${t.type}`)
}
function lx(n, e, t) {
    t.state === "hasValue" && t.contents instanceof x1 ? n.atomValues.delete(e) : n.atomValues.set(e, t),
    n.dirtyAtoms.add(e),
    n.nonvalidatedAtoms.delete(e)
}
function z2(n, e) {
    n.replaceState(t=>{
        const i = B2(t);
        for (const r of e)
            wF(n, i, r);
        return V2(n, i),
        yF(),
        i
    }
    )
}
function jg(n, e) {
    if (Cf.length) {
        const t = Cf[Cf.length - 1];
        let i = t.get(n);
        i || t.set(n, i = []),
        i.push(e)
    } else
        z2(n, [e])
}
const Cf = [];
function MF() {
    const n = new Map;
    return Cf.push(n),
    ()=>{
        for (const [e,t] of n)
            z2(e, t);
        Cf.pop()
    }
}
function B2(n) {
    return {
        ...n,
        atomValues: n.atomValues.clone(),
        nonvalidatedAtoms: n.nonvalidatedAtoms.clone(),
        dirtyAtoms: new Set(n.dirtyAtoms)
    }
}
function V2(n, e) {
    const t = cF(n, e, e.dirtyAtoms);
    for (const s of t) {
        var i, r;
        (i = F2(s)) === null || i === void 0 || (r = i.invalidate) === null || r === void 0 || r.call(i, e)
    }
}
function H2(n, e, t) {
    jg(n, {
        type: "set",
        recoilValue: e,
        valueOrUpdater: t
    })
}
function EF(n, e, t) {
    if (t instanceof x1)
        return H2(n, e, t);
    jg(n, {
        type: "setLoadable",
        recoilValue: e,
        loadable: t
    })
}
function TF(n, e) {
    jg(n, {
        type: "markModified",
        recoilValue: e
    })
}
function AF(n, e, t) {
    jg(n, {
        type: "setUnvalidated",
        recoilValue: e,
        unvalidatedValue: t
    })
}
function RF(n, {key: e}, t, i=null) {
    const r = fF()
      , s = n.getState();
    s.nodeToComponentSubscriptions.has(e) || s.nodeToComponentSubscriptions.set(e, new Map),
    cn(s.nodeToComponentSubscriptions.get(e)).set(r, [i ?? "<not captured>", t]);
    const o = hF();
    if (o.early && (o.mode === "LEGACY" || o.mode === "MUTABLE_SOURCE")) {
        const a = n.getState().nextTree;
        a && a.dirtyAtoms.has(e) && t(a)
    }
    return {
        release: ()=>{
            const a = n.getState()
              , l = a.nodeToComponentSubscriptions.get(e);
            l === void 0 || !l.has(r) || (l.delete(r),
            l.size === 0 && a.nodeToComponentSubscriptions.delete(e))
        }
    }
}
function CF(n, e) {
    var t;
    const {currentTree: i} = n.getState()
      , r = dF(e.key);
    (t = r.clearCache) === null || t === void 0 || t.call(r, n, i)
}
var Ts = {
    RecoilValueReadOnly: gF,
    AbstractRecoilValue: pF,
    RecoilState: mF,
    getRecoilValueAsLoadable: _F,
    setRecoilValue: H2,
    setRecoilValueLoadable: EF,
    markRecoilValueModified: TF,
    setUnvalidatedRecoilValue: AF,
    subscribeToRecoilValue: RF,
    isRecoilValue: vF,
    applyAtomValueWrites: xF,
    batchStart: MF,
    writeLoadableToTreeState: lx,
    invalidateDownstreams: V2,
    copyTreeState: B2,
    refreshRecoilValue: CF
};
function bF(n, e, t) {
    const i = n.entries();
    let r = i.next();
    for (; !r.done; ) {
        const s = r.value;
        if (e.call(t, s[1], s[0], n))
            return !0;
        r = i.next()
    }
    return !1
}
var PF = bF;
const {cleanUpNode: LF} = ia
  , {deleteNodeConfigIfPossible: IF, getNode: G2} = Fi
  , {RetentionZone: W2} = $g
  , NF = 12e4
  , X2 = new Set;
function $2(n, e) {
    const t = n.getState()
      , i = t.currentTree;
    if (t.nextTree)
        return;
    const r = new Set;
    for (const o of e)
        if (o instanceof W2)
            for (const a of OF(t, o))
                r.add(a);
        else
            r.add(o);
    const s = DF(n, r);
    for (const o of s)
        kF(n, i, o)
}
function DF(n, e) {
    const t = n.getState()
      , i = t.currentTree
      , r = n.getGraph(i.version)
      , s = new Set
      , o = new Set;
    return a(e),
    s;
    function a(l) {
        const f = new Set
          , d = UF(n, i, l, s, o);
        for (const y of d) {
            var h;
            if (G2(y).retainedBy === "recoilRoot") {
                o.add(y);
                continue
            }
            if (((h = t.retention.referenceCounts.get(y)) !== null && h !== void 0 ? h : 0) > 0) {
                o.add(y);
                continue
            }
            if (j2(y).some(M=>t.retention.referenceCounts.get(M))) {
                o.add(y);
                continue
            }
            const S = r.nodeToNodeSubscriptions.get(y);
            if (S && PF(S, M=>o.has(M))) {
                o.add(y);
                continue
            }
            s.add(y),
            f.add(y)
        }
        const p = new Set;
        for (const y of f)
            for (const S of (m = r.nodeDeps.get(y)) !== null && m !== void 0 ? m : X2) {
                var m;
                s.has(S) || p.add(S)
            }
        p.size && a(p)
    }
}
function UF(n, e, t, i, r) {
    const s = n.getGraph(e.version)
      , o = []
      , a = new Set;
    for (; t.size > 0; )
        l(cn(t.values().next().value));
    return o;
    function l(f) {
        if (i.has(f) || r.has(f)) {
            t.delete(f);
            return
        }
        if (a.has(f))
            return;
        const d = s.nodeToNodeSubscriptions.get(f);
        if (d)
            for (const h of d)
                l(h);
        a.add(f),
        t.delete(f),
        o.push(f)
    }
}
function kF(n, e, t) {
    if (!Zt("recoil_memory_managament_2020"))
        return;
    LF(n, t);
    const i = n.getState();
    i.knownAtoms.delete(t),
    i.knownSelectors.delete(t),
    i.nodeTransactionSubscriptions.delete(t),
    i.retention.referenceCounts.delete(t);
    const r = j2(t);
    for (const l of r) {
        var s;
        (s = i.retention.nodesRetainedByZone.get(l)) === null || s === void 0 || s.delete(t)
    }
    e.atomValues.delete(t),
    e.dirtyAtoms.delete(t),
    e.nonvalidatedAtoms.delete(t);
    const o = i.graphsByVersion.get(e.version);
    if (o) {
        const l = o.nodeDeps.get(t);
        if (l !== void 0) {
            o.nodeDeps.delete(t);
            for (const f of l) {
                var a;
                (a = o.nodeToNodeSubscriptions.get(f)) === null || a === void 0 || a.delete(t)
            }
        }
        o.nodeToNodeSubscriptions.delete(t)
    }
    IF(t)
}
function OF(n, e) {
    var t;
    return (t = n.retention.nodesRetainedByZone.get(e)) !== null && t !== void 0 ? t : X2
}
function j2(n) {
    const e = G2(n).retainedBy;
    return e === void 0 || e === "components" || e === "recoilRoot" ? [] : e instanceof W2 ? [e] : e
}
function FF(n, e) {
    const t = n.getState();
    t.nextTree ? t.retention.retainablesToCheckForRelease.add(e) : $2(n, new Set([e]))
}
function zF(n, e, t) {
    var i;
    if (!Zt("recoil_memory_managament_2020"))
        return;
    const r = n.getState().retention.referenceCounts
      , s = ((i = r.get(e)) !== null && i !== void 0 ? i : 0) + t;
    s === 0 ? Y2(n, e) : r.set(e, s)
}
function Y2(n, e) {
    if (!Zt("recoil_memory_managament_2020"))
        return;
    n.getState().retention.referenceCounts.delete(e),
    FF(n, e)
}
function BF(n) {
    if (!Zt("recoil_memory_managament_2020"))
        return;
    const e = n.getState();
    $2(n, e.retention.retainablesToCheckForRelease),
    e.retention.retainablesToCheckForRelease.clear()
}
function VF(n) {
    return n === void 0 ? "recoilRoot" : n
}
var fl = {
    SUSPENSE_TIMEOUT_MS: NF,
    updateRetainCount: zF,
    updateRetainCountToZero: Y2,
    releaseScheduledRetainablesNow: BF,
    retainedByOptionWithDefault: VF
};
const {unstable_batchedUpdates: HF} = NU;
var GF = {
    unstable_batchedUpdates: HF
};
const {unstable_batchedUpdates: WF} = GF;
var XF = {
    unstable_batchedUpdates: WF
};
const {batchStart: $F} = Ts
  , {unstable_batchedUpdates: jF} = XF;
let S1 = jF || (n=>n());
const YF = n=>{
    S1 = n
}
  , qF = ()=>S1
  , KF = n=>{
    S1(()=>{
        let e = ()=>{}
        ;
        try {
            e = $F(),
            n()
        } finally {
            e()
        }
    }
    )
}
;
var Yg = {
    getBatcher: qF,
    setBatcher: YF,
    batchUpdates: KF
};
function *ZF(n) {
    for (const e of n)
        for (const t of e)
            yield t
}
var q2 = ZF;
const K2 = typeof Window > "u" || typeof window > "u"
  , QF = n=>!K2 && (n === window || n instanceof Window)
  , JF = typeof navigator < "u" && navigator.product === "ReactNative";
var qg = {
    isSSR: K2,
    isReactNative: JF,
    isWindow: QF
};
function ez(n, e) {
    let t;
    return (...i)=>{
        t || (t = {});
        const r = e(...i);
        return Object.hasOwnProperty.call(t, r) || (t[r] = n(...i)),
        t[r]
    }
}
function tz(n, e) {
    let t, i;
    return (...r)=>{
        const s = e(...r);
        return t === s || (t = s,
        i = n(...r)),
        i
    }
}
function nz(n, e) {
    let t, i;
    return [(...o)=>{
        const a = e(...o);
        return t === a || (t = a,
        i = n(...o)),
        i
    }
    , ()=>{
        t = null
    }
    ]
}
var iz = {
    memoizeWithArgsHash: ez,
    memoizeOneWithArgsHash: tz,
    memoizeOneWithArgsHashAndInvalidation: nz
};
const {batchUpdates: cx} = Yg
  , {initializeNode: rz, peekNodeInfo: sz} = ia
  , {graph: oz} = Sd
  , {getNextStoreID: az} = Xg
  , {DEFAULT_VALUE: lz, recoilValues: MT, recoilValuesForKeys: ET} = Fi
  , {AbstractRecoilValue: cz, getRecoilValueAsLoadable: uz, setRecoilValue: TT, setUnvalidatedRecoilValue: fz} = Ts
  , {updateRetainCount: hm} = fl
  , {setInvalidateMemoizedSnapshot: dz} = k2
  , {getNextTreeStateVersion: hz, makeEmptyStoreState: pz} = b2
  , {isSSR: mz} = qg
  , {memoizeOneWithArgsHashAndInvalidation: gz} = iz;
class Kg {
    constructor(e, t) {
        vt(this, "_store", void 0),
        vt(this, "_refCount", 1),
        vt(this, "getLoadable", i=>(this.checkRefCount_INTERNAL(),
        uz(this._store, i))),
        vt(this, "getPromise", i=>(this.checkRefCount_INTERNAL(),
        this.getLoadable(i).toPromise())),
        vt(this, "getNodes_UNSTABLE", i=>{
            if (this.checkRefCount_INTERNAL(),
            (i == null ? void 0 : i.isModified) === !0) {
                if ((i == null ? void 0 : i.isInitialized) === !1)
                    return [];
                const o = this._store.getState().currentTree;
                return ET(o.dirtyAtoms)
            }
            const r = this._store.getState().knownAtoms
              , s = this._store.getState().knownSelectors;
            return (i == null ? void 0 : i.isInitialized) == null ? MT.values() : i.isInitialized === !0 ? ET(q2([r, s])) : y1(MT.values(), ({key: o})=>!r.has(o) && !s.has(o))
        }
        ),
        vt(this, "getInfo_UNSTABLE", ({key: i})=>(this.checkRefCount_INTERNAL(),
        sz(this._store, this._store.getState().currentTree, i))),
        vt(this, "map", i=>{
            this.checkRefCount_INTERNAL();
            const r = new ux(this,cx);
            return i(r),
            r
        }
        ),
        vt(this, "asyncMap", async i=>{
            this.checkRefCount_INTERNAL();
            const r = new ux(this,cx);
            return r.retain(),
            await i(r),
            r.autoRelease_INTERNAL(),
            r
        }
        ),
        this._store = {
            storeID: az(),
            parentStoreID: t,
            getState: ()=>e,
            replaceState: i=>{
                e.currentTree = i(e.currentTree)
            }
            ,
            getGraph: i=>{
                const r = e.graphsByVersion;
                if (r.has(i))
                    return cn(r.get(i));
                const s = oz();
                return r.set(i, s),
                s
            }
            ,
            subscribeToTransactions: ()=>({
                release: ()=>{}
            }),
            addTransactionMetadata: ()=>{
                throw St("Cannot subscribe to Snapshots")
            }
        };
        for (const i of this._store.getState().knownAtoms)
            rz(this._store, i, "get"),
            hm(this._store, i, 1);
        this.autoRelease_INTERNAL()
    }
    retain() {
        this._refCount <= 0,
        this._refCount++;
        let e = !1;
        return ()=>{
            e || (e = !0,
            this._release())
        }
    }
    autoRelease_INTERNAL() {
        mz || window.setTimeout(()=>this._release(), 10)
    }
    _release() {
        if (this._refCount--,
        this._refCount === 0) {
            if (this._store.getState().nodeCleanupFunctions.forEach(e=>e()),
            this._store.getState().nodeCleanupFunctions.clear(),
            !Zt("recoil_memory_managament_2020"))
                return
        } else
            this._refCount < 0
    }
    isRetained() {
        return this._refCount > 0
    }
    checkRefCount_INTERNAL() {
        Zt("recoil_memory_managament_2020") && this._refCount <= 0
    }
    getStore_INTERNAL() {
        return this.checkRefCount_INTERNAL(),
        this._store
    }
    getID() {
        return this.checkRefCount_INTERNAL(),
        this._store.getState().currentTree.stateID
    }
    getStoreID() {
        return this.checkRefCount_INTERNAL(),
        this._store.storeID
    }
}
function Z2(n, e, t=!1) {
    const i = n.getState()
      , r = t ? hz() : e.version;
    return {
        currentTree: {
            version: t ? r : e.version,
            stateID: t ? r : e.stateID,
            transactionMetadata: {
                ...e.transactionMetadata
            },
            dirtyAtoms: new Set(e.dirtyAtoms),
            atomValues: e.atomValues.clone(),
            nonvalidatedAtoms: e.nonvalidatedAtoms.clone()
        },
        commitDepth: 0,
        nextTree: null,
        previousTree: null,
        knownAtoms: new Set(i.knownAtoms),
        knownSelectors: new Set(i.knownSelectors),
        transactionSubscriptions: new Map,
        nodeTransactionSubscriptions: new Map,
        nodeToComponentSubscriptions: new Map,
        queuedComponentCallbacks_DEPRECATED: [],
        suspendedComponentResolvers: new Set,
        graphsByVersion: new Map().set(r, n.getGraph(e.version)),
        retention: {
            referenceCounts: new Map,
            nodesRetainedByZone: new Map,
            retainablesToCheckForRelease: new Set
        },
        nodeCleanupFunctions: new Map(Wg(i.nodeCleanupFunctions.entries(), ([s])=>[s, ()=>{}
        ]))
    }
}
function vz(n) {
    const e = new Kg(pz());
    return n != null ? e.map(n) : e
}
const [AT,Q2] = gz((n,e)=>{
    var t;
    const i = n.getState()
      , r = e === "latest" ? (t = i.nextTree) !== null && t !== void 0 ? t : i.currentTree : cn(i.previousTree);
    return new Kg(Z2(n, r),n.storeID)
}
, (n,e)=>{
    var t, i;
    return String(e) + String(n.storeID) + String((t = n.getState().nextTree) === null || t === void 0 ? void 0 : t.version) + String(n.getState().currentTree.version) + String((i = n.getState().previousTree) === null || i === void 0 ? void 0 : i.version)
}
);
dz(Q2);
function yz(n, e="latest") {
    const t = AT(n, e);
    return t.isRetained() ? t : (Q2(),
    AT(n, e))
}
class ux extends Kg {
    constructor(e, t) {
        super(Z2(e.getStore_INTERNAL(), e.getStore_INTERNAL().getState().currentTree, !0), e.getStoreID()),
        vt(this, "_batch", void 0),
        vt(this, "set", (i,r)=>{
            this.checkRefCount_INTERNAL();
            const s = this.getStore_INTERNAL();
            this._batch(()=>{
                hm(s, i.key, 1),
                TT(this.getStore_INTERNAL(), i, r)
            }
            )
        }
        ),
        vt(this, "reset", i=>{
            this.checkRefCount_INTERNAL();
            const r = this.getStore_INTERNAL();
            this._batch(()=>{
                hm(r, i.key, 1),
                TT(this.getStore_INTERNAL(), i, lz)
            }
            )
        }
        ),
        vt(this, "setUnvalidatedAtomValues_DEPRECATED", i=>{
            this.checkRefCount_INTERNAL();
            const r = this.getStore_INTERNAL();
            cx(()=>{
                for (const [s,o] of i.entries())
                    hm(r, s, 1),
                    fz(r, new cz(s), o)
            }
            )
        }
        ),
        this._batch = t
    }
}
var Zg = {
    Snapshot: Kg,
    MutableSnapshot: ux,
    freshSnapshot: vz,
    cloneSnapshot: yz
}
  , _z = Zg.Snapshot
  , xz = Zg.MutableSnapshot
  , Sz = Zg.freshSnapshot
  , wz = Zg.cloneSnapshot
  , Qg = Object.freeze({
    __proto__: null,
    Snapshot: _z,
    MutableSnapshot: xz,
    freshSnapshot: Sz,
    cloneSnapshot: wz
});
function Mz(...n) {
    const e = new Set;
    for (const t of n)
        for (const i of t)
            e.add(i);
    return e
}
var Ez = Mz;
const {useRef: Tz} = Wt;
function Az(n) {
    const e = Tz(n);
    return e.current === n && typeof n == "function" && (e.current = n()),
    e
}
var RT = Az;
const {getNextTreeStateVersion: Rz, makeEmptyStoreState: J2} = b2
  , {cleanUpNode: Cz, getDownstreamNodes: bz, initializeNode: Pz, setNodeValue: Lz, setUnvalidatedAtomValue_DEPRECATED: Iz} = ia
  , {graph: Nz} = Sd
  , {cloneGraph: Dz} = Sd
  , {getNextStoreID: eP} = Xg
  , {createMutableSource: uy, reactMode: tP} = xd
  , {applyAtomValueWrites: Uz} = Ts
  , {releaseScheduledRetainablesNow: nP} = fl
  , {freshSnapshot: kz} = Qg
  , {useCallback: Oz, useContext: iP, useEffect: fx, useMemo: Fz, useRef: zz, useState: Bz} = Wt;
function Wu() {
    throw St("This component must be used inside a <RecoilRoot> component.")
}
const rP = Object.freeze({
    storeID: eP(),
    getState: Wu,
    replaceState: Wu,
    getGraph: Wu,
    subscribeToTransactions: Wu,
    addTransactionMetadata: Wu
});
let dx = !1;
function CT(n) {
    if (dx)
        throw St("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");
    const e = n.getState();
    if (e.nextTree === null) {
        Zt("recoil_memory_managament_2020") && Zt("recoil_release_on_cascading_update_killswitch_2021") && e.commitDepth > 0 && nP(n);
        const t = e.currentTree.version
          , i = Rz();
        e.nextTree = {
            ...e.currentTree,
            version: i,
            stateID: i,
            dirtyAtoms: new Set,
            transactionMetadata: {}
        },
        e.graphsByVersion.set(i, Dz(cn(e.graphsByVersion.get(t))))
    }
}
const sP = Wt.createContext({
    current: rP
})
  , Jg = ()=>iP(sP)
  , oP = Wt.createContext(null);
function Vz() {
    return iP(oP)
}
function w1(n, e, t) {
    const i = bz(n, t, t.dirtyAtoms);
    for (const r of i) {
        const s = e.nodeToComponentSubscriptions.get(r);
        if (s)
            for (const [o,[a,l]] of s)
                l(t)
    }
}
function aP(n) {
    const e = n.getState()
      , t = e.currentTree
      , i = t.dirtyAtoms;
    if (i.size) {
        for (const [r,s] of e.nodeTransactionSubscriptions)
            if (i.has(r))
                for (const [o,a] of s)
                    a(n);
        for (const [r,s] of e.transactionSubscriptions)
            s(n);
        (!tP().early || e.suspendedComponentResolvers.size > 0) && (w1(n, e, t),
        e.suspendedComponentResolvers.forEach(r=>r()),
        e.suspendedComponentResolvers.clear())
    }
    e.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(t)),
    e.queuedComponentCallbacks_DEPRECATED.splice(0, e.queuedComponentCallbacks_DEPRECATED.length)
}
function Hz(n) {
    const e = n.getState();
    e.commitDepth++;
    try {
        const {nextTree: t} = e;
        if (t == null)
            return;
        e.previousTree = e.currentTree,
        e.currentTree = t,
        e.nextTree = null,
        aP(n),
        e.previousTree != null ? e.graphsByVersion.delete(e.previousTree.version) : h1("Ended batch with no previous state, which is unexpected", "recoil"),
        e.previousTree = null,
        Zt("recoil_memory_managament_2020") && t == null && nP(n)
    } finally {
        e.commitDepth--
    }
}
function Gz({setNotifyBatcherOfChange: n}) {
    const e = Jg()
      , [,t] = Bz([]);
    return n(()=>t({})),
    fx(()=>(n(()=>t({})),
    ()=>{
        n(()=>{}
        )
    }
    ), [n]),
    fx(()=>{
        SO.enqueueExecution("Batcher", ()=>{
            Hz(e.current)
        }
        )
    }
    ),
    null
}
function Wz(n, e) {
    const t = J2();
    return e({
        set: (i,r)=>{
            const s = t.currentTree
              , o = Lz(n, s, i.key, r)
              , a = new Set(o.keys())
              , l = s.nonvalidatedAtoms.clone();
            for (const f of a)
                l.delete(f);
            t.currentTree = {
                ...s,
                dirtyAtoms: Ez(s.dirtyAtoms, a),
                atomValues: Uz(s.atomValues, o),
                nonvalidatedAtoms: l
            }
        }
        ,
        setUnvalidatedAtomValues: i=>{
            i.forEach((r,s)=>{
                t.currentTree = Iz(t.currentTree, s, r)
            }
            )
        }
    }),
    t
}
function Xz(n) {
    const e = kz(n)
      , t = e.getStore_INTERNAL().getState();
    return e.retain(),
    t.nodeCleanupFunctions.forEach(i=>i()),
    t.nodeCleanupFunctions.clear(),
    t
}
let bT = 0;
function $z({initializeState_DEPRECATED: n, initializeState: e, store_INTERNAL: t, children: i}) {
    let r;
    const s = m=>{
        const y = r.current.graphsByVersion;
        if (y.has(m))
            return cn(y.get(m));
        const S = Nz();
        return y.set(m, S),
        S
    }
      , o = (m,y)=>{
        if (y == null) {
            const {transactionSubscriptions: S} = h.current.getState()
              , M = bT++;
            return S.set(M, m),
            {
                release: ()=>{
                    S.delete(M)
                }
            }
        } else {
            const {nodeTransactionSubscriptions: S} = h.current.getState();
            S.has(y) || S.set(y, new Map);
            const M = bT++;
            return cn(S.get(y)).set(M, m),
            {
                release: ()=>{
                    const g = S.get(y);
                    g && (g.delete(M),
                    g.size === 0 && S.delete(y))
                }
            }
        }
    }
      , a = m=>{
        CT(h.current);
        for (const y of Object.keys(m))
            cn(h.current.getState().nextTree).transactionMetadata[y] = m[y]
    }
      , l = m=>{
        CT(h.current);
        const y = cn(r.current.nextTree);
        let S;
        try {
            dx = !0,
            S = m(y)
        } finally {
            dx = !1
        }
        S !== y && (r.current.nextTree = S,
        tP().early && w1(h.current, r.current, S),
        cn(f.current)())
    }
      , f = zz(null)
      , d = Oz(m=>{
        f.current = m
    }
    , [f])
      , h = RT(()=>t ?? {
        storeID: eP(),
        getState: ()=>r.current,
        replaceState: l,
        getGraph: s,
        subscribeToTransactions: o,
        addTransactionMetadata: a
    });
    t != null && (h.current = t),
    r = RT(()=>n != null ? Wz(h.current, n) : e != null ? Xz(e) : J2());
    const p = Fz(()=>uy == null ? void 0 : uy(r, ()=>r.current.currentTree.version), [r]);
    return fx(()=>{
        const m = h.current;
        for (const y of new Set(m.getState().knownAtoms))
            Pz(m, y, "get");
        return ()=>{
            for (const y of m.getState().knownAtoms)
                Cz(m, y)
        }
    }
    , [h]),
    Wt.createElement(sP.Provider, {
        value: h
    }, Wt.createElement(oP.Provider, {
        value: p
    }, Wt.createElement(Gz, {
        setNotifyBatcherOfChange: d
    }), i))
}
function jz(n) {
    const {override: e, ...t} = n
      , i = Jg();
    return e === !1 && i.current !== rP ? n.children : Wt.createElement($z, t)
}
function Yz() {
    return Jg().current.storeID
}
var ro = {
    RecoilRoot: jz,
    useStoreRef: Jg,
    useRecoilMutableSource: Vz,
    useRecoilStoreID: Yz,
    notifyComponents_FOR_TESTING: w1,
    sendEndOfBatchNotifications_FOR_TESTING: aP
};
function qz(n, e) {
    if (n === e)
        return !0;
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
var Kz = qz;
const {useEffect: Zz, useRef: Qz} = Wt;
function Jz(n) {
    const e = Qz();
    return Zz(()=>{
        e.current = n
    }
    ),
    e.current
}
var lP = Jz;
const {useStoreRef: eB} = ro
  , {SUSPENSE_TIMEOUT_MS: tB} = fl
  , {updateRetainCount: Xu} = fl
  , {RetentionZone: nB} = $g
  , {useEffect: iB, useRef: rB} = Wt
  , {isSSR: PT} = qg;
function sB(n) {
    if (Zt("recoil_memory_managament_2020"))
        return oB(n)
}
function oB(n) {
    const t = (Array.isArray(n) ? n : [n]).map(o=>o instanceof nB ? o : o.key)
      , i = eB();
    iB(()=>{
        if (!Zt("recoil_memory_managament_2020"))
            return;
        const o = i.current;
        if (r.current && !PT)
            window.clearTimeout(r.current),
            r.current = null;
        else
            for (const a of t)
                Xu(o, a, 1);
        return ()=>{
            for (const a of t)
                Xu(o, a, -1)
        }
    }
    , [i, ...t]);
    const r = rB()
      , s = lP(t);
    if (!PT && (s === void 0 || !Kz(s, t))) {
        const o = i.current;
        for (const a of t)
            Xu(o, a, 1);
        if (s)
            for (const a of s)
                Xu(o, a, -1);
        r.current && window.clearTimeout(r.current),
        r.current = window.setTimeout(()=>{
            r.current = null;
            for (const a of t)
                Xu(o, a, -1)
        }
        , tB)
    }
}
var M1 = sB;
function aB() {
    return "<component name not available>"
}
var Md = aB;
const {batchUpdates: lB} = Yg
  , {DEFAULT_VALUE: cP} = Fi
  , {currentRendererSupportsUseSyncExternalStore: cB, reactMode: au, useMutableSource: uB, useSyncExternalStore: fB} = xd
  , {useRecoilMutableSource: dB, useStoreRef: As} = ro
  , {AbstractRecoilValue: hx, getRecoilValueAsLoadable: Ed, setRecoilValue: Km, setUnvalidatedRecoilValue: hB, subscribeToRecoilValue: Xc} = Ts
  , {useCallback: Oi, useEffect: $c, useMemo: uP, useRef: bf, useState: E1} = Wt
  , {setByAddingToSet: pB} = L2
  , {isSSR: mB} = qg;
function T1(n, e, t) {
    if (n.state === "hasValue")
        return n.contents;
    throw n.state === "loading" ? new Promise(r=>{
        const s = t.current.getState().suspendedComponentResolvers;
        s.add(r),
        mB && rn(n.contents) && n.contents.finally(()=>{
            s.delete(r)
        }
        )
    }
    ) : n.state === "hasError" ? n.contents : St(`Invalid value of loadable atom "${e.key}"`)
}
function gB() {
    const n = Md()
      , e = As()
      , [,t] = E1([])
      , i = bf(new Set);
    i.current = new Set;
    const r = bf(new Set)
      , s = bf(new Map)
      , o = Oi(l=>{
        const f = s.current.get(l);
        f && (f.release(),
        s.current.delete(l))
    }
    , [s])
      , a = Oi((l,f)=>{
        s.current.has(f) && t([])
    }
    , []);
    return $c(()=>{
        const l = e.current;
        Rf(i.current, r.current).forEach(f=>{
            if (s.current.has(f))
                return;
            const d = Xc(l, new hx(f), p=>a(p, f), n);
            s.current.set(f, d),
            l.getState().nextTree ? l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{
                a(l.getState(), f)
            }
            ) : a(l.getState(), f)
        }
        ),
        Rf(r.current, i.current).forEach(f=>{
            o(f)
        }
        ),
        r.current = i.current
    }
    ),
    $c(()=>{
        const l = s.current;
        return Rf(i.current, new Set(l.keys())).forEach(f=>{
            const d = Xc(e.current, new hx(f), h=>a(h, f), n);
            l.set(f, d)
        }
        ),
        ()=>l.forEach((f,d)=>o(d))
    }
    , [n, e, o, a]),
    uP(()=>{
        function l(y) {
            return S=>{
                Km(e.current, y, S)
            }
        }
        function f(y) {
            return ()=>Km(e.current, y, cP)
        }
        function d(y) {
            var S;
            i.current.has(y.key) || (i.current = pB(i.current, y.key));
            const M = e.current.getState();
            return Ed(e.current, y, au().early && (S = M.nextTree) !== null && S !== void 0 ? S : M.currentTree)
        }
        function h(y) {
            const S = d(y);
            return T1(S, y, e)
        }
        function p(y) {
            return [h(y), l(y)]
        }
        function m(y) {
            return [d(y), l(y)]
        }
        return {
            getRecoilValue: h,
            getRecoilValueLoadable: d,
            getRecoilState: p,
            getRecoilStateLoadable: m,
            getSetRecoilState: l,
            getResetRecoilState: f
        }
    }
    , [i, e])
}
const vB = {
    current: 0
};
function yB(n) {
    const e = As()
      , t = Md()
      , i = Oi(()=>{
        var a;
        const l = e.current
          , f = l.getState()
          , d = au().early && (a = f.nextTree) !== null && a !== void 0 ? a : f.currentTree;
        return {
            loadable: Ed(l, n, d),
            key: n.key
        }
    }
    , [e, n])
      , r = Oi(a=>{
        let l;
        return ()=>{
            var f, d;
            const h = a();
            return (f = l) !== null && f !== void 0 && f.loadable.is(h.loadable) && ((d = l) === null || d === void 0 ? void 0 : d.key) === h.key ? l : (l = h,
            h)
        }
    }
    , [])
      , s = uP(()=>r(i), [i, r])
      , o = Oi(a=>{
        const l = e.current;
        return Xc(l, n, a, t).release
    }
    , [e, n, t]);
    return fB(o, s, s).loadable
}
function _B(n) {
    const e = As()
      , t = Oi(()=>{
        var f;
        const d = e.current
          , h = d.getState()
          , p = au().early && (f = h.nextTree) !== null && f !== void 0 ? f : h.currentTree;
        return Ed(d, n, p)
    }
    , [e, n])
      , i = Oi(()=>t(), [t])
      , r = Md()
      , s = Oi((f,d)=>{
        const h = e.current;
        return Xc(h, n, ()=>{
            if (!Zt("recoil_suppress_rerender_in_callback"))
                return d();
            const m = t();
            l.current.is(m) || d(),
            l.current = m
        }
        , r).release
    }
    , [e, n, r, t])
      , o = dB();
    if (o == null)
        throw St("Recoil hooks must be used in components contained within a <RecoilRoot> component.");
    const a = uB(o, i, s)
      , l = bf(a);
    return $c(()=>{
        l.current = a
    }
    ),
    a
}
function px(n) {
    const e = As()
      , t = Md()
      , i = Oi(()=>{
        var l;
        const f = e.current
          , d = f.getState()
          , h = au().early && (l = d.nextTree) !== null && l !== void 0 ? l : d.currentTree;
        return Ed(f, n, h)
    }
    , [e, n])
      , r = Oi(()=>({
        loadable: i(),
        key: n.key
    }), [i, n.key])
      , s = Oi(l=>{
        const f = r();
        return l.loadable.is(f.loadable) && l.key === f.key ? l : f
    }
    , [r]);
    $c(()=>{
        const l = Xc(e.current, n, f=>{
            a(s)
        }
        , t);
        return a(s),
        l.release
    }
    , [t, n, e, s]);
    const [o,a] = E1(r);
    return o.key !== n.key ? r().loadable : o.loadable
}
function xB(n) {
    const e = As()
      , [,t] = E1([])
      , i = Md()
      , r = Oi(()=>{
        var a;
        const l = e.current
          , f = l.getState()
          , d = au().early && (a = f.nextTree) !== null && a !== void 0 ? a : f.currentTree;
        return Ed(l, n, d)
    }
    , [e, n])
      , s = r()
      , o = bf(s);
    return $c(()=>{
        o.current = s
    }
    ),
    $c(()=>{
        const a = e.current
          , l = a.getState()
          , f = Xc(a, n, h=>{
            var p;
            if (!Zt("recoil_suppress_rerender_in_callback"))
                return t([]);
            const m = r();
            (p = o.current) !== null && p !== void 0 && p.is(m) || t(m),
            o.current = m
        }
        , i);
        if (l.nextTree)
            a.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{
                o.current = null,
                t([])
            }
            );
        else {
            var d;
            if (!Zt("recoil_suppress_rerender_in_callback"))
                return t([]);
            const h = r();
            (d = o.current) !== null && d !== void 0 && d.is(h) || t(h),
            o.current = h
        }
        return f.release
    }
    , [i, r, n, e]),
    s
}
function A1(n) {
    return Zt("recoil_memory_managament_2020") && M1(n),
    {
        TRANSITION_SUPPORT: px,
        SYNC_EXTERNAL_STORE: cB() ? yB : px,
        MUTABLE_SOURCE: _B,
        LEGACY: xB
    }[au().mode](n)
}
function fP(n) {
    const e = As()
      , t = A1(n);
    return T1(t, n, e)
}
function e0(n) {
    const e = As();
    return Oi(t=>{
        Km(e.current, n, t)
    }
    , [e, n])
}
function SB(n) {
    const e = As();
    return Oi(()=>{
        Km(e.current, n, cP)
    }
    , [e, n])
}
function wB(n) {
    return [fP(n), e0(n)]
}
function MB(n) {
    return [A1(n), e0(n)]
}
function EB() {
    const n = As();
    return (e,t={})=>{
        lB(()=>{
            n.current.addTransactionMetadata(t),
            e.forEach((i,r)=>hB(n.current, new hx(r), i))
        }
        )
    }
}
function dP(n) {
    return Zt("recoil_memory_managament_2020") && M1(n),
    px(n)
}
function hP(n) {
    const e = As()
      , t = dP(n);
    return T1(t, n, e)
}
function TB(n) {
    return [hP(n), e0(n)]
}
var AB = {
    recoilComponentGetRecoilValueCount_FOR_TESTING: vB,
    useRecoilInterface: gB,
    useRecoilState: wB,
    useRecoilStateLoadable: MB,
    useRecoilValue: fP,
    useRecoilValueLoadable: A1,
    useResetRecoilState: SB,
    useSetRecoilState: e0,
    useSetUnvalidatedAtomValues: EB,
    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: dP,
    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: hP,
    useRecoilState_TRANSITION_SUPPORT_UNSTABLE: TB
};
function RB(n, e) {
    const t = new Map;
    for (const [i,r] of n)
        e(r, i) && t.set(i, r);
    return t
}
var CB = RB;
function bB(n, e) {
    const t = new Set;
    for (const i of n)
        e(i) && t.add(i);
    return t
}
var PB = bB;
function LB(...n) {
    const e = new Map;
    for (let t = 0; t < n.length; t++) {
        const i = n[t].keys();
        let r;
        for (; !(r = i.next()).done; )
            e.set(r.value, n[t].get(r.value))
    }
    return e
}
var IB = LB;
const {batchUpdates: NB} = Yg
  , {DEFAULT_VALUE: DB, getNode: pP, nodes: UB} = Fi
  , {useStoreRef: R1} = ro
  , {AbstractRecoilValue: kB, setRecoilValueLoadable: OB} = Ts
  , {SUSPENSE_TIMEOUT_MS: FB} = fl
  , {cloneSnapshot: Zm} = Qg
  , {useCallback: t0, useEffect: mP, useRef: LT, useState: zB} = Wt
  , {isSSR: IT} = qg;
function n0(n) {
    const e = R1();
    mP(()=>e.current.subscribeToTransactions(n).release, [n, e])
}
function NT(n) {
    const e = n.atomValues.toMap()
      , t = qm(CB(e, (i,r)=>{
        const o = pP(r).persistence_UNSTABLE;
        return o != null && o.type !== "none" && i.state === "hasValue"
    }
    ), i=>i.contents);
    return IB(n.nonvalidatedAtoms.toMap(), t)
}
function BB(n) {
    n0(t0(e=>{
        let t = e.getState().previousTree;
        const i = e.getState().currentTree;
        t || (t = e.getState().currentTree);
        const r = NT(i)
          , s = NT(t)
          , o = qm(UB, l=>{
            var f, d, h, p;
            return {
                persistence_UNSTABLE: {
                    type: (f = (d = l.persistence_UNSTABLE) === null || d === void 0 ? void 0 : d.type) !== null && f !== void 0 ? f : "none",
                    backButton: (h = (p = l.persistence_UNSTABLE) === null || p === void 0 ? void 0 : p.backButton) !== null && h !== void 0 ? h : !1
                }
            }
        }
        )
          , a = PB(i.dirtyAtoms, l=>r.has(l) || s.has(l));
        n({
            atomValues: r,
            previousAtomValues: s,
            atomInfo: o,
            modifiedAtoms: a,
            transactionMetadata: {
                ...i.transactionMetadata
            }
        })
    }
    , [n]))
}
function VB(n) {
    n0(t0(e=>{
        const t = Zm(e, "latest")
          , i = Zm(e, "previous");
        n({
            snapshot: t,
            previousSnapshot: i
        })
    }
    , [n]))
}
function HB() {
    const n = R1()
      , [e,t] = zB(()=>Zm(n.current))
      , i = lP(e)
      , r = LT()
      , s = LT();
    if (n0(t0(a=>t(Zm(a)), [])),
    mP(()=>{
        const a = e.retain();
        if (r.current && !IT) {
            var l;
            window.clearTimeout(r.current),
            r.current = null,
            (l = s.current) === null || l === void 0 || l.call(s),
            s.current = null
        }
        return ()=>{
            window.setTimeout(a, 10)
        }
    }
    , [e]),
    i !== e && !IT) {
        if (r.current) {
            var o;
            window.clearTimeout(r.current),
            r.current = null,
            (o = s.current) === null || o === void 0 || o.call(s),
            s.current = null
        }
        s.current = e.retain(),
        r.current = window.setTimeout(()=>{
            var a;
            r.current = null,
            (a = s.current) === null || a === void 0 || a.call(s),
            s.current = null
        }
        , FB)
    }
    return e
}
function gP(n, e) {
    var t;
    const i = n.getState()
      , r = (t = i.nextTree) !== null && t !== void 0 ? t : i.currentTree
      , s = e.getStore_INTERNAL().getState().currentTree;
    NB(()=>{
        const o = new Set;
        for (const f of [r.atomValues.keys(), s.atomValues.keys()])
            for (const d of f) {
                var a, l;
                ((a = r.atomValues.get(d)) === null || a === void 0 ? void 0 : a.contents) !== ((l = s.atomValues.get(d)) === null || l === void 0 ? void 0 : l.contents) && pP(d).shouldRestoreFromSnapshots && o.add(d)
            }
        o.forEach(f=>{
            OB(n, new kB(f), s.atomValues.has(f) ? cn(s.atomValues.get(f)) : DB)
        }
        ),
        n.replaceState(f=>({
            ...f,
            stateID: e.getID()
        }))
    }
    )
}
function GB() {
    const n = R1();
    return t0(e=>gP(n.current, e), [n])
}
var vP = {
    useRecoilSnapshot: HB,
    gotoSnapshot: gP,
    useGotoRecoilSnapshot: GB,
    useRecoilTransactionObserver: VB,
    useTransactionObservation_DEPRECATED: BB,
    useTransactionSubscription_DEPRECATED: n0
};
const {peekNodeInfo: WB} = ia
  , {useStoreRef: XB} = ro;
function $B() {
    const n = XB();
    return ({key: e})=>WB(n.current, n.current.getState().currentTree, e)
}
var jB = $B;
const {reactMode: YB} = xd
  , {RecoilRoot: qB, useStoreRef: KB} = ro
  , {useMemo: ZB} = Wt;
function QB() {
    YB().mode === "MUTABLE_SOURCE" && console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");
    const n = KB().current;
    return ZB(()=>{
        function e({children: t}) {
            return Wt.createElement(qB, {
                store_INTERNAL: n
            }, t)
        }
        return e
    }
    , [n])
}
var JB = QB;
const {loadableWithValue: e4} = _d
  , {initializeNode: t4} = ia
  , {DEFAULT_VALUE: n4, getNode: i4} = Fi
  , {copyTreeState: r4, getRecoilValueAsLoadable: s4, invalidateDownstreams: o4, writeLoadableToTreeState: a4} = Ts;
function DT(n) {
    return i4(n.key).nodeType === "atom"
}
class l4 {
    constructor(e, t) {
        vt(this, "_store", void 0),
        vt(this, "_treeState", void 0),
        vt(this, "_changes", void 0),
        vt(this, "get", i=>{
            if (this._changes.has(i.key))
                return this._changes.get(i.key);
            if (!DT(i))
                throw St("Reading selectors within atomicUpdate is not supported");
            const r = s4(this._store, i, this._treeState);
            if (r.state === "hasValue")
                return r.contents;
            throw r.state === "hasError" ? r.contents : St(`Expected Recoil atom ${i.key} to have a value, but it is in a loading state.`)
        }
        ),
        vt(this, "set", (i,r)=>{
            if (!DT(i))
                throw St("Setting selectors within atomicUpdate is not supported");
            if (typeof r == "function") {
                const s = this.get(i);
                this._changes.set(i.key, r(s))
            } else
                t4(this._store, i.key, "set"),
                this._changes.set(i.key, r)
        }
        ),
        vt(this, "reset", i=>{
            this.set(i, n4)
        }
        ),
        this._store = e,
        this._treeState = t,
        this._changes = new Map
    }
    newTreeState_INTERNAL() {
        if (this._changes.size === 0)
            return this._treeState;
        const e = r4(this._treeState);
        for (const [t,i] of this._changes)
            a4(e, t, e4(i));
        return o4(this._store, e),
        e
    }
}
function c4(n) {
    return e=>{
        n.replaceState(t=>{
            const i = new l4(n,t);
            return e(i),
            i.newTreeState_INTERNAL()
        }
        )
    }
}
var u4 = {
    atomicUpdater: c4
}
  , f4 = u4.atomicUpdater
  , yP = Object.freeze({
    __proto__: null,
    atomicUpdater: f4
});
function d4(n, e) {
    if (!n)
        throw new Error(e)
}
var h4 = d4
  , pf = h4;
const {atomicUpdater: p4} = yP
  , {batchUpdates: m4} = Yg
  , {DEFAULT_VALUE: g4} = Fi
  , {useStoreRef: v4} = ro
  , {refreshRecoilValue: y4, setRecoilValue: UT} = Ts
  , {cloneSnapshot: _4} = Qg
  , {gotoSnapshot: x4} = vP
  , {useCallback: S4} = Wt;
class _P {
}
const w4 = new _P;
function xP(n, e, t, i) {
    let r = w4, s;
    if (m4(()=>{
        const a = "useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";
        if (typeof e != "function")
            throw St(a);
        const l = I2({
            ...i ?? {},
            set: (d,h)=>UT(n, d, h),
            reset: d=>UT(n, d, g4),
            refresh: d=>y4(n, d),
            gotoSnapshot: d=>x4(n, d),
            transact_UNSTABLE: d=>p4(n)(d)
        }, {
            snapshot: ()=>{
                const d = _4(n);
                return s = d.retain(),
                d
            }
        })
          , f = e(l);
        if (typeof f != "function")
            throw St(a);
        r = f(...t)
    }
    ),
    r instanceof _P && pf(!1),
    rn(r))
        r = r.finally(()=>{
            var a;
            (a = s) === null || a === void 0 || a()
        }
        );
    else {
        var o;
        (o = s) === null || o === void 0 || o()
    }
    return r
}
function M4(n, e) {
    const t = v4();
    return S4((...i)=>xP(t.current, n, i), e != null ? [...e, t] : void 0)
}
var SP = {
    recoilCallback: xP,
    useRecoilCallback: M4
};
const {useStoreRef: E4} = ro
  , {refreshRecoilValue: T4} = Ts
  , {useCallback: A4} = Wt;
function R4(n) {
    const e = E4();
    return A4(()=>{
        const t = e.current;
        T4(t, n)
    }
    , [n, e])
}
var C4 = R4;
const {atomicUpdater: b4} = yP
  , {useStoreRef: P4} = ro
  , {useMemo: L4} = Wt;
function I4(n, e) {
    const t = P4();
    return L4(()=>(...i)=>{
        b4(t.current)(s=>{
            n(s)(...i)
        }
        )
    }
    , e != null ? [...e, t] : void 0)
}
var N4 = I4;
class D4 {
    constructor(e) {
        vt(this, "value", void 0),
        this.value = e
    }
}
var U4 = {
    WrappedValue: D4
}
  , k4 = U4.WrappedValue
  , wP = Object.freeze({
    __proto__: null,
    WrappedValue: k4
});
const {isFastRefreshEnabled: O4} = xd;
class kT extends Error {
}
class F4 {
    constructor(e) {
        var t, i, r;
        vt(this, "_name", void 0),
        vt(this, "_numLeafs", void 0),
        vt(this, "_root", void 0),
        vt(this, "_onHit", void 0),
        vt(this, "_onSet", void 0),
        vt(this, "_mapNodeValue", void 0),
        this._name = e == null ? void 0 : e.name,
        this._numLeafs = 0,
        this._root = null,
        this._onHit = (t = e == null ? void 0 : e.onHit) !== null && t !== void 0 ? t : ()=>{}
        ,
        this._onSet = (i = e == null ? void 0 : e.onSet) !== null && i !== void 0 ? i : ()=>{}
        ,
        this._mapNodeValue = (r = e == null ? void 0 : e.mapNodeValue) !== null && r !== void 0 ? r : s=>s
    }
    size() {
        return this._numLeafs
    }
    root() {
        return this._root
    }
    get(e, t) {
        var i;
        return (i = this.getLeafNode(e, t)) === null || i === void 0 ? void 0 : i.value
    }
    getLeafNode(e, t) {
        if (this._root == null)
            return;
        let i = this._root;
        for (; i; ) {
            if (t == null || t.onNodeVisit(i),
            i.type === "leaf")
                return this._onHit(i),
                i;
            const r = this._mapNodeValue(e(i.nodeKey));
            i = i.branches.get(r)
        }
    }
    set(e, t, i) {
        const r = ()=>{
            var s, o, a, l;
            let f, d;
            for (const [M,g] of e) {
                var h, p, m;
                const _ = this._root;
                if ((_ == null ? void 0 : _.type) === "leaf")
                    throw this.invalidCacheError();
                const w = f;
                if (f = w ? w.branches.get(d) : _,
                f = (h = f) !== null && h !== void 0 ? h : {
                    type: "branch",
                    nodeKey: M,
                    parent: w,
                    branches: new Map,
                    branchKey: d
                },
                f.type !== "branch" || f.nodeKey !== M)
                    throw this.invalidCacheError();
                w == null || w.branches.set(d, f),
                i == null || (p = i.onNodeVisit) === null || p === void 0 || p.call(i, f),
                d = this._mapNodeValue(g),
                this._root = (m = this._root) !== null && m !== void 0 ? m : f
            }
            const y = f ? (s = f) === null || s === void 0 ? void 0 : s.branches.get(d) : this._root;
            if (y != null && (y.type !== "leaf" || y.branchKey !== d))
                throw this.invalidCacheError();
            const S = {
                type: "leaf",
                value: t,
                parent: f,
                branchKey: d
            };
            (o = f) === null || o === void 0 || o.branches.set(d, S),
            this._root = (a = this._root) !== null && a !== void 0 ? a : S,
            this._numLeafs++,
            this._onSet(S),
            i == null || (l = i.onNodeVisit) === null || l === void 0 || l.call(i, S)
        }
        ;
        try {
            r()
        } catch (s) {
            if (s instanceof kT)
                this.clear(),
                r();
            else
                throw s
        }
    }
    delete(e) {
        const t = this.root();
        if (!t)
            return !1;
        if (e === t)
            return this._root = null,
            this._numLeafs = 0,
            !0;
        let i = e.parent
          , r = e.branchKey;
        for (; i; ) {
            var s;
            if (i.branches.delete(r),
            i === t)
                return i.branches.size === 0 ? (this._root = null,
                this._numLeafs = 0) : this._numLeafs--,
                !0;
            if (i.branches.size > 0)
                break;
            r = (s = i) === null || s === void 0 ? void 0 : s.branchKey,
            i = i.parent
        }
        for (; i !== t; i = i.parent)
            if (i == null)
                return !1;
        return this._numLeafs--,
        !0
    }
    clear() {
        this._numLeafs = 0,
        this._root = null
    }
    invalidCacheError() {
        const e = O4() ? "Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache." : "Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";
        throw h1(e + (this._name != null ? ` - ${this._name}` : "")),
        new kT
    }
}
var z4 = {
    TreeCache: F4
}
  , B4 = z4.TreeCache
  , MP = Object.freeze({
    __proto__: null,
    TreeCache: B4
});
class V4 {
    constructor(e) {
        var t;
        vt(this, "_maxSize", void 0),
        vt(this, "_size", void 0),
        vt(this, "_head", void 0),
        vt(this, "_tail", void 0),
        vt(this, "_map", void 0),
        vt(this, "_keyMapper", void 0),
        this._maxSize = e.maxSize,
        this._size = 0,
        this._head = null,
        this._tail = null,
        this._map = new Map,
        this._keyMapper = (t = e.mapKey) !== null && t !== void 0 ? t : i=>i
    }
    head() {
        return this._head
    }
    tail() {
        return this._tail
    }
    size() {
        return this._size
    }
    maxSize() {
        return this._maxSize
    }
    has(e) {
        return this._map.has(this._keyMapper(e))
    }
    get(e) {
        const t = this._keyMapper(e)
          , i = this._map.get(t);
        if (i)
            return this.set(e, i.value),
            i.value
    }
    set(e, t) {
        const i = this._keyMapper(e);
        this._map.get(i) && this.delete(e);
        const s = this.head()
          , o = {
            key: e,
            right: s,
            left: null,
            value: t
        };
        s ? s.left = o : this._tail = o,
        this._map.set(i, o),
        this._head = o,
        this._size++,
        this._maybeDeleteLRU()
    }
    _maybeDeleteLRU() {
        this.size() > this.maxSize() && this.deleteLru()
    }
    deleteLru() {
        const e = this.tail();
        e && this.delete(e.key)
    }
    delete(e) {
        const t = this._keyMapper(e);
        if (!this._size || !this._map.has(t))
            return;
        const i = cn(this._map.get(t))
          , r = i.right
          , s = i.left;
        r && (r.left = i.left),
        s && (s.right = i.right),
        i === this.head() && (this._head = r),
        i === this.tail() && (this._tail = s),
        this._map.delete(t),
        this._size--
    }
    clear() {
        this._size = 0,
        this._head = null,
        this._tail = null,
        this._map = new Map
    }
}
var H4 = {
    LRUCache: V4
}
  , G4 = H4.LRUCache
  , EP = Object.freeze({
    __proto__: null,
    LRUCache: G4
});
const {LRUCache: W4} = EP
  , {TreeCache: X4} = MP;
function $4({name: n, maxSize: e, mapNodeValue: t=i=>i}) {
    const i = new W4({
        maxSize: e
    })
      , r = new X4({
        name: n,
        mapNodeValue: t,
        onHit: s=>{
            i.set(s, !0)
        }
        ,
        onSet: s=>{
            const o = i.tail();
            i.set(s, !0),
            o && r.size() > e && r.delete(o.key)
        }
    });
    return r
}
var OT = $4;
function Br(n, e, t) {
    if (typeof n == "string" && !n.includes('"') && !n.includes("\\"))
        return `"${n}"`;
    switch (typeof n) {
    case "undefined":
        return "";
    case "boolean":
        return n ? "true" : "false";
    case "number":
    case "symbol":
        return String(n);
    case "string":
        return JSON.stringify(n);
    case "function":
        if ((e == null ? void 0 : e.allowFunctions) !== !0)
            throw St("Attempt to serialize function in a Recoil cache key");
        return `__FUNCTION(${n.name})__`
    }
    if (n === null)
        return "null";
    if (typeof n != "object") {
        var i;
        return (i = JSON.stringify(n)) !== null && i !== void 0 ? i : ""
    }
    if (rn(n))
        return "__PROMISE__";
    if (Array.isArray(n))
        return `[${n.map((r,s)=>Br(r, e, s.toString()))}]`;
    if (typeof n.toJSON == "function")
        return Br(n.toJSON(t), e, t);
    if (n instanceof Map) {
        const r = {};
        for (const [s,o] of n)
            r[typeof s == "string" ? s : Br(s, e)] = o;
        return Br(r, e, t)
    }
    return n instanceof Set ? Br(Array.from(n).sort((r,s)=>Br(r, e).localeCompare(Br(s, e))), e, t) : Symbol !== void 0 && n[Symbol.iterator] != null && typeof n[Symbol.iterator] == "function" ? Br(Array.from(n), e, t) : `{${Object.keys(n).filter(r=>n[r] !== void 0).sort().map(r=>`${Br(r, e)}:${Br(n[r], e, r)}`).join(",")}}`
}
function j4(n, e={
    allowFunctions: !1
}) {
    return Br(n, e)
}
var i0 = j4;
const {TreeCache: Y4} = MP
  , rp = {
    equality: "reference",
    eviction: "keep-all",
    maxSize: 1 / 0
};
function q4({equality: n=rp.equality, eviction: e=rp.eviction, maxSize: t=rp.maxSize}=rp, i) {
    const r = K4(n);
    return Z4(e, t, r, i)
}
function K4(n) {
    switch (n) {
    case "reference":
        return e=>e;
    case "value":
        return e=>i0(e)
    }
    throw St(`Unrecognized equality policy ${n}`)
}
function Z4(n, e, t, i) {
    switch (n) {
    case "keep-all":
        return new Y4({
            name: i,
            mapNodeValue: t
        });
    case "lru":
        return OT({
            name: i,
            maxSize: cn(e),
            mapNodeValue: t
        });
    case "most-recent":
        return OT({
            name: i,
            maxSize: 1,
            mapNodeValue: t
        })
    }
    throw St(`Unrecognized eviction policy ${n}`)
}
var Q4 = q4;
function J4(n) {
    return ()=>null
}
var eV = {
    startPerfBlock: J4
};
const {isLoadable: tV, loadableWithError: sp, loadableWithPromise: nV, loadableWithValue: fy} = _d
  , {WrappedValue: TP} = wP
  , {getNodeLoadable: op, peekNodeLoadable: iV, setNodeValue: rV} = ia
  , {saveDepsToStore: sV} = Sd
  , {DEFAULT_VALUE: oV, getConfigDeletionHandler: aV, getNode: lV, registerNode: FT} = Fi
  , {isRecoilValue: cV} = Wc
  , {markRecoilValueModified: zT} = Ts
  , {retainedByOptionWithDefault: uV} = fl
  , {recoilCallback: fV} = SP
  , {startPerfBlock: dV} = eV;
class AP {
}
const $u = new AP
  , ju = []
  , ap = new Map
  , hV = (()=>{
    let n = 0;
    return ()=>n++
}
)();
function RP(n) {
    let e = null;
    const {key: t, get: i, cachePolicy_UNSTABLE: r} = n
      , s = n.set != null ? n.set : void 0
      , o = new Set
      , a = Q4(r ?? {
        equality: "reference",
        eviction: "keep-all"
    }, t)
      , l = uV(n.retainedBy_UNSTABLE)
      , f = new Map;
    let d = 0;
    function h() {
        return !Zt("recoil_memory_managament_2020") || d > 0
    }
    function p(I) {
        return I.getState().knownSelectors.add(t),
        d++,
        ()=>{
            d--
        }
    }
    function m() {
        return aV(t) !== void 0 && !h()
    }
    function y(I, U, O, J, F) {
        fe(U, J, F),
        S(I, O)
    }
    function S(I, U) {
        Q(I, U) && $(I),
        g(U, !0)
    }
    function M(I, U) {
        Q(I, U) && (cn(L(I)).stateVersions.clear(),
        g(U, !1))
    }
    function g(I, U) {
        const O = ap.get(I);
        if (O != null) {
            for (const J of O)
                zT(J, cn(e));
            U && ap.delete(I)
        }
    }
    function _(I, U) {
        let O = ap.get(U);
        O == null && ap.set(U, O = new Set),
        O.add(I)
    }
    function w(I, U, O, J, F, B) {
        return U.then(ae=>{
            if (!h())
                throw $(I),
                $u;
            const _e = fy(ae);
            return y(I, O, F, _e, J),
            ae
        }
        ).catch(ae=>{
            if (!h())
                throw $(I),
                $u;
            if (rn(ae))
                return T(I, ae, O, J, F, B);
            const _e = sp(ae);
            throw y(I, O, F, _e, J),
            ae
        }
        )
    }
    function T(I, U, O, J, F, B) {
        return U.then(ae=>{
            if (!h())
                throw $(I),
                $u;
            B.loadingDepKey != null && B.loadingDepPromise === U ? O.atomValues.set(B.loadingDepKey, fy(ae)) : I.getState().knownSelectors.forEach(se=>{
                O.atomValues.delete(se)
            }
            );
            const _e = P(I, O);
            if (_e && _e.state !== "loading") {
                if ((Q(I, F) || L(I) == null) && S(I, F),
                _e.state === "hasValue")
                    return _e.contents;
                throw _e.contents
            }
            if (!Q(I, F)) {
                const se = b(I, O);
                if (se != null)
                    return se.loadingLoadable.contents
            }
            const [pe,Ee] = C(I, O, F);
            if (pe.state !== "loading" && y(I, O, F, pe, Ee),
            pe.state === "hasError")
                throw pe.contents;
            return pe.contents
        }
        ).catch(ae=>{
            if (ae instanceof AP)
                throw $u;
            if (!h())
                throw $(I),
                $u;
            const _e = sp(ae);
            throw y(I, O, F, _e, J),
            ae
        }
        )
    }
    function A(I, U, O, J) {
        var F, B, ae, _e;
        if (Q(I, J) || U.version === ((F = I.getState()) === null || F === void 0 || (B = F.currentTree) === null || B === void 0 ? void 0 : B.version) || U.version === ((ae = I.getState()) === null || ae === void 0 || (_e = ae.nextTree) === null || _e === void 0 ? void 0 : _e.version)) {
            var pe, Ee, se;
            sV(t, O, I, (pe = (Ee = I.getState()) === null || Ee === void 0 || (se = Ee.nextTree) === null || se === void 0 ? void 0 : se.version) !== null && pe !== void 0 ? pe : I.getState().currentTree.version)
        }
        for (const oe of O)
            o.add(oe)
    }
    function C(I, U, O) {
        const J = dV(t);
        let F = !0
          , B = !0;
        const ae = ()=>{
            J(),
            B = !1
        }
        ;
        let _e, pe = !1, Ee;
        const se = {
            loadingDepKey: null,
            loadingDepPromise: null
        }
          , oe = new Map;
        function ve({key: Re}) {
            const Le = op(I, U, Re);
            switch (oe.set(Re, Le),
            F || (A(I, U, new Set(oe.keys()), O),
            M(I, O)),
            Le.state) {
            case "hasValue":
                return Le.contents;
            case "hasError":
                throw Le.contents;
            case "loading":
                throw se.loadingDepKey = Re,
                se.loadingDepPromise = Le.contents,
                Le.contents
            }
            throw St("Invalid Loadable state")
        }
        const Ce = Re=>(...Le)=>{
            if (B)
                throw St("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");
            return e == null && pf(!1),
            fV(I, Re, Le, {
                node: e
            })
        }
        ;
        try {
            _e = i({
                get: ve,
                getCallback: Ce
            }),
            _e = cV(_e) ? ve(_e) : _e,
            tV(_e) && (_e.state === "hasError" && (pe = !0),
            _e = _e.contents),
            rn(_e) ? _e = w(I, _e, U, oe, O, se).finally(ae) : ae(),
            _e = _e instanceof TP ? _e.value : _e
        } catch (Re) {
            _e = Re,
            rn(_e) ? _e = T(I, _e, U, oe, O, se).finally(ae) : (pe = !0,
            ae())
        }
        return pe ? Ee = sp(_e) : rn(_e) ? Ee = nV(_e) : Ee = fy(_e),
        F = !1,
        Z(I, O, oe),
        A(I, U, new Set(oe.keys()), O),
        [Ee, oe]
    }
    function P(I, U) {
        let O = U.atomValues.get(t);
        if (O != null)
            return O;
        const J = new Set;
        try {
            O = a.get(B=>(typeof B != "string" && pf(!1),
            op(I, U, B).contents), {
                onNodeVisit: B=>{
                    B.type === "branch" && B.nodeKey !== t && J.add(B.nodeKey)
                }
            })
        } catch (B) {
            throw St(`Problem with cache lookup for selector "${t}": ${B.message}`)
        }
        if (O) {
            var F;
            U.atomValues.set(t, O),
            A(I, U, J, (F = L(I)) === null || F === void 0 ? void 0 : F.executionID)
        }
        return O
    }
    function N(I, U) {
        const O = P(I, U);
        if (O != null)
            return $(I),
            O;
        const J = b(I, U);
        if (J != null) {
            var F;
            return ((F = J.loadingLoadable) === null || F === void 0 ? void 0 : F.state) === "loading" && _(I, J.executionID),
            J.loadingLoadable
        }
        const B = hV()
          , [ae,_e] = C(I, U, B);
        return ae.state === "loading" ? (Y(I, B, ae, _e, U),
        _(I, B)) : ($(I),
        fe(U, ae, _e)),
        ae
    }
    function b(I, U) {
        const O = q2([f.has(I) ? [cn(f.get(I))] : [], Wg(y1(f, ([F])=>F !== I), ([,F])=>F)]);
        function J(F) {
            for (const [B,ae] of F)
                if (!op(I, U, B).is(ae))
                    return !0;
            return !1
        }
        for (const F of O) {
            if (F.stateVersions.get(U.version) || !J(F.depValuesDiscoveredSoFarDuringAsyncWork))
                return F.stateVersions.set(U.version, !0),
                F;
            F.stateVersions.set(U.version, !1)
        }
    }
    function L(I) {
        return f.get(I)
    }
    function Y(I, U, O, J, F) {
        f.set(I, {
            depValuesDiscoveredSoFarDuringAsyncWork: J,
            executionID: U,
            loadingLoadable: O,
            stateVersions: new Map([[F.version, !0]])
        })
    }
    function Z(I, U, O) {
        if (Q(I, U)) {
            const J = L(I);
            J != null && (J.depValuesDiscoveredSoFarDuringAsyncWork = O)
        }
    }
    function $(I) {
        f.delete(I)
    }
    function Q(I, U) {
        var O;
        return U === ((O = L(I)) === null || O === void 0 ? void 0 : O.executionID)
    }
    function ie(I) {
        return Array.from(I.entries()).map(([U,O])=>[U, O.contents])
    }
    function fe(I, U, O) {
        I.atomValues.set(t, U);
        try {
            a.set(ie(O), U)
        } catch (J) {
            throw St(`Problem with setting cache for selector "${t}": ${J.message}`)
        }
    }
    function le(I) {
        if (ju.includes(t)) {
            const U = `Recoil selector has circular dependencies: ${ju.slice(ju.indexOf(t)).join(" → ")}`;
            return sp(St(U))
        }
        ju.push(t);
        try {
            return I()
        } finally {
            ju.pop()
        }
    }
    function D(I, U) {
        const O = U.atomValues.get(t);
        return O ?? a.get(J=>{
            var F;
            return typeof J != "string" && pf(!1),
            (F = iV(I, U, J)) === null || F === void 0 ? void 0 : F.contents
        }
        )
    }
    function j(I, U) {
        return le(()=>N(I, U))
    }
    function X(I) {
        I.atomValues.delete(t)
    }
    function ue(I, U) {
        e == null && pf(!1);
        for (const J of o) {
            var O;
            const F = lV(J);
            (O = F.clearCache) === null || O === void 0 || O.call(F, I, U)
        }
        o.clear(),
        X(U),
        a.clear(),
        zT(I, e)
    }
    return s != null ? e = FT({
        key: t,
        nodeType: "selector",
        peek: D,
        get: j,
        set: (U,O,J)=>{
            let F = !1;
            const B = new Map;
            function ae({key: se}) {
                if (F)
                    throw St("Recoil: Async selector sets are not currently supported.");
                const oe = op(U, O, se);
                if (oe.state === "hasValue")
                    return oe.contents;
                if (oe.state === "loading") {
                    const ve = `Getting value of asynchronous atom or selector "${se}" in a pending state while setting selector "${t}" is not yet supported.`;
                    throw St(ve)
                } else
                    throw oe.contents
            }
            function _e(se, oe) {
                if (F)
                    throw St("Recoil: Async selector sets are not currently supported.");
                const ve = typeof oe == "function" ? oe(ae(se)) : oe;
                rV(U, O, se.key, ve).forEach((Re,Le)=>B.set(Le, Re))
            }
            function pe(se) {
                _e(se, oV)
            }
            const Ee = s({
                set: _e,
                get: ae,
                reset: pe
            }, J);
            if (Ee !== void 0)
                throw rn(Ee) ? St("Recoil: Async selector sets are not currently supported.") : St("Recoil: selector set should be a void function.");
            return F = !0,
            B
        }
        ,
        init: p,
        invalidate: X,
        clearCache: ue,
        shouldDeleteConfigOnRelease: m,
        dangerouslyAllowMutability: n.dangerouslyAllowMutability,
        shouldRestoreFromSnapshots: !1,
        retainedBy: l
    }) : e = FT({
        key: t,
        nodeType: "selector",
        peek: D,
        get: j,
        init: p,
        invalidate: X,
        clearCache: ue,
        shouldDeleteConfigOnRelease: m,
        dangerouslyAllowMutability: n.dangerouslyAllowMutability,
        shouldRestoreFromSnapshots: !1,
        retainedBy: l
    })
}
RP.value = n=>new TP(n);
var jc = RP;
const {isLoadable: pV, loadableWithError: dy, loadableWithPromise: hy, loadableWithValue: Ll} = _d
  , {WrappedValue: CP} = wP
  , {peekNodeInfo: mV} = ia
  , {DEFAULT_VALUE: ba, DefaultValue: Co, getConfigDeletionHandler: bP, registerNode: gV, setConfigDeletionHandler: vV} = Fi
  , {isRecoilValue: yV} = Wc
  , {getRecoilValueAsLoadable: _V, markRecoilValueModified: xV, setRecoilValue: BT, setRecoilValueLoadable: SV} = Ts
  , {retainedByOptionWithDefault: wV} = fl
  , Yu = n=>n instanceof CP ? n.value : n;
function MV(n) {
    const {key: e, persistence_UNSTABLE: t} = n
      , i = wV(n.retainedBy_UNSTABLE);
    let r = 0;
    function s(_) {
        return hy(_.then(w=>(o = Ll(w),
        w)).catch(w=>{
            throw o = dy(w),
            w
        }
        ))
    }
    let o = rn(n.default) ? s(n.default) : pV(n.default) ? n.default.state === "loading" ? s(n.default.contents) : n.default : Ll(Yu(n.default));
    o.contents;
    let a;
    const l = new Map;
    function f(_) {
        return _
    }
    function d(_, w) {
        const T = w.then(A=>{
            var C, P;
            return ((P = ((C = _.getState().nextTree) !== null && C !== void 0 ? C : _.getState().currentTree).atomValues.get(e)) === null || P === void 0 ? void 0 : P.contents) === T && BT(_, g, A),
            A
        }
        ).catch(A=>{
            var C, P;
            throw ((P = ((C = _.getState().nextTree) !== null && C !== void 0 ? C : _.getState().currentTree).atomValues.get(e)) === null || P === void 0 ? void 0 : P.contents) === T && SV(_, g, dy(A)),
            A
        }
        );
        return T
    }
    function h(_, w, T) {
        var A;
        r++;
        const C = ()=>{
            var $;
            r--,
            ($ = l.get(_)) === null || $ === void 0 || $.forEach(Q=>Q()),
            l.delete(_)
        }
        ;
        if (_.getState().knownAtoms.add(e),
        o.state === "loading") {
            const $ = ()=>{
                var Q;
                ((Q = _.getState().nextTree) !== null && Q !== void 0 ? Q : _.getState().currentTree).atomValues.has(e) || xV(_, g)
            }
            ;
            o.contents.finally($)
        }
        const P = (A = n.effects) !== null && A !== void 0 ? A : n.effects_UNSTABLE;
        if (P != null) {
            let le = function(U) {
                if (Q && U.key === e) {
                    const O = $;
                    return O instanceof Co ? p(_, w) : rn(O) ? hy(O.then(J=>J instanceof Co ? o.toPromise() : J)) : Ll(O)
                }
                return _V(_, U)
            }
              , D = function(U) {
                return le(U).toPromise()
            }
              , j = function(U) {
                var O;
                const J = mV(_, (O = _.getState().nextTree) !== null && O !== void 0 ? O : _.getState().currentTree, U.key);
                return Q && U.key === e && !($ instanceof Co) ? {
                    ...J,
                    isSet: !0,
                    loadable: le(U)
                } : J
            };
            var L = le
              , Y = D
              , Z = j;
            let $ = ba
              , Q = !0
              , ie = !1
              , fe = null;
            const X = U=>O=>{
                if (Q) {
                    const J = le(g)
                      , F = J.state === "hasValue" ? J.contents : ba;
                    $ = typeof O == "function" ? O(F) : O,
                    rn($) && ($ = $.then(B=>(fe = {
                        effect: U,
                        value: B
                    },
                    B)))
                } else {
                    if (rn(O))
                        throw St("Setting atoms to async values is not implemented.");
                    typeof O != "function" && (fe = {
                        effect: U,
                        value: Yu(O)
                    }),
                    BT(_, g, typeof O == "function" ? J=>{
                        const F = Yu(O(J));
                        return fe = {
                            effect: U,
                            value: F
                        },
                        F
                    }
                    : Yu(O))
                }
            }
              , ue = U=>()=>X(U)(ba)
              , I = U=>O=>{
                var J;
                const {release: F} = _.subscribeToTransactions(B=>{
                    var ae;
                    let {currentTree: _e, previousTree: pe} = B.getState();
                    pe || (pe = _e);
                    const Ee = (ae = _e.atomValues.get(e)) !== null && ae !== void 0 ? ae : o;
                    if (Ee.state === "hasValue") {
                        var se, oe, ve, Ce;
                        const Re = Ee.contents
                          , Le = (se = pe.atomValues.get(e)) !== null && se !== void 0 ? se : o
                          , Be = Le.state === "hasValue" ? Le.contents : ba;
                        ((oe = fe) === null || oe === void 0 ? void 0 : oe.effect) !== U || ((ve = fe) === null || ve === void 0 ? void 0 : ve.value) !== Re ? O(Re, Be, !_e.atomValues.has(e)) : ((Ce = fe) === null || Ce === void 0 ? void 0 : Ce.effect) === U && (fe = null)
                    }
                }
                , e);
                l.set(_, [...(J = l.get(_)) !== null && J !== void 0 ? J : [], F])
            }
            ;
            for (const U of P)
                try {
                    const O = U({
                        node: g,
                        storeID: _.storeID,
                        parentStoreID_UNSTABLE: _.parentStoreID,
                        trigger: T,
                        setSelf: X(U),
                        resetSelf: ue(U),
                        onSet: I(U),
                        getPromise: D,
                        getLoadable: le,
                        getInfo_UNSTABLE: j
                    });
                    if (O != null) {
                        var N;
                        l.set(_, [...(N = l.get(_)) !== null && N !== void 0 ? N : [], O])
                    }
                } catch (O) {
                    $ = O,
                    ie = !0
                }
            if (Q = !1,
            !($ instanceof Co)) {
                var b;
                const U = ie ? dy($) : rn($) ? hy(d(_, $)) : Ll(Yu($));
                U.contents,
                w.atomValues.set(e, U),
                (b = _.getState().nextTree) === null || b === void 0 || b.atomValues.set(e, U)
            }
        }
        return C
    }
    function p(_, w) {
        var T, A;
        return (T = (A = w.atomValues.get(e)) !== null && A !== void 0 ? A : a) !== null && T !== void 0 ? T : o
    }
    function m(_, w) {
        if (w.atomValues.has(e))
            return cn(w.atomValues.get(e));
        if (w.nonvalidatedAtoms.has(e)) {
            if (a != null)
                return a;
            if (t == null)
                return o;
            const T = w.nonvalidatedAtoms.get(e)
              , A = t.validator(T, ba);
            return a = A instanceof Co ? o : Ll(A),
            a
        } else
            return o
    }
    function y() {
        a = void 0
    }
    function S(_, w, T) {
        if (w.atomValues.has(e)) {
            const A = cn(w.atomValues.get(e));
            if (A.state === "hasValue" && T === A.contents)
                return new Map
        } else if (!w.nonvalidatedAtoms.has(e) && T instanceof Co)
            return new Map;
        return a = void 0,
        new Map().set(e, Ll(T))
    }
    function M() {
        return bP(e) !== void 0 && r <= 0
    }
    const g = gV({
        key: e,
        nodeType: "atom",
        peek: p,
        get: m,
        set: S,
        init: h,
        invalidate: y,
        shouldDeleteConfigOnRelease: M,
        dangerouslyAllowMutability: n.dangerouslyAllowMutability,
        persistence_UNSTABLE: n.persistence_UNSTABLE ? {
            type: n.persistence_UNSTABLE.type,
            backButton: n.persistence_UNSTABLE.backButton
        } : void 0,
        shouldRestoreFromSnapshots: !0,
        retainedBy: i
    });
    return g
}
function C1(n) {
    const {...e} = n
      , t = "default"in n ? n.default : new Promise(()=>{}
    );
    return yV(t) ? EV({
        ...e,
        default: t
    }) : MV({
        ...e,
        default: t
    })
}
function EV(n) {
    const e = C1({
        ...n,
        default: ba,
        persistence_UNSTABLE: n.persistence_UNSTABLE === void 0 ? void 0 : {
            ...n.persistence_UNSTABLE,
            validator: i=>i instanceof Co ? i : cn(n.persistence_UNSTABLE).validator(i, ba)
        },
        effects: n.effects,
        effects_UNSTABLE: n.effects_UNSTABLE
    })
      , t = jc({
        key: `${n.key}__withFallback`,
        get: ({get: i})=>{
            const r = i(e);
            return r instanceof Co ? n.default : r
        }
        ,
        set: ({set: i},r)=>i(e, r),
        cachePolicy_UNSTABLE: {
            eviction: "most-recent"
        },
        dangerouslyAllowMutability: n.dangerouslyAllowMutability
    });
    return vV(t.key, bP(n.key)),
    t
}
C1.value = n=>new CP(n);
var PP = C1;
class TV {
    constructor(e) {
        var t;
        vt(this, "_map", void 0),
        vt(this, "_keyMapper", void 0),
        this._map = new Map,
        this._keyMapper = (t = e == null ? void 0 : e.mapKey) !== null && t !== void 0 ? t : i=>i
    }
    size() {
        return this._map.size
    }
    has(e) {
        return this._map.has(this._keyMapper(e))
    }
    get(e) {
        return this._map.get(this._keyMapper(e))
    }
    set(e, t) {
        this._map.set(this._keyMapper(e), t)
    }
    delete(e) {
        this._map.delete(this._keyMapper(e))
    }
    clear() {
        this._map.clear()
    }
}
var AV = {
    MapCache: TV
}
  , RV = AV.MapCache
  , CV = Object.freeze({
    __proto__: null,
    MapCache: RV
});
const {LRUCache: VT} = EP
  , {MapCache: bV} = CV
  , lp = {
    equality: "reference",
    eviction: "none",
    maxSize: 1 / 0
};
function PV({equality: n=lp.equality, eviction: e=lp.eviction, maxSize: t=lp.maxSize}=lp) {
    const i = LV(n);
    return IV(e, t, i)
}
function LV(n) {
    switch (n) {
    case "reference":
        return e=>e;
    case "value":
        return e=>i0(e)
    }
    throw St(`Unrecognized equality policy ${n}`)
}
function IV(n, e, t) {
    switch (n) {
    case "keep-all":
        return new bV({
            mapKey: t
        });
    case "lru":
        return new VT({
            mapKey: t,
            maxSize: cn(e)
        });
    case "most-recent":
        return new VT({
            mapKey: t,
            maxSize: 1
        })
    }
    throw St(`Unrecognized eviction policy ${n}`)
}
var LP = PV;
const {setConfigDeletionHandler: NV} = Fi;
function DV(n) {
    var e, t;
    const i = LP({
        equality: (e = (t = n.cachePolicyForParams_UNSTABLE) === null || t === void 0 ? void 0 : t.equality) !== null && e !== void 0 ? e : "value",
        eviction: "keep-all"
    });
    return r=>{
        var s, o;
        const a = i.get(r);
        if (a != null)
            return a;
        const {cachePolicyForParams_UNSTABLE: l, ...f} = n
          , d = "default"in n ? n.default : new Promise(()=>{}
        )
          , h = PP({
            ...f,
            key: `${n.key}__ ${(s = i0(r)) !== null && s !== void 0 ? s : "void"}`,
            default: typeof d == "function" ? d(r) : d,
            retainedBy_UNSTABLE: typeof n.retainedBy_UNSTABLE == "function" ? n.retainedBy_UNSTABLE(r) : n.retainedBy_UNSTABLE,
            effects: typeof n.effects == "function" ? n.effects(r) : typeof n.effects_UNSTABLE == "function" ? n.effects_UNSTABLE(r) : (o = n.effects) !== null && o !== void 0 ? o : n.effects_UNSTABLE
        });
        return i.set(r, h),
        NV(h.key, ()=>{
            i.delete(r)
        }
        ),
        h
    }
}
var UV = DV;
const {setConfigDeletionHandler: kV} = Fi;
let OV = 0;
function FV(n) {
    var e, t;
    const i = LP({
        equality: (e = (t = n.cachePolicyForParams_UNSTABLE) === null || t === void 0 ? void 0 : t.equality) !== null && e !== void 0 ? e : "value",
        eviction: "keep-all"
    });
    return r=>{
        var s;
        let o;
        try {
            o = i.get(r)
        } catch (p) {
            throw St(`Problem with cache lookup for selector ${n.key}: ${p.message}`)
        }
        if (o != null)
            return o;
        const a = `${n.key}__selectorFamily/${(s = i0(r, {
            allowFunctions: !0
        })) !== null && s !== void 0 ? s : "void"}/${OV++}`
          , l = p=>n.get(r)(p)
          , f = n.cachePolicy_UNSTABLE
          , d = typeof n.retainedBy_UNSTABLE == "function" ? n.retainedBy_UNSTABLE(r) : n.retainedBy_UNSTABLE;
        let h;
        if (n.set != null) {
            const p = n.set;
            h = jc({
                key: a,
                get: l,
                set: (y,S)=>p(r)(y, S),
                cachePolicy_UNSTABLE: f,
                dangerouslyAllowMutability: n.dangerouslyAllowMutability,
                retainedBy_UNSTABLE: d
            })
        } else
            h = jc({
                key: a,
                get: l,
                cachePolicy_UNSTABLE: f,
                dangerouslyAllowMutability: n.dangerouslyAllowMutability,
                retainedBy_UNSTABLE: d
            });
        return i.set(r, h),
        kV(h.key, ()=>{
            i.delete(r)
        }
        ),
        h
    }
}
var ra = FV;
const zV = ra({
    key: "__constant",
    get: n=>()=>n,
    cachePolicyForParams_UNSTABLE: {
        equality: "reference"
    }
});
function BV(n) {
    return zV(n)
}
var VV = BV;
const HV = ra({
    key: "__error",
    get: n=>()=>{
        throw St(n)
    }
    ,
    cachePolicyForParams_UNSTABLE: {
        equality: "reference"
    }
});
function GV(n) {
    return HV(n)
}
var WV = GV;
function XV(n) {
    return n
}
var $V = XV;
const {loadableWithError: IP, loadableWithPromise: NP, loadableWithValue: DP} = _d;
function r0(n, e) {
    const t = Array(e.length).fill(void 0)
      , i = Array(e.length).fill(void 0);
    for (const [r,s] of e.entries())
        try {
            t[r] = n(s)
        } catch (o) {
            i[r] = o
        }
    return [t, i]
}
function jV(n) {
    return n != null && !rn(n)
}
function s0(n) {
    return Array.isArray(n) ? n : Object.getOwnPropertyNames(n).map(e=>n[e])
}
function mx(n, e) {
    return Array.isArray(n) ? e : Object.getOwnPropertyNames(n).reduce((t,i,r)=>({
        ...t,
        [i]: e[r]
    }), {})
}
function Cc(n, e, t) {
    const i = t.map((r,s)=>r == null ? DP(e[s]) : rn(r) ? NP(r) : IP(r));
    return mx(n, i)
}
function YV(n, e) {
    return e.map((t,i)=>t === void 0 ? n[i] : t)
}
const qV = ra({
    key: "__waitForNone",
    get: n=>({get: e})=>{
        const t = s0(n)
          , [i,r] = r0(e, t);
        return Cc(n, i, r)
    }
    ,
    dangerouslyAllowMutability: !0
})
  , KV = ra({
    key: "__waitForAny",
    get: n=>({get: e})=>{
        const t = s0(n)
          , [i,r] = r0(e, t);
        return r.some(s=>!rn(s)) ? Cc(n, i, r) : new Promise(s=>{
            for (const [o,a] of r.entries())
                rn(a) && a.then(l=>{
                    i[o] = l,
                    r[o] = void 0,
                    s(Cc(n, i, r))
                }
                ).catch(l=>{
                    r[o] = l,
                    s(Cc(n, i, r))
                }
                )
        }
        )
    }
    ,
    dangerouslyAllowMutability: !0
})
  , ZV = ra({
    key: "__waitForAll",
    get: n=>({get: e})=>{
        const t = s0(n)
          , [i,r] = r0(e, t);
        if (r.every(o=>o == null))
            return mx(n, i);
        const s = r.find(jV);
        if (s != null)
            throw s;
        return Promise.all(r).then(o=>mx(n, YV(i, o)))
    }
    ,
    dangerouslyAllowMutability: !0
})
  , QV = ra({
    key: "__waitForAllSettled",
    get: n=>({get: e})=>{
        const t = s0(n)
          , [i,r] = r0(e, t);
        return r.every(s=>!rn(s)) ? Cc(n, i, r) : Promise.all(r.map((s,o)=>rn(s) ? s.then(a=>{
            i[o] = a,
            r[o] = void 0
        }
        ).catch(a=>{
            i[o] = void 0,
            r[o] = a
        }
        ) : null)).then(()=>Cc(n, i, r))
    }
    ,
    dangerouslyAllowMutability: !0
})
  , JV = ra({
    key: "__noWait",
    get: n=>({get: e})=>{
        try {
            return jc.value(DP(e(n)))
        } catch (t) {
            return jc.value(rn(t) ? NP(t) : IP(t))
        }
    }
    ,
    dangerouslyAllowMutability: !0
});
var eH = {
    waitForNone: qV,
    waitForAny: KV,
    waitForAll: ZV,
    waitForAllSettled: QV,
    noWait: JV
};
const {RecoilLoadable: tH} = _d
  , {DefaultValue: nH} = Fi
  , {RecoilRoot: iH, useRecoilStoreID: rH} = ro
  , {isRecoilValue: sH} = Wc
  , {retentionZone: oH} = $g
  , {freshSnapshot: aH} = Qg
  , {useRecoilState: lH, useRecoilState_TRANSITION_SUPPORT_UNSTABLE: cH, useRecoilStateLoadable: uH, useRecoilValue: fH, useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: dH, useRecoilValueLoadable: hH, useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: pH, useResetRecoilState: mH, useSetRecoilState: gH} = AB
  , {useGotoRecoilSnapshot: vH, useRecoilSnapshot: yH, useRecoilTransactionObserver: _H} = vP
  , {useRecoilCallback: xH} = SP
  , {noWait: SH, waitForAll: wH, waitForAllSettled: MH, waitForAny: EH, waitForNone: TH} = eH;
var o0 = {
    DefaultValue: nH,
    isRecoilValue: sH,
    RecoilLoadable: tH,
    RecoilEnv: ou,
    RecoilRoot: iH,
    useRecoilStoreID: rH,
    useRecoilBridgeAcrossReactRoots_UNSTABLE: JB,
    atom: PP,
    selector: jc,
    atomFamily: UV,
    selectorFamily: ra,
    constSelector: VV,
    errorSelector: WV,
    readOnlySelector: $V,
    noWait: SH,
    waitForNone: TH,
    waitForAny: EH,
    waitForAll: wH,
    waitForAllSettled: MH,
    useRecoilValue: fH,
    useRecoilValueLoadable: hH,
    useRecoilState: lH,
    useRecoilStateLoadable: uH,
    useSetRecoilState: gH,
    useResetRecoilState: mH,
    useGetRecoilValueInfo_UNSTABLE: jB,
    useRecoilRefresher_UNSTABLE: C4,
    useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: pH,
    useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: dH,
    useRecoilState_TRANSITION_SUPPORT_UNSTABLE: cH,
    useRecoilCallback: xH,
    useRecoilTransaction_UNSTABLE: N4,
    useGotoRecoilSnapshot: vH,
    useRecoilSnapshot: yH,
    useRecoilTransactionObserver_UNSTABLE: _H,
    snapshot_UNSTABLE: aH,
    useRetain: M1,
    retentionZone: oH
}
  , AH = o0.RecoilRoot
  , UP = o0.atom
  , RH = o0.useRecoilValue
  , gx = o0.useRecoilState
  , b1 = (n=>(n[n.ORTHOGONAL = 0] = "ORTHOGONAL",
n[n.PERSPECTIVE = 1] = "PERSPECTIVE",
n))(b1 || {});
const kP = UP({
    key: "canvasMode",
    default: b1.ORTHOGONAL
})
  , OP = UP({
    key: "dialogStartTrigger",
    default: 0
});
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const a0 = "152"
  , CH = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , bH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , FP = 0
  , vx = 1
  , zP = 2
  , PH = 3
  , BP = 0
  , l0 = 1
  , bc = 2
  , Hr = 3
  , Zr = 0
  , hi = 1
  , $r = 2
  , LH = 2
  , Ks = 0
  , Va = 1
  , yx = 2
  , _x = 3
  , xx = 4
  , VP = 5
  , Pa = 100
  , HP = 101
  , GP = 102
  , Sx = 103
  , wx = 104
  , WP = 200
  , XP = 201
  , $P = 202
  , jP = 203
  , P1 = 204
  , L1 = 205
  , YP = 206
  , qP = 207
  , KP = 208
  , ZP = 209
  , QP = 210
  , JP = 0
  , eL = 1
  , tL = 2
  , Qm = 3
  , nL = 4
  , iL = 5
  , rL = 6
  , sL = 7
  , Td = 0
  , oL = 1
  , aL = 2
  , qr = 0
  , lL = 1
  , cL = 2
  , uL = 3
  , I1 = 4
  , fL = 5
  , c0 = 300
  , Zo = 301
  , Qo = 302
  , Yc = 303
  , ed = 304
  , lu = 306
  , Yn = 1e3
  , On = 1001
  , qc = 1002
  , _n = 1003
  , td = 1004
  , IH = 1004
  , Pc = 1005
  , NH = 1005
  , dn = 1006
  , u0 = 1007
  , DH = 1007
  , ws = 1008
  , UH = 1008
  , to = 1009
  , dL = 1010
  , hL = 1011
  , N1 = 1012
  , pL = 1013
  , Uo = 1014
  , Ys = 1015
  , Kc = 1016
  , mL = 1017
  , gL = 1018
  , Ha = 1020
  , vL = 1021
  , Ii = 1023
  , yL = 1024
  , _L = 1025
  , $o = 1026
  , Ja = 1027
  , xL = 1028
  , SL = 1029
  , wL = 1030
  , ML = 1031
  , EL = 1033
  , pm = 33776
  , mm = 33777
  , gm = 33778
  , vm = 33779
  , Mx = 35840
  , Ex = 35841
  , Tx = 35842
  , Ax = 35843
  , TL = 36196
  , Rx = 37492
  , Cx = 37496
  , bx = 37808
  , Px = 37809
  , Lx = 37810
  , Ix = 37811
  , Nx = 37812
  , Dx = 37813
  , Ux = 37814
  , kx = 37815
  , Ox = 37816
  , Fx = 37817
  , zx = 37818
  , Bx = 37819
  , Vx = 37820
  , Hx = 37821
  , ym = 36492
  , AL = 36283
  , Gx = 36284
  , Wx = 36285
  , Xx = 36286
  , RL = 2200
  , CL = 2201
  , bL = 2202
  , Zc = 2300
  , el = 2301
  , _m = 2302
  , Ua = 2400
  , ka = 2401
  , nd = 2402
  , f0 = 2500
  , D1 = 2501
  , PL = 0
  , U1 = 1
  , Jm = 2
  , k1 = 3e3
  , jo = 3001
  , LL = 3200
  , IL = 3201
  , sa = 0
  , NL = 1
  , Yo = ""
  , lt = "srgb"
  , Qr = "srgb-linear"
  , O1 = "display-p3"
  , kH = 0
  , xm = 7680
  , OH = 7681
  , FH = 7682
  , zH = 7683
  , BH = 34055
  , VH = 34056
  , HH = 5386
  , GH = 512
  , WH = 513
  , XH = 514
  , $H = 515
  , jH = 516
  , YH = 517
  , qH = 518
  , DL = 519
  , id = 35044
  , KH = 35048
  , ZH = 35040
  , QH = 35045
  , JH = 35049
  , e5 = 35041
  , t5 = 35046
  , n5 = 35050
  , i5 = 35042
  , r5 = "100"
  , $x = "300 es"
  , eg = 1035;
class so {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const ui = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let HT = 1234567;
const Ga = Math.PI / 180
  , Qc = 180 / Math.PI;
function Qi() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (ui[n & 255] + ui[n >> 8 & 255] + ui[n >> 16 & 255] + ui[n >> 24 & 255] + "-" + ui[e & 255] + ui[e >> 8 & 255] + "-" + ui[e >> 16 & 15 | 64] + ui[e >> 24 & 255] + "-" + ui[t & 63 | 128] + ui[t >> 8 & 255] + "-" + ui[t >> 16 & 255] + ui[t >> 24 & 255] + ui[i & 255] + ui[i >> 8 & 255] + ui[i >> 16 & 255] + ui[i >> 24 & 255]).toLowerCase()
}
function xn(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function F1(n, e) {
    return (n % e + e) % e
}
function s5(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function o5(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function Pf(n, e, t) {
    return (1 - t) * n + t * e
}
function a5(n, e, t, i) {
    return Pf(n, e, 1 - Math.exp(-t * i))
}
function l5(n, e=1) {
    return e - Math.abs(F1(n, e * 2) - e)
}
function c5(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function u5(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function f5(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function d5(n, e) {
    return n + Math.random() * (e - n)
}
function h5(n) {
    return n * (.5 - Math.random())
}
function p5(n) {
    n !== void 0 && (HT = n);
    let e = HT += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function m5(n) {
    return n * Ga
}
function g5(n) {
    return n * Qc
}
function jx(n) {
    return (n & n - 1) === 0 && n !== 0
}
function UL(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function kL(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function v5(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , f = s((e + i) / 2)
      , d = o((e + i) / 2)
      , h = s((e - i) / 2)
      , p = o((e - i) / 2)
      , m = s((i - e) / 2)
      , y = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * d, l * h, l * p, a * f);
        break;
    case "YZY":
        n.set(l * p, a * d, l * h, a * f);
        break;
    case "ZXZ":
        n.set(l * h, l * p, a * d, a * f);
        break;
    case "XZX":
        n.set(a * d, l * y, l * m, a * f);
        break;
    case "YXY":
        n.set(l * m, a * d, l * y, a * f);
        break;
    case "ZYZ":
        n.set(l * y, l * m, a * d, a * f);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function Yi(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function xt(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const vr = {
    DEG2RAD: Ga,
    RAD2DEG: Qc,
    generateUUID: Qi,
    clamp: xn,
    euclideanModulo: F1,
    mapLinear: s5,
    inverseLerp: o5,
    lerp: Pf,
    damp: a5,
    pingpong: l5,
    smoothstep: c5,
    smootherstep: u5,
    randInt: f5,
    randFloat: d5,
    randFloatSpread: h5,
    seededRandom: p5,
    degToRad: m5,
    radToDeg: g5,
    isPowerOfTwo: jx,
    ceilPowerOfTwo: UL,
    floorPowerOfTwo: kL,
    setQuaternionFromProperEuler: v5,
    normalize: xt,
    denormalize: Yi
};
class be {
    constructor(e=0, t=0) {
        be.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(xn(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Rt {
    constructor() {
        Rt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, f) {
        const d = this.elements;
        return d[0] = e,
        d[1] = r,
        d[2] = a,
        d[3] = t,
        d[4] = s,
        d[5] = l,
        d[6] = i,
        d[7] = o,
        d[8] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , f = i[1]
          , d = i[4]
          , h = i[7]
          , p = i[2]
          , m = i[5]
          , y = i[8]
          , S = r[0]
          , M = r[3]
          , g = r[6]
          , _ = r[1]
          , w = r[4]
          , T = r[7]
          , A = r[2]
          , C = r[5]
          , P = r[8];
        return s[0] = o * S + a * _ + l * A,
        s[3] = o * M + a * w + l * C,
        s[6] = o * g + a * T + l * P,
        s[1] = f * S + d * _ + h * A,
        s[4] = f * M + d * w + h * C,
        s[7] = f * g + d * T + h * P,
        s[2] = p * S + m * _ + y * A,
        s[5] = p * M + m * w + y * C,
        s[8] = p * g + m * T + y * P,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , d = e[8];
        return t * o * d - t * a * f - i * s * d + i * a * l + r * s * f - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , d = e[8]
          , h = d * o - a * f
          , p = a * l - d * s
          , m = f * s - o * l
          , y = t * h + i * p + r * m;
        if (y === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / y;
        return e[0] = h * S,
        e[1] = (r * f - d * i) * S,
        e[2] = (a * i - r * o) * S,
        e[3] = p * S,
        e[4] = (d * t - r * l) * S,
        e[5] = (r * s - a * t) * S,
        e[6] = m * S,
        e[7] = (i * l - f * t) * S,
        e[8] = (o * t - i * s) * S,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s)
          , f = Math.sin(s);
        return this.set(i * l, i * f, -i * (l * o + f * a) + o + e, -r * f, r * l, -r * (-f * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(py.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(py.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(py.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const py = new Rt;
function OL(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const y5 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function yc(n, e) {
    return new y5[n](e)
}
function rd(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
const GT = {};
function Lf(n) {
    n in GT || (GT[n] = !0,
    console.warn(n))
}
function Lc(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function my(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
const _5 = new Rt().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199])
  , x5 = new Rt().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);
function S5(n) {
    return n.convertSRGBToLinear().applyMatrix3(x5)
}
function w5(n) {
    return n.applyMatrix3(_5).convertLinearToSRGB()
}
const M5 = {
    [Qr]: n=>n,
    [lt]: n=>n.convertSRGBToLinear(),
    [O1]: S5
}
  , E5 = {
    [Qr]: n=>n,
    [lt]: n=>n.convertLinearToSRGB(),
    [O1]: w5
}
  , dr = {
    enabled: !0,
    get legacyMode() {
        return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        !this.enabled
    },
    set legacyMode(n) {
        console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        this.enabled = !n
    },
    get workingColorSpace() {
        return Qr
    },
    set workingColorSpace(n) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = M5[e]
          , r = E5[t];
        if (i === void 0 || r === void 0)
            throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this.workingColorSpace)
    }
};
let Il;
class z1 {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Il === void 0 && (Il = rd("canvas")),
            Il.width = e.width,
            Il.height = e.height;
            const i = Il.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Il
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = rd("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Lc(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Lc(t[i] / 255) * 255) : t[i] = Lc(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
class Oa {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = Qi(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(gy(r[o].image)) : s.push(gy(r[o]))
            } else
                s = gy(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function gy(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? z1.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let T5 = 0;
class en extends so {
    constructor(e=en.DEFAULT_IMAGE, t=en.DEFAULT_MAPPING, i=On, r=On, s=dn, o=ws, a=Ii, l=to, f=en.DEFAULT_ANISOTROPY, d=Yo) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: T5++
        }),
        this.uuid = Qi(),
        this.name = "",
        this.source = new Oa(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = f,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new be(0,0),
        this.repeat = new be(1,1),
        this.center = new be(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Rt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof d == "string" ? this.colorSpace = d : (Lf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = d === jo ? lt : Yo),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== c0)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Yn:
                e.x = e.x - Math.floor(e.x);
                break;
            case On:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case qc:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Yn:
                e.y = e.y - Math.floor(e.y);
                break;
            case On:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case qc:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return Lf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === lt ? jo : k1
    }
    set encoding(e) {
        Lf("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === jo ? lt : Yo
    }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = c0;
en.DEFAULT_ANISOTROPY = 1;
class Ut {
    constructor(e=0, t=0, i=0, r=1) {
        Ut.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements
          , f = l[0]
          , d = l[4]
          , h = l[8]
          , p = l[1]
          , m = l[5]
          , y = l[9]
          , S = l[2]
          , M = l[6]
          , g = l[10];
        if (Math.abs(d - p) < .01 && Math.abs(h - S) < .01 && Math.abs(y - M) < .01) {
            if (Math.abs(d + p) < .1 && Math.abs(h + S) < .1 && Math.abs(y + M) < .1 && Math.abs(f + m + g - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (f + 1) / 2
              , T = (m + 1) / 2
              , A = (g + 1) / 2
              , C = (d + p) / 4
              , P = (h + S) / 4
              , N = (y + M) / 4;
            return w > T && w > A ? w < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(w),
            r = C / i,
            s = P / i) : T > A ? T < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(T),
            i = C / r,
            s = N / r) : A < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(A),
            i = P / s,
            r = N / s),
            this.set(i, r, s, t),
            this
        }
        let _ = Math.sqrt((M - y) * (M - y) + (h - S) * (h - S) + (p - d) * (p - d));
        return Math.abs(_) < .001 && (_ = 1),
        this.x = (M - y) / _,
        this.y = (h - S) / _,
        this.z = (p - d) / _,
        this.w = Math.acos((f + m + g - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Jr extends so {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Ut(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ut(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i.encoding !== void 0 && (Lf("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
        i.colorSpace = i.encoding === jo ? lt : Yo),
        this.texture = new en(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1,
        this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null,
        this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : dn,
        this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0,
        this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1,
        this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null,
        this.samples = i.samples !== void 0 ? i.samples : 0
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Oa(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class d0 extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = _n,
        this.minFilter = _n,
        this.wrapR = On,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class A5 extends Jr {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new d0(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class B1 extends en {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = _n,
        this.minFilter = _n,
        this.wrapR = On,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class R5 extends Jr {
    constructor(e=1, t=1, i=1) {
        super(e, t),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new B1(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class C5 extends Jr {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < i; o++)
            this.texture[o] = s.clone(),
            this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.texture.length; r < s; r++)
                this.texture[r].image.width = e,
                this.texture[r].image.height = t,
                this.texture[r].image.depth = i;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t),
        this
    }
    copy(e) {
        this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.texture.length = 0;
        for (let t = 0, i = e.texture.length; t < i; t++)
            this.texture[t] = e.texture[t].clone(),
            this.texture[t].isRenderTargetTexture = !0;
        return this
    }
}
class In {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0]
          , f = i[r + 1]
          , d = i[r + 2]
          , h = i[r + 3];
        const p = s[o + 0]
          , m = s[o + 1]
          , y = s[o + 2]
          , S = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = f,
            e[t + 2] = d,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = p,
            e[t + 1] = m,
            e[t + 2] = y,
            e[t + 3] = S;
            return
        }
        if (h !== S || l !== p || f !== m || d !== y) {
            let M = 1 - a;
            const g = l * p + f * m + d * y + h * S
              , _ = g >= 0 ? 1 : -1
              , w = 1 - g * g;
            if (w > Number.EPSILON) {
                const A = Math.sqrt(w)
                  , C = Math.atan2(A, g * _);
                M = Math.sin(M * C) / A,
                a = Math.sin(a * C) / A
            }
            const T = a * _;
            if (l = l * M + p * T,
            f = f * M + m * T,
            d = d * M + y * T,
            h = h * M + S * T,
            M === 1 - a) {
                const A = 1 / Math.sqrt(l * l + f * f + d * d + h * h);
                l *= A,
                f *= A,
                d *= A,
                h *= A
            }
        }
        e[t] = l,
        e[t + 1] = f,
        e[t + 2] = d,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , f = i[r + 2]
          , d = i[r + 3]
          , h = s[o]
          , p = s[o + 1]
          , m = s[o + 2]
          , y = s[o + 3];
        return e[t] = a * y + d * h + l * m - f * p,
        e[t + 1] = l * y + d * p + f * h - a * m,
        e[t + 2] = f * y + d * m + a * p - l * h,
        e[t + 3] = d * y - a * h - l * p - f * m,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , f = a(i / 2)
          , d = a(r / 2)
          , h = a(s / 2)
          , p = l(i / 2)
          , m = l(r / 2)
          , y = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = p * d * h + f * m * y,
            this._y = f * m * h - p * d * y,
            this._z = f * d * y + p * m * h,
            this._w = f * d * h - p * m * y;
            break;
        case "YXZ":
            this._x = p * d * h + f * m * y,
            this._y = f * m * h - p * d * y,
            this._z = f * d * y - p * m * h,
            this._w = f * d * h + p * m * y;
            break;
        case "ZXY":
            this._x = p * d * h - f * m * y,
            this._y = f * m * h + p * d * y,
            this._z = f * d * y + p * m * h,
            this._w = f * d * h - p * m * y;
            break;
        case "ZYX":
            this._x = p * d * h - f * m * y,
            this._y = f * m * h + p * d * y,
            this._z = f * d * y - p * m * h,
            this._w = f * d * h + p * m * y;
            break;
        case "YZX":
            this._x = p * d * h + f * m * y,
            this._y = f * m * h + p * d * y,
            this._z = f * d * y - p * m * h,
            this._w = f * d * h - p * m * y;
            break;
        case "XZY":
            this._x = p * d * h - f * m * y,
            this._y = f * m * h - p * d * y,
            this._z = f * d * y + p * m * h,
            this._w = f * d * h + p * m * y;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , f = t[2]
          , d = t[6]
          , h = t[10]
          , p = i + a + h;
        if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m,
            this._x = (d - l) * m,
            this._y = (s - f) * m,
            this._z = (o - r) * m
        } else if (i > a && i > h) {
            const m = 2 * Math.sqrt(1 + i - a - h);
            this._w = (d - l) / m,
            this._x = .25 * m,
            this._y = (r + o) / m,
            this._z = (s + f) / m
        } else if (a > h) {
            const m = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - f) / m,
            this._x = (r + o) / m,
            this._y = .25 * m,
            this._z = (l + d) / m
        } else {
            const m = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / m,
            this._x = (s + f) / m,
            this._y = (l + d) / m,
            this._z = .25 * m
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(xn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , f = t._z
          , d = t._w;
        return this._x = i * d + o * a + r * f - s * l,
        this._y = r * d + o * l + s * a - i * f,
        this._z = s * d + o * f + i * l - r * a,
        this._w = o * d - i * a - r * l - s * f,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w,
            this._x = m * i + t * this._x,
            this._y = m * r + t * this._y,
            this._z = m * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const f = Math.sqrt(l)
          , d = Math.atan2(f, a)
          , h = Math.sin((1 - t) * d) / f
          , p = Math.sin(t * d) / f;
        return this._w = o * h + this._w * p,
        this._x = i * h + this._x * p,
        this._y = r * h + this._y * p,
        this._z = s * h + this._z * p,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , r = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class z {
    constructor(e=0, t=0, i=0) {
        z.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(WT.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(WT.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , f = l * t + o * r - a * i
          , d = l * i + a * t - s * r
          , h = l * r + s * i - o * t
          , p = -s * t - o * i - a * r;
        return this.x = f * l + p * -s + d * -a - h * -o,
        this.y = d * l + p * -o + h * -s - f * -a,
        this.z = h * l + p * -a + f * -o - d * -s,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return vy.copy(this).projectOnVector(e),
        this.sub(vy)
    }
    reflect(e) {
        return this.sub(vy.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(xn(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const vy = new z
  , WT = new In;
class ts {
    constructor(e=new z(1 / 0,1 / 0,1 / 0), t=new z(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(Us.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(Us.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Us.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        if (e.updateWorldMatrix(!1, !1),
        e.boundingBox !== void 0)
            e.boundingBox === null && e.computeBoundingBox(),
            Nl.copy(e.boundingBox),
            Nl.applyMatrix4(e.matrixWorld),
            this.union(Nl);
        else {
            const r = e.geometry;
            if (r !== void 0)
                if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
                    const s = r.attributes.position;
                    for (let o = 0, a = s.count; o < a; o++)
                        Us.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                        this.expandByPoint(Us)
                } else
                    r.boundingBox === null && r.computeBoundingBox(),
                    Nl.copy(r.boundingBox),
                    Nl.applyMatrix4(e.matrixWorld),
                    this.union(Nl)
        }
        const i = e.children;
        for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Us),
        Us.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(qu),
        cp.subVectors(this.max, qu),
        Dl.subVectors(e.a, qu),
        Ul.subVectors(e.b, qu),
        kl.subVectors(e.c, qu),
        _o.subVectors(Ul, Dl),
        xo.subVectors(kl, Ul),
        ya.subVectors(Dl, kl);
        let t = [0, -_o.z, _o.y, 0, -xo.z, xo.y, 0, -ya.z, ya.y, _o.z, 0, -_o.x, xo.z, 0, -xo.x, ya.z, 0, -ya.x, -_o.y, _o.x, 0, -xo.y, xo.x, 0, -ya.y, ya.x, 0];
        return !yy(t, Dl, Ul, kl, cp) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !yy(t, Dl, Ul, kl, cp)) ? !1 : (up.crossVectors(_o, xo),
        t = [up.x, up.y, up.z],
        yy(t, Dl, Ul, kl, cp))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Us).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Us).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Ds[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ds[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ds[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ds[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ds[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ds[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ds[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ds[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ds),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Ds = [new z, new z, new z, new z, new z, new z, new z, new z]
  , Us = new z
  , Nl = new ts
  , Dl = new z
  , Ul = new z
  , kl = new z
  , _o = new z
  , xo = new z
  , ya = new z
  , qu = new z
  , cp = new z
  , up = new z
  , _a = new z;
function yy(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        _a.fromArray(n, s);
        const a = r.x * Math.abs(_a.x) + r.y * Math.abs(_a.y) + r.z * Math.abs(_a.z)
          , l = e.dot(_a)
          , f = t.dot(_a)
          , d = i.dot(_a);
        if (Math.max(-Math.max(l, f, d), Math.min(l, f, d)) > a)
            return !1
    }
    return !0
}
const b5 = new ts
  , Ku = new z
  , _y = new z;
class ns {
    constructor(e=new z, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : b5.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Ku.subVectors(e, this.center);
        const t = Ku.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(Ku, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (_y.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Ku.copy(e.center).add(_y)),
        this.expandByPoint(Ku.copy(e.center).sub(_y))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ks = new z
  , xy = new z
  , fp = new z
  , So = new z
  , Sy = new z
  , dp = new z
  , wy = new z;
class Ad {
    constructor(e=new z, t=new z(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, ks)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = ks.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (ks.copy(this.origin).addScaledVector(this.direction, t),
        ks.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        xy.copy(e).add(t).multiplyScalar(.5),
        fp.copy(t).sub(e).normalize(),
        So.copy(this.origin).sub(xy);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(fp)
          , a = So.dot(this.direction)
          , l = -So.dot(fp)
          , f = So.lengthSq()
          , d = Math.abs(1 - o * o);
        let h, p, m, y;
        if (d > 0)
            if (h = o * l - a,
            p = o * a - l,
            y = s * d,
            h >= 0)
                if (p >= -y)
                    if (p <= y) {
                        const S = 1 / d;
                        h *= S,
                        p *= S,
                        m = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + f
                    } else
                        p = s,
                        h = Math.max(0, -(o * p + a)),
                        m = -h * h + p * (p + 2 * l) + f;
                else
                    p = -s,
                    h = Math.max(0, -(o * p + a)),
                    m = -h * h + p * (p + 2 * l) + f;
            else
                p <= -y ? (h = Math.max(0, -(-o * s + a)),
                p = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + f) : p <= y ? (h = 0,
                p = Math.min(Math.max(-s, -l), s),
                m = p * (p + 2 * l) + f) : (h = Math.max(0, -(o * s + a)),
                p = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                m = -h * h + p * (p + 2 * l) + f);
        else
            p = o > 0 ? -s : s,
            h = Math.max(0, -(o * p + a)),
            m = -h * h + p * (p + 2 * l) + f;
        return i && i.copy(this.origin).addScaledVector(this.direction, h),
        r && r.copy(xy).addScaledVector(fp, p),
        m
    }
    intersectSphere(e, t) {
        ks.subVectors(e.center, this.origin);
        const i = ks.dot(this.direction)
          , r = ks.dot(ks) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const f = 1 / this.direction.x
          , d = 1 / this.direction.y
          , h = 1 / this.direction.z
          , p = this.origin;
        return f >= 0 ? (i = (e.min.x - p.x) * f,
        r = (e.max.x - p.x) * f) : (i = (e.max.x - p.x) * f,
        r = (e.min.x - p.x) * f),
        d >= 0 ? (s = (e.min.y - p.y) * d,
        o = (e.max.y - p.y) * d) : (s = (e.max.y - p.y) * d,
        o = (e.min.y - p.y) * d),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (a = (e.min.z - p.z) * h,
        l = (e.max.z - p.z) * h) : (a = (e.max.z - p.z) * h,
        l = (e.min.z - p.z) * h),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, ks) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        Sy.subVectors(t, e),
        dp.subVectors(i, e),
        wy.crossVectors(Sy, dp);
        let o = this.direction.dot(wy), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        So.subVectors(this.origin, e);
        const l = a * this.direction.dot(dp.crossVectors(So, dp));
        if (l < 0)
            return null;
        const f = a * this.direction.dot(Sy.cross(So));
        if (f < 0 || l + f > o)
            return null;
        const d = -a * So.dot(wy);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class $e {
    constructor() {
        $e.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, f, d, h, p, m, y, S, M) {
        const g = this.elements;
        return g[0] = e,
        g[4] = t,
        g[8] = i,
        g[12] = r,
        g[1] = s,
        g[5] = o,
        g[9] = a,
        g[13] = l,
        g[2] = f,
        g[6] = d,
        g[10] = h,
        g[14] = p,
        g[3] = m,
        g[7] = y,
        g[11] = S,
        g[15] = M,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new $e().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / Ol.setFromMatrixColumn(e, 0).length()
          , s = 1 / Ol.setFromMatrixColumn(e, 1).length()
          , o = 1 / Ol.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , f = Math.sin(r)
          , d = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const p = o * d
              , m = o * h
              , y = a * d
              , S = a * h;
            t[0] = l * d,
            t[4] = -l * h,
            t[8] = f,
            t[1] = m + y * f,
            t[5] = p - S * f,
            t[9] = -a * l,
            t[2] = S - p * f,
            t[6] = y + m * f,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const p = l * d
              , m = l * h
              , y = f * d
              , S = f * h;
            t[0] = p + S * a,
            t[4] = y * a - m,
            t[8] = o * f,
            t[1] = o * h,
            t[5] = o * d,
            t[9] = -a,
            t[2] = m * a - y,
            t[6] = S + p * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const p = l * d
              , m = l * h
              , y = f * d
              , S = f * h;
            t[0] = p - S * a,
            t[4] = -o * h,
            t[8] = y + m * a,
            t[1] = m + y * a,
            t[5] = o * d,
            t[9] = S - p * a,
            t[2] = -o * f,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const p = o * d
              , m = o * h
              , y = a * d
              , S = a * h;
            t[0] = l * d,
            t[4] = y * f - m,
            t[8] = p * f + S,
            t[1] = l * h,
            t[5] = S * f + p,
            t[9] = m * f - y,
            t[2] = -f,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const p = o * l
              , m = o * f
              , y = a * l
              , S = a * f;
            t[0] = l * d,
            t[4] = S - p * h,
            t[8] = y * h + m,
            t[1] = h,
            t[5] = o * d,
            t[9] = -a * d,
            t[2] = -f * d,
            t[6] = m * h + y,
            t[10] = p - S * h
        } else if (e.order === "XZY") {
            const p = o * l
              , m = o * f
              , y = a * l
              , S = a * f;
            t[0] = l * d,
            t[4] = -h,
            t[8] = f * d,
            t[1] = p * h + S,
            t[5] = o * d,
            t[9] = m * h - y,
            t[2] = y * h - m,
            t[6] = a * d,
            t[10] = S * h + p
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(P5, e, L5)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return Wi.subVectors(e, t),
        Wi.lengthSq() === 0 && (Wi.z = 1),
        Wi.normalize(),
        wo.crossVectors(i, Wi),
        wo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Wi.x += 1e-4 : Wi.z += 1e-4,
        Wi.normalize(),
        wo.crossVectors(i, Wi)),
        wo.normalize(),
        hp.crossVectors(Wi, wo),
        r[0] = wo.x,
        r[4] = hp.x,
        r[8] = Wi.x,
        r[1] = wo.y,
        r[5] = hp.y,
        r[9] = Wi.y,
        r[2] = wo.z,
        r[6] = hp.z,
        r[10] = Wi.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , f = i[12]
          , d = i[1]
          , h = i[5]
          , p = i[9]
          , m = i[13]
          , y = i[2]
          , S = i[6]
          , M = i[10]
          , g = i[14]
          , _ = i[3]
          , w = i[7]
          , T = i[11]
          , A = i[15]
          , C = r[0]
          , P = r[4]
          , N = r[8]
          , b = r[12]
          , L = r[1]
          , Y = r[5]
          , Z = r[9]
          , $ = r[13]
          , Q = r[2]
          , ie = r[6]
          , fe = r[10]
          , le = r[14]
          , D = r[3]
          , j = r[7]
          , X = r[11]
          , ue = r[15];
        return s[0] = o * C + a * L + l * Q + f * D,
        s[4] = o * P + a * Y + l * ie + f * j,
        s[8] = o * N + a * Z + l * fe + f * X,
        s[12] = o * b + a * $ + l * le + f * ue,
        s[1] = d * C + h * L + p * Q + m * D,
        s[5] = d * P + h * Y + p * ie + m * j,
        s[9] = d * N + h * Z + p * fe + m * X,
        s[13] = d * b + h * $ + p * le + m * ue,
        s[2] = y * C + S * L + M * Q + g * D,
        s[6] = y * P + S * Y + M * ie + g * j,
        s[10] = y * N + S * Z + M * fe + g * X,
        s[14] = y * b + S * $ + M * le + g * ue,
        s[3] = _ * C + w * L + T * Q + A * D,
        s[7] = _ * P + w * Y + T * ie + A * j,
        s[11] = _ * N + w * Z + T * fe + A * X,
        s[15] = _ * b + w * $ + T * le + A * ue,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , f = e[13]
          , d = e[2]
          , h = e[6]
          , p = e[10]
          , m = e[14]
          , y = e[3]
          , S = e[7]
          , M = e[11]
          , g = e[15];
        return y * (+s * l * h - r * f * h - s * a * p + i * f * p + r * a * m - i * l * m) + S * (+t * l * m - t * f * p + s * o * p - r * o * m + r * f * d - s * l * d) + M * (+t * f * h - t * a * m - s * o * h + i * o * m + s * a * d - i * f * d) + g * (-r * a * d - t * l * h + t * a * p + r * o * h - i * o * p + i * l * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , f = e[7]
          , d = e[8]
          , h = e[9]
          , p = e[10]
          , m = e[11]
          , y = e[12]
          , S = e[13]
          , M = e[14]
          , g = e[15]
          , _ = h * M * f - S * p * f + S * l * m - a * M * m - h * l * g + a * p * g
          , w = y * p * f - d * M * f - y * l * m + o * M * m + d * l * g - o * p * g
          , T = d * S * f - y * h * f + y * a * m - o * S * m - d * a * g + o * h * g
          , A = y * h * l - d * S * l - y * a * p + o * S * p + d * a * M - o * h * M
          , C = t * _ + i * w + r * T + s * A;
        if (C === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const P = 1 / C;
        return e[0] = _ * P,
        e[1] = (S * p * s - h * M * s - S * r * m + i * M * m + h * r * g - i * p * g) * P,
        e[2] = (a * M * s - S * l * s + S * r * f - i * M * f - a * r * g + i * l * g) * P,
        e[3] = (h * l * s - a * p * s - h * r * f + i * p * f + a * r * m - i * l * m) * P,
        e[4] = w * P,
        e[5] = (d * M * s - y * p * s + y * r * m - t * M * m - d * r * g + t * p * g) * P,
        e[6] = (y * l * s - o * M * s - y * r * f + t * M * f + o * r * g - t * l * g) * P,
        e[7] = (o * p * s - d * l * s + d * r * f - t * p * f - o * r * m + t * l * m) * P,
        e[8] = T * P,
        e[9] = (y * h * s - d * S * s - y * i * m + t * S * m + d * i * g - t * h * g) * P,
        e[10] = (o * S * s - y * a * s + y * i * f - t * S * f - o * i * g + t * a * g) * P,
        e[11] = (d * a * s - o * h * s - d * i * f + t * h * f + o * i * m - t * a * m) * P,
        e[12] = A * P,
        e[13] = (d * S * r - y * h * r + y * i * p - t * S * p - d * i * M + t * h * M) * P,
        e[14] = (y * a * r - o * S * r - y * i * l + t * S * l + o * i * M - t * a * M) * P,
        e[15] = (o * h * r - d * a * r + d * i * l - t * h * l - o * i * p + t * a * p) * P,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , f = s * o
          , d = s * a;
        return this.set(f * o + i, f * a - r * l, f * l + r * a, 0, f * a + r * l, d * a + i, d * l - r * o, 0, f * l - r * a, d * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , f = s + s
          , d = o + o
          , h = a + a
          , p = s * f
          , m = s * d
          , y = s * h
          , S = o * d
          , M = o * h
          , g = a * h
          , _ = l * f
          , w = l * d
          , T = l * h
          , A = i.x
          , C = i.y
          , P = i.z;
        return r[0] = (1 - (S + g)) * A,
        r[1] = (m + T) * A,
        r[2] = (y - w) * A,
        r[3] = 0,
        r[4] = (m - T) * C,
        r[5] = (1 - (p + g)) * C,
        r[6] = (M + _) * C,
        r[7] = 0,
        r[8] = (y + w) * P,
        r[9] = (M - _) * P,
        r[10] = (1 - (p + S)) * P,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = Ol.set(r[0], r[1], r[2]).length();
        const o = Ol.set(r[4], r[5], r[6]).length()
          , a = Ol.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        kr.copy(this);
        const f = 1 / s
          , d = 1 / o
          , h = 1 / a;
        return kr.elements[0] *= f,
        kr.elements[1] *= f,
        kr.elements[2] *= f,
        kr.elements[4] *= d,
        kr.elements[5] *= d,
        kr.elements[6] *= d,
        kr.elements[8] *= h,
        kr.elements[9] *= h,
        kr.elements[10] *= h,
        t.setFromRotationMatrix(kr),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o) {
        const a = this.elements
          , l = 2 * s / (t - e)
          , f = 2 * s / (i - r)
          , d = (t + e) / (t - e)
          , h = (i + r) / (i - r)
          , p = -(o + s) / (o - s)
          , m = -2 * o * s / (o - s);
        return a[0] = l,
        a[4] = 0,
        a[8] = d,
        a[12] = 0,
        a[1] = 0,
        a[5] = f,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = p,
        a[14] = m,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o) {
        const a = this.elements
          , l = 1 / (t - e)
          , f = 1 / (i - r)
          , d = 1 / (o - s)
          , h = (t + e) * l
          , p = (i + r) * f
          , m = (o + s) * d;
        return a[0] = 2 * l,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * f,
        a[9] = 0,
        a[13] = -p,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * d,
        a[14] = -m,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const Ol = new z
  , kr = new $e
  , P5 = new z(0,0,0)
  , L5 = new z(1,1,1)
  , wo = new z
  , hp = new z
  , Wi = new z
  , XT = new $e
  , $T = new In;
class qi {
    constructor(e=0, t=0, i=0, r=qi.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , f = r[5]
          , d = r[9]
          , h = r[2]
          , p = r[6]
          , m = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(xn(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, m),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, f),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-xn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, m),
            this._z = Math.atan2(l, f)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(xn(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, m),
            this._z = Math.atan2(-o, f)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-xn(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, m),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, f));
            break;
        case "YZX":
            this._z = Math.asin(xn(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, f),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, m));
            break;
        case "XZY":
            this._z = Math.asin(-xn(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, f),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, m),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return XT.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(XT, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return $T.setFromEuler(this),
        this.setFromQuaternion($T, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
qi.DEFAULT_ORDER = "XYZ";
class Wa {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let I5 = 0;
const jT = new z
  , Fl = new In
  , Os = new $e
  , pp = new z
  , Zu = new z
  , N5 = new z
  , D5 = new In
  , YT = new z(1,0,0)
  , qT = new z(0,1,0)
  , KT = new z(0,0,1)
  , U5 = {
    type: "added"
}
  , ZT = {
    type: "removed"
};
class Lt extends so {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: I5++
        }),
        this.uuid = Qi(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Lt.DEFAULT_UP.clone();
        const e = new z
          , t = new qi
          , i = new In
          , r = new z(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new $e
            },
            normalMatrix: {
                value: new Rt
            }
        }),
        this.matrix = new $e,
        this.matrixWorld = new $e,
        this.matrixAutoUpdate = Lt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = Lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.layers = new Wa,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Fl.setFromAxisAngle(e, t),
        this.quaternion.multiply(Fl),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Fl.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Fl),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(YT, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(qT, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(KT, e)
    }
    translateOnAxis(e, t) {
        return jT.copy(e).applyQuaternion(this.quaternion),
        this.position.add(jT.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(YT, e)
    }
    translateY(e) {
        return this.translateOnAxis(qT, e)
    }
    translateZ(e) {
        return this.translateOnAxis(KT, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Os.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? pp.copy(e) : pp.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        Zu.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Os.lookAt(Zu, pp, this.up) : Os.lookAt(pp, Zu, this.up),
        this.quaternion.setFromRotationMatrix(Os),
        r && (Os.extractRotation(r.matrixWorld),
        Fl.setFromRotationMatrix(Os),
        this.quaternion.premultiply(Fl.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(U5)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(ZT)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(ZT)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Os.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Os.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Os),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
            const o = this.children[r].getObjectsByProperty(e, t);
            o.length > 0 && (i = i.concat(o))
        }
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Zu, e, N5),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Zu, D5, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let f = 0, d = l.length; f < d; f++) {
                        const h = l[f];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, f = this.material.length; l < f; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , f = o(e.textures)
              , d = o(e.images)
              , h = o(e.shapes)
              , p = o(e.skeletons)
              , m = o(e.animations)
              , y = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            f.length > 0 && (i.textures = f),
            d.length > 0 && (i.images = d),
            h.length > 0 && (i.shapes = h),
            p.length > 0 && (i.skeletons = p),
            m.length > 0 && (i.animations = m),
            y.length > 0 && (i.nodes = y)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const f in a) {
                const d = a[f];
                delete d.metadata,
                l.push(d)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Lt.DEFAULT_UP = new z(0,1,0);
Lt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Or = new z
  , Fs = new z
  , My = new z
  , zs = new z
  , zl = new z
  , Bl = new z
  , QT = new z
  , Ey = new z
  , Ty = new z
  , Ay = new z;
let mp = !1;
class Li {
    constructor(e=new z, t=new z, i=new z) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        Or.subVectors(e, t),
        r.cross(Or);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Or.subVectors(r, t),
        Fs.subVectors(i, t),
        My.subVectors(e, t);
        const o = Or.dot(Or)
          , a = Or.dot(Fs)
          , l = Or.dot(My)
          , f = Fs.dot(Fs)
          , d = Fs.dot(My)
          , h = o * f - a * a;
        if (h === 0)
            return s.set(-2, -1, -1);
        const p = 1 / h
          , m = (f * l - a * d) * p
          , y = (o * d - a * l) * p;
        return s.set(1 - m - y, y, m)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, zs),
        zs.x >= 0 && zs.y >= 0 && zs.x + zs.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return mp === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        mp = !0),
        this.getInterpolation(e, t, i, r, s, o, a, l)
    }
    static getInterpolation(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, zs),
        l.setScalar(0),
        l.addScaledVector(s, zs.x),
        l.addScaledVector(o, zs.y),
        l.addScaledVector(a, zs.z),
        l
    }
    static isFrontFacing(e, t, i, r) {
        return Or.subVectors(i, t),
        Fs.subVectors(e, t),
        Or.cross(Fs).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Or.subVectors(this.c, this.b),
        Fs.subVectors(this.a, this.b),
        Or.cross(Fs).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Li.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Li.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return mp === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        mp = !0),
        Li.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    getInterpolation(e, t, i, r, s) {
        return Li.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return Li.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Li.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        zl.subVectors(r, i),
        Bl.subVectors(s, i),
        Ey.subVectors(e, i);
        const l = zl.dot(Ey)
          , f = Bl.dot(Ey);
        if (l <= 0 && f <= 0)
            return t.copy(i);
        Ty.subVectors(e, r);
        const d = zl.dot(Ty)
          , h = Bl.dot(Ty);
        if (d >= 0 && h <= d)
            return t.copy(r);
        const p = l * h - d * f;
        if (p <= 0 && l >= 0 && d <= 0)
            return o = l / (l - d),
            t.copy(i).addScaledVector(zl, o);
        Ay.subVectors(e, s);
        const m = zl.dot(Ay)
          , y = Bl.dot(Ay);
        if (y >= 0 && m <= y)
            return t.copy(s);
        const S = m * f - l * y;
        if (S <= 0 && f >= 0 && y <= 0)
            return a = f / (f - y),
            t.copy(i).addScaledVector(Bl, a);
        const M = d * y - m * h;
        if (M <= 0 && h - d >= 0 && m - y >= 0)
            return QT.subVectors(s, r),
            a = (h - d) / (h - d + (m - y)),
            t.copy(r).addScaledVector(QT, a);
        const g = 1 / (M + S + p);
        return o = S * g,
        a = p * g,
        t.copy(i).addScaledVector(zl, o).addScaledVector(Bl, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let k5 = 0;
class Nn extends so {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: k5++
        }),
        this.uuid = Qi(),
        this.name = "",
        this.type = "Material",
        this.blending = Va,
        this.side = Zr,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = P1,
        this.blendDst = L1,
        this.blendEquation = Pa,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Qm,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = DL,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = xm,
        this.stencilZFail = xm,
        this.stencilZPass = xm,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Va && (i.blending = this.blending),
        this.side !== Zr && (i.side = this.side),
        this.vertexColors && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = this.transparent),
        i.depthFunc = this.depthFunc,
        i.depthTest = this.depthTest,
        i.depthWrite = this.depthWrite,
        i.colorWrite = this.colorWrite,
        i.stencilWrite = this.stencilWrite,
        i.stencilWriteMask = this.stencilWriteMask,
        i.stencilFunc = this.stencilFunc,
        i.stencilRef = this.stencilRef,
        i.stencilFuncMask = this.stencilFuncMask,
        i.stencilFail = this.stencilFail,
        i.stencilZFail = this.stencilZFail,
        i.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha),
        this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
        this.wireframe === !0 && (i.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = this.flatShading),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
const FL = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Fr = {
    h: 0,
    s: 0,
    l: 0
}
  , gp = {
    h: 0,
    s: 0,
    l: 0
};
function Ry(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Oe {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=lt) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        dr.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=dr.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        dr.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=dr.workingColorSpace) {
        if (e = F1(e, 1),
        t = xn(t, 0, 1),
        i = xn(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = Ry(o, s, e + 1 / 3),
            this.g = Ry(o, s, e),
            this.b = Ry(o, s, e - 1 / 3)
        }
        return dr.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=lt) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=lt) {
        const i = FL[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Lc(e.r),
        this.g = Lc(e.g),
        this.b = Lc(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = my(e.r),
        this.g = my(e.g),
        this.b = my(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=lt) {
        return dr.fromWorkingColorSpace(fi.copy(this), e),
        Math.round(xn(fi.r * 255, 0, 255)) * 65536 + Math.round(xn(fi.g * 255, 0, 255)) * 256 + Math.round(xn(fi.b * 255, 0, 255))
    }
    getHexString(e=lt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=dr.workingColorSpace) {
        dr.fromWorkingColorSpace(fi.copy(this), t);
        const i = fi.r
          , r = fi.g
          , s = fi.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, f;
        const d = (a + o) / 2;
        if (a === o)
            l = 0,
            f = 0;
        else {
            const h = o - a;
            switch (f = d <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = f,
        e.l = d,
        e
    }
    getRGB(e, t=dr.workingColorSpace) {
        return dr.fromWorkingColorSpace(fi.copy(this), t),
        e.r = fi.r,
        e.g = fi.g,
        e.b = fi.b,
        e
    }
    getStyle(e=lt) {
        dr.fromWorkingColorSpace(fi.copy(this), e);
        const t = fi.r
          , i = fi.g
          , r = fi.b;
        return e !== lt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Fr),
        Fr.h += e,
        Fr.s += t,
        Fr.l += i,
        this.setHSL(Fr.h, Fr.s, Fr.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Fr),
        e.getHSL(gp);
        const i = Pf(Fr.h, gp.h, t)
          , r = Pf(Fr.s, gp.s, t)
          , s = Pf(Fr.l, gp.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const fi = new Oe;
Oe.NAMES = FL;
class Ki extends Nn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Td,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Gs = O5();
function O5() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const f = l - 127;
        f < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        r[l] = 24,
        r[l | 256] = 24) : f < -14 ? (i[l] = 1024 >> -f - 14,
        i[l | 256] = 1024 >> -f - 14 | 32768,
        r[l] = -f - 1,
        r[l | 256] = -f - 1) : f <= 15 ? (i[l] = f + 15 << 10,
        i[l | 256] = f + 15 << 10 | 32768,
        r[l] = 13,
        r[l | 256] = 13) : f < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 24,
        r[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 13,
        r[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let f = l << 13
          , d = 0;
        for (; !(f & 8388608); )
            f <<= 1,
            d -= 8388608;
        f &= -8388609,
        d += 947912704,
        s[l] = f | d
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function Ci(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = xn(n, -65504, 65504),
    Gs.floatView[0] = n;
    const e = Gs.uint32View[0]
      , t = e >> 23 & 511;
    return Gs.baseTable[t] + ((e & 8388607) >> Gs.shiftTable[t])
}
function mf(n) {
    const e = n >> 10;
    return Gs.uint32View[0] = Gs.mantissaTable[Gs.offsetTable[e] + (n & 1023)] + Gs.exponentTable[e],
    Gs.floatView[0]
}
const F5 = {
    toHalfFloat: Ci,
    fromHalfFloat: mf
}
  , bn = new z
  , vp = new be;
class Ht {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = id,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                vp.fromBufferAttribute(this, t),
                vp.applyMatrix3(e),
                this.setXY(t, vp.x, vp.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                bn.fromBufferAttribute(this, t),
                bn.applyMatrix3(e),
                this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.applyMatrix4(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.applyNormalMatrix(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            bn.fromBufferAttribute(this, t),
            bn.transformDirection(e),
            this.setXYZ(t, bn.x, bn.y, bn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array),
        s = xt(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== id && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class z5 extends Ht {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class B5 extends Ht {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class V5 extends Ht {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class H5 extends Ht {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class h0 extends Ht {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class G5 extends Ht {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class V1 extends Ht {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class W5 extends Ht {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = mf(this.array[e * this.itemSize]);
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize] = Ci(t),
        this
    }
    getY(e) {
        let t = mf(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 1] = Ci(t),
        this
    }
    getZ(e) {
        let t = mf(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 2] = Ci(t),
        this
    }
    getW(e) {
        let t = mf(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.array[e * this.itemSize + 3] = Ci(t),
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array)),
        this.array[e + 0] = Ci(t),
        this.array[e + 1] = Ci(i),
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array)),
        this.array[e + 0] = Ci(t),
        this.array[e + 1] = Ci(i),
        this.array[e + 2] = Ci(r),
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array),
        s = xt(s, this.array)),
        this.array[e + 0] = Ci(t),
        this.array[e + 1] = Ci(i),
        this.array[e + 2] = Ci(r),
        this.array[e + 3] = Ci(s),
        this
    }
}
class je extends Ht {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
class X5 extends Ht {
    constructor(e, t, i) {
        super(new Float64Array(e), t, i)
    }
}
let $5 = 0;
const fr = new $e
  , Cy = new Lt
  , Vl = new z
  , Xi = new ts
  , Qu = new ts
  , Xn = new z;
class ft extends so {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: $5++
        }),
        this.uuid = Qi(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (OL(e) ? V1 : h0)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new Rt().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return fr.makeRotationFromQuaternion(e),
        this.applyMatrix4(fr),
        this
    }
    rotateX(e) {
        return fr.makeRotationX(e),
        this.applyMatrix4(fr),
        this
    }
    rotateY(e) {
        return fr.makeRotationY(e),
        this.applyMatrix4(fr),
        this
    }
    rotateZ(e) {
        return fr.makeRotationZ(e),
        this.applyMatrix4(fr),
        this
    }
    translate(e, t, i) {
        return fr.makeTranslation(e, t, i),
        this.applyMatrix4(fr),
        this
    }
    scale(e, t, i) {
        return fr.makeScale(e, t, i),
        this.applyMatrix4(fr),
        this
    }
    lookAt(e) {
        return Cy.lookAt(e),
        Cy.updateMatrix(),
        this.applyMatrix4(Cy.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Vl).negate(),
        this.translate(Vl.x, Vl.y, Vl.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new je(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ts);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new z(-1 / 0,-1 / 0,-1 / 0), new z(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Xi.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Xn.addVectors(this.boundingBox.min, Xi.min),
                    this.boundingBox.expandByPoint(Xn),
                    Xn.addVectors(this.boundingBox.max, Xi.max),
                    this.boundingBox.expandByPoint(Xn)) : (this.boundingBox.expandByPoint(Xi.min),
                    this.boundingBox.expandByPoint(Xi.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ns);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new z, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Xi.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Qu.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Xn.addVectors(Xi.min, Qu.min),
                    Xi.expandByPoint(Xn),
                    Xn.addVectors(Xi.max, Qu.max),
                    Xi.expandByPoint(Xn)) : (Xi.expandByPoint(Qu.min),
                    Xi.expandByPoint(Qu.max))
                }
            Xi.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Xn.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(Xn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let f = 0, d = a.count; f < d; f++)
                        Xn.fromBufferAttribute(a, f),
                        l && (Vl.fromBufferAttribute(e, f),
                        Xn.add(Vl)),
                        r = Math.max(r, i.distanceToSquared(Xn))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , r = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ht(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , f = []
          , d = [];
        for (let L = 0; L < a; L++)
            f[L] = new z,
            d[L] = new z;
        const h = new z
          , p = new z
          , m = new z
          , y = new be
          , S = new be
          , M = new be
          , g = new z
          , _ = new z;
        function w(L, Y, Z) {
            h.fromArray(r, L * 3),
            p.fromArray(r, Y * 3),
            m.fromArray(r, Z * 3),
            y.fromArray(o, L * 2),
            S.fromArray(o, Y * 2),
            M.fromArray(o, Z * 2),
            p.sub(h),
            m.sub(h),
            S.sub(y),
            M.sub(y);
            const $ = 1 / (S.x * M.y - M.x * S.y);
            isFinite($) && (g.copy(p).multiplyScalar(M.y).addScaledVector(m, -S.y).multiplyScalar($),
            _.copy(m).multiplyScalar(S.x).addScaledVector(p, -M.x).multiplyScalar($),
            f[L].add(g),
            f[Y].add(g),
            f[Z].add(g),
            d[L].add(_),
            d[Y].add(_),
            d[Z].add(_))
        }
        let T = this.groups;
        T.length === 0 && (T = [{
            start: 0,
            count: i.length
        }]);
        for (let L = 0, Y = T.length; L < Y; ++L) {
            const Z = T[L]
              , $ = Z.start
              , Q = Z.count;
            for (let ie = $, fe = $ + Q; ie < fe; ie += 3)
                w(i[ie + 0], i[ie + 1], i[ie + 2])
        }
        const A = new z
          , C = new z
          , P = new z
          , N = new z;
        function b(L) {
            P.fromArray(s, L * 3),
            N.copy(P);
            const Y = f[L];
            A.copy(Y),
            A.sub(P.multiplyScalar(P.dot(Y))).normalize(),
            C.crossVectors(N, Y);
            const $ = C.dot(d[L]) < 0 ? -1 : 1;
            l[L * 4] = A.x,
            l[L * 4 + 1] = A.y,
            l[L * 4 + 2] = A.z,
            l[L * 4 + 3] = $
        }
        for (let L = 0, Y = T.length; L < Y; ++L) {
            const Z = T[L]
              , $ = Z.start
              , Q = Z.count;
            for (let ie = $, fe = $ + Q; ie < fe; ie += 3)
                b(i[ie + 0]),
                b(i[ie + 1]),
                b(i[ie + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Ht(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let p = 0, m = i.count; p < m; p++)
                    i.setXYZ(p, 0, 0, 0);
            const r = new z
              , s = new z
              , o = new z
              , a = new z
              , l = new z
              , f = new z
              , d = new z
              , h = new z;
            if (e)
                for (let p = 0, m = e.count; p < m; p += 3) {
                    const y = e.getX(p + 0)
                      , S = e.getX(p + 1)
                      , M = e.getX(p + 2);
                    r.fromBufferAttribute(t, y),
                    s.fromBufferAttribute(t, S),
                    o.fromBufferAttribute(t, M),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    a.fromBufferAttribute(i, y),
                    l.fromBufferAttribute(i, S),
                    f.fromBufferAttribute(i, M),
                    a.add(d),
                    l.add(d),
                    f.add(d),
                    i.setXYZ(y, a.x, a.y, a.z),
                    i.setXYZ(S, l.x, l.y, l.z),
                    i.setXYZ(M, f.x, f.y, f.z)
                }
            else
                for (let p = 0, m = t.count; p < m; p += 3)
                    r.fromBufferAttribute(t, p + 0),
                    s.fromBufferAttribute(t, p + 1),
                    o.fromBufferAttribute(t, p + 2),
                    d.subVectors(o, s),
                    h.subVectors(r, s),
                    d.cross(h),
                    i.setXYZ(p + 0, d.x, d.y, d.z),
                    i.setXYZ(p + 1, d.x, d.y, d.z),
                    i.setXYZ(p + 2, d.x, d.y, d.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            Xn.fromBufferAttribute(e, t),
            Xn.normalize(),
            e.setXYZ(t, Xn.x, Xn.y, Xn.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const f = a.array
              , d = a.itemSize
              , h = a.normalized
              , p = new f.constructor(l.length * d);
            let m = 0
              , y = 0;
            for (let S = 0, M = l.length; S < M; S++) {
                a.isInterleavedBufferAttribute ? m = l[S] * a.data.stride + a.offset : m = l[S] * d;
                for (let g = 0; g < d; g++)
                    p[y++] = f[m++]
            }
            return new Ht(p,d,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new ft
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , f = e(l, i);
            t.setAttribute(a, f)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , f = s[a];
            for (let d = 0, h = f.length; d < h; d++) {
                const p = f[d]
                  , m = e(p, i);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const f = o[a];
            t.addGroup(f.start, f.count, f.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const f in l)
                l[f] !== void 0 && (e[f] = l[f]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const f = i[l];
            e.data.attributes[l] = f.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const f = this.morphAttributes[l]
              , d = [];
            for (let h = 0, p = f.length; h < p; h++) {
                const m = f[h];
                d.push(m.toJSON(e.data))
            }
            d.length > 0 && (r[l] = d,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const f in r) {
            const d = r[f];
            this.setAttribute(f, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const f in s) {
            const d = []
              , h = s[f];
            for (let p = 0, m = h.length; p < m; p++)
                d.push(h[p].clone(t));
            this.morphAttributes[f] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let f = 0, d = o.length; f < d; f++) {
            const h = o[f];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const JT = new $e
  , ms = new Ad
  , yp = new ns
  , eA = new z
  , Hl = new z
  , Gl = new z
  , Wl = new z
  , by = new z
  , _p = new z
  , xp = new be
  , Sp = new be
  , wp = new be
  , tA = new z
  , nA = new z
  , iA = new z
  , Mp = new z
  , Ep = new z;
class zn extends Lt {
    constructor(e=new ft, t=new Ki) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            _p.set(0, 0, 0);
            for (let l = 0, f = s.length; l < f; l++) {
                const d = a[l]
                  , h = s[l];
                d !== 0 && (by.fromBufferAttribute(h, e),
                o ? _p.addScaledVector(by, d) : _p.addScaledVector(by.sub(t), d))
            }
            t.add(_p)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        yp.copy(i.boundingSphere),
        yp.applyMatrix4(s),
        ms.copy(e.ray).recast(e.near),
        !(yp.containsPoint(ms.origin) === !1 && (ms.intersectSphere(yp, eA) === null || ms.origin.distanceToSquared(eA) > (e.far - e.near) ** 2)) && (JT.copy(s).invert(),
        ms.copy(e.ray).applyMatrix4(JT),
        !(i.boundingBox !== null && ms.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t)))
    }
    _computeIntersections(e, t) {
        let i;
        const r = this.geometry
          , s = this.material
          , o = r.index
          , a = r.attributes.position
          , l = r.attributes.uv
          , f = r.attributes.uv1
          , d = r.attributes.normal
          , h = r.groups
          , p = r.drawRange;
        if (o !== null)
            if (Array.isArray(s))
                for (let m = 0, y = h.length; m < y; m++) {
                    const S = h[m]
                      , M = s[S.materialIndex]
                      , g = Math.max(S.start, p.start)
                      , _ = Math.min(o.count, Math.min(S.start + S.count, p.start + p.count));
                    for (let w = g, T = _; w < T; w += 3) {
                        const A = o.getX(w)
                          , C = o.getX(w + 1)
                          , P = o.getX(w + 2);
                        i = Tp(this, M, e, ms, l, f, d, A, C, P),
                        i && (i.faceIndex = Math.floor(w / 3),
                        i.face.materialIndex = S.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(o.count, p.start + p.count);
                for (let S = m, M = y; S < M; S += 3) {
                    const g = o.getX(S)
                      , _ = o.getX(S + 1)
                      , w = o.getX(S + 2);
                    i = Tp(this, s, e, ms, l, f, d, g, _, w),
                    i && (i.faceIndex = Math.floor(S / 3),
                    t.push(i))
                }
            }
        else if (a !== void 0)
            if (Array.isArray(s))
                for (let m = 0, y = h.length; m < y; m++) {
                    const S = h[m]
                      , M = s[S.materialIndex]
                      , g = Math.max(S.start, p.start)
                      , _ = Math.min(a.count, Math.min(S.start + S.count, p.start + p.count));
                    for (let w = g, T = _; w < T; w += 3) {
                        const A = w
                          , C = w + 1
                          , P = w + 2;
                        i = Tp(this, M, e, ms, l, f, d, A, C, P),
                        i && (i.faceIndex = Math.floor(w / 3),
                        i.face.materialIndex = S.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const m = Math.max(0, p.start)
                  , y = Math.min(a.count, p.start + p.count);
                for (let S = m, M = y; S < M; S += 3) {
                    const g = S
                      , _ = S + 1
                      , w = S + 2;
                    i = Tp(this, s, e, ms, l, f, d, g, _, w),
                    i && (i.faceIndex = Math.floor(S / 3),
                    t.push(i))
                }
            }
    }
}
function j5(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === hi ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === Zr, a),
    l === null)
        return null;
    Ep.copy(a),
    Ep.applyMatrix4(n.matrixWorld);
    const f = t.ray.origin.distanceTo(Ep);
    return f < t.near || f > t.far ? null : {
        distance: f,
        point: Ep.clone(),
        object: n
    }
}
function Tp(n, e, t, i, r, s, o, a, l, f) {
    n.getVertexPosition(a, Hl),
    n.getVertexPosition(l, Gl),
    n.getVertexPosition(f, Wl);
    const d = j5(n, e, t, i, Hl, Gl, Wl, Mp);
    if (d) {
        r && (xp.fromBufferAttribute(r, a),
        Sp.fromBufferAttribute(r, l),
        wp.fromBufferAttribute(r, f),
        d.uv = Li.getInterpolation(Mp, Hl, Gl, Wl, xp, Sp, wp, new be)),
        s && (xp.fromBufferAttribute(s, a),
        Sp.fromBufferAttribute(s, l),
        wp.fromBufferAttribute(s, f),
        d.uv1 = Li.getInterpolation(Mp, Hl, Gl, Wl, xp, Sp, wp, new be),
        d.uv2 = d.uv1),
        o && (tA.fromBufferAttribute(o, a),
        nA.fromBufferAttribute(o, l),
        iA.fromBufferAttribute(o, f),
        d.normal = Li.getInterpolation(Mp, Hl, Gl, Wl, tA, nA, iA, new z),
        d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c: f,
            normal: new z,
            materialIndex: 0
        };
        Li.getNormal(Hl, Gl, Wl, h.normal),
        d.face = h
    }
    return d
}
class oa extends ft {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , f = []
          , d = []
          , h = [];
        let p = 0
          , m = 0;
        y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new je(f,3)),
        this.setAttribute("normal", new je(d,3)),
        this.setAttribute("uv", new je(h,2));
        function y(S, M, g, _, w, T, A, C, P, N, b) {
            const L = T / P
              , Y = A / N
              , Z = T / 2
              , $ = A / 2
              , Q = C / 2
              , ie = P + 1
              , fe = N + 1;
            let le = 0
              , D = 0;
            const j = new z;
            for (let X = 0; X < fe; X++) {
                const ue = X * Y - $;
                for (let I = 0; I < ie; I++) {
                    const U = I * L - Z;
                    j[S] = U * _,
                    j[M] = ue * w,
                    j[g] = Q,
                    f.push(j.x, j.y, j.z),
                    j[S] = 0,
                    j[M] = 0,
                    j[g] = C > 0 ? 1 : -1,
                    d.push(j.x, j.y, j.z),
                    h.push(I / P),
                    h.push(1 - X / N),
                    le += 1
                }
            }
            for (let X = 0; X < N; X++)
                for (let ue = 0; ue < P; ue++) {
                    const I = p + ue + ie * X
                      , U = p + ue + ie * (X + 1)
                      , O = p + (ue + 1) + ie * (X + 1)
                      , J = p + (ue + 1) + ie * X;
                    l.push(I, U, J),
                    l.push(U, O, J),
                    D += 6
                }
            a.addGroup(m, D, b),
            m += D,
            p += le
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new oa(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Jc(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function yi(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = Jc(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function Y5(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function zL(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : Qr
}
const BL = {
    clone: Jc,
    merge: yi
};
var q5 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , K5 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ms extends Nn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = q5,
        this.fragmentShader = K5,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Jc(e.uniforms),
        this.uniformsGroups = Y5(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class Rd extends Lt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new $e,
        this.projectionMatrix = new $e,
        this.projectionMatrixInverse = new $e
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Pn extends Rd {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Qc * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Ga * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Qc * 2 * Math.atan(Math.tan(Ga * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Ga * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , f = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * i / f,
            r *= o.width / l,
            i *= o.height / f
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Xl = -90
  , $l = 1;
class VL extends Lt {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i;
        const r = new Pn(Xl,$l,e,t);
        r.layers = this.layers,
        r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        this.add(r);
        const s = new Pn(Xl,$l,e,t);
        s.layers = this.layers,
        s.up.set(0, 1, 0),
        s.lookAt(-1, 0, 0),
        this.add(s);
        const o = new Pn(Xl,$l,e,t);
        o.layers = this.layers,
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        this.add(o);
        const a = new Pn(Xl,$l,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        this.add(a);
        const l = new Pn(Xl,$l,e,t);
        l.layers = this.layers,
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, 1),
        this.add(l);
        const f = new Pn(Xl,$l,e,t);
        f.layers = this.layers,
        f.up.set(0, 1, 0),
        f.lookAt(0, 0, -1),
        this.add(f)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const i = this.renderTarget
          , [r,s,o,a,l,f] = this.children
          , d = e.getRenderTarget()
          , h = e.toneMapping
          , p = e.xr.enabled;
        e.toneMapping = qr,
        e.xr.enabled = !1;
        const m = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0),
        e.render(t, r),
        e.setRenderTarget(i, 1),
        e.render(t, s),
        e.setRenderTarget(i, 2),
        e.render(t, o),
        e.setRenderTarget(i, 3),
        e.render(t, a),
        e.setRenderTarget(i, 4),
        e.render(t, l),
        i.texture.generateMipmaps = m,
        e.setRenderTarget(i, 5),
        e.render(t, f),
        e.setRenderTarget(d),
        e.toneMapping = h,
        e.xr.enabled = p,
        i.texture.needsPMREMUpdate = !0
    }
}
class Cd extends en {
    constructor(e, t, i, r, s, o, a, l, f, d) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Zo,
        super(e, t, i, r, s, o, a, l, f, d),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class HL extends Jr {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        t.encoding !== void 0 && (Lf("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
        t.colorSpace = t.encoding === jo ? lt : Yo),
        this.texture = new Cd(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : dn
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new oa(5,5,5)
          , s = new Ms({
            name: "CubemapFromEquirect",
            uniforms: Jc(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: hi,
            blending: Ks
        });
        s.uniforms.tEquirect.value = t;
        const o = new zn(r,s)
          , a = t.minFilter;
        return t.minFilter === ws && (t.minFilter = dn),
        new VL(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Py = new z
  , Z5 = new z
  , Q5 = new Rt;
class bo {
    constructor(e=new z(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Py.subVectors(i, t).cross(Z5.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Py)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || Q5.getNormalMatrix(e)
          , r = this.coplanarPoint(Py).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const xa = new ns
  , Ap = new z;
class p0 {
    constructor(e=new bo, t=new bo, i=new bo, r=new bo, s=new bo, o=new bo) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , i = e.elements
          , r = i[0]
          , s = i[1]
          , o = i[2]
          , a = i[3]
          , l = i[4]
          , f = i[5]
          , d = i[6]
          , h = i[7]
          , p = i[8]
          , m = i[9]
          , y = i[10]
          , S = i[11]
          , M = i[12]
          , g = i[13]
          , _ = i[14]
          , w = i[15];
        return t[0].setComponents(a - r, h - l, S - p, w - M).normalize(),
        t[1].setComponents(a + r, h + l, S + p, w + M).normalize(),
        t[2].setComponents(a + s, h + f, S + m, w + g).normalize(),
        t[3].setComponents(a - s, h - f, S - m, w - g).normalize(),
        t[4].setComponents(a - o, h - d, S - y, w - _).normalize(),
        t[5].setComponents(a + o, h + d, S + y, w + _).normalize(),
        this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            xa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            xa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(xa)
    }
    intersectsSprite(e) {
        return xa.center.set(0, 0, 0),
        xa.radius = .7071067811865476,
        xa.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(xa)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Ap.x = r.normal.x > 0 ? e.max.x : e.min.x,
            Ap.y = r.normal.y > 0 ? e.max.y : e.min.y,
            Ap.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(Ap) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function GL() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function J5(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(f, d) {
        const h = f.array
          , p = f.usage
          , m = n.createBuffer();
        n.bindBuffer(d, m),
        n.bufferData(d, h, p),
        f.onUploadCallback();
        let y;
        if (h instanceof Float32Array)
            y = n.FLOAT;
        else if (h instanceof Uint16Array)
            if (f.isFloat16BufferAttribute)
                if (t)
                    y = n.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                y = n.UNSIGNED_SHORT;
        else if (h instanceof Int16Array)
            y = n.SHORT;
        else if (h instanceof Uint32Array)
            y = n.UNSIGNED_INT;
        else if (h instanceof Int32Array)
            y = n.INT;
        else if (h instanceof Int8Array)
            y = n.BYTE;
        else if (h instanceof Uint8Array)
            y = n.UNSIGNED_BYTE;
        else if (h instanceof Uint8ClampedArray)
            y = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: m,
            type: y,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: f.version
        }
    }
    function s(f, d, h) {
        const p = d.array
          , m = d.updateRange;
        n.bindBuffer(h, f),
        m.count === -1 ? n.bufferSubData(h, 0, p) : (t ? n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)),
        m.count = -1),
        d.onUploadCallback()
    }
    function o(f) {
        return f.isInterleavedBufferAttribute && (f = f.data),
        i.get(f)
    }
    function a(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const d = i.get(f);
        d && (n.deleteBuffer(d.buffer),
        i.delete(f))
    }
    function l(f, d) {
        if (f.isGLBufferAttribute) {
            const p = i.get(f);
            (!p || p.version < f.version) && i.set(f, {
                buffer: f.buffer,
                type: f.type,
                bytesPerElement: f.elementSize,
                version: f.version
            });
            return
        }
        f.isInterleavedBufferAttribute && (f = f.data);
        const h = i.get(f);
        h === void 0 ? i.set(f, r(f, d)) : h.version < f.version && (s(h.buffer, f, d),
        h.version = f.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class cu extends ft {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , f = a + 1
          , d = l + 1
          , h = e / a
          , p = t / l
          , m = []
          , y = []
          , S = []
          , M = [];
        for (let g = 0; g < d; g++) {
            const _ = g * p - o;
            for (let w = 0; w < f; w++) {
                const T = w * h - s;
                y.push(T, -_, 0),
                S.push(0, 0, 1),
                M.push(w / a),
                M.push(1 - g / l)
            }
        }
        for (let g = 0; g < l; g++)
            for (let _ = 0; _ < a; _++) {
                const w = _ + f * g
                  , T = _ + f * (g + 1)
                  , A = _ + 1 + f * (g + 1)
                  , C = _ + 1 + f * g;
                m.push(w, T, C),
                m.push(T, A, C)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(S,3)),
        this.setAttribute("uv", new je(M,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new cu(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var eG = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , tG = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , nG = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , iG = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , rG = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , sG = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , oG = "vec3 transformed = vec3( position );"
  , aG = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , lG = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , cG = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , uG = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , fG = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , dG = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , hG = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , pG = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , mG = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , gG = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , vG = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , yG = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , _G = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , xG = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , SG = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , wG = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , MG = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , EG = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , TG = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , AG = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , RG = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , CG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , bG = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , PG = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , LG = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , IG = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , NG = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , DG = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , UG = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , kG = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , OG = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , FG = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , zG = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , BG = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , VG = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , HG = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , GG = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , WG = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , XG = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , $G = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , jG = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , YG = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`
  , qG = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , KG = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , ZG = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , QG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , JG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , eW = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , tW = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , nW = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , iW = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`
  , rW = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , sW = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , oW = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , aW = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , lW = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , cW = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , uW = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , fW = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , dW = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , hW = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`
  , pW = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , mW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , gW = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , vW = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , yW = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , _W = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , xW = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , SW = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , wW = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , MW = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , EW = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , TW = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , AW = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , RW = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , CW = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , bW = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , PW = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , LW = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , IW = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , NW = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , DW = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , UW = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , kW = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , OW = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , FW = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , zW = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , BW = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , VW = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , HW = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , GW = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
  , WW = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , XW = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , $W = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , jW = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , YW = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const qW = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , KW = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , ZW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , QW = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , JW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , e8 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , t8 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , n8 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , i8 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , r8 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , s8 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , o8 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , a8 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , l8 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , c8 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , u8 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , f8 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , d8 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , h8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , p8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , m8 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , g8 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , v8 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , y8 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , _8 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , x8 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , S8 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , w8 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , M8 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , E8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , T8 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , A8 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , R8 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , C8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , _t = {
    alphamap_fragment: eG,
    alphamap_pars_fragment: tG,
    alphatest_fragment: nG,
    alphatest_pars_fragment: iG,
    aomap_fragment: rG,
    aomap_pars_fragment: sG,
    begin_vertex: oG,
    beginnormal_vertex: aG,
    bsdfs: lG,
    iridescence_fragment: cG,
    bumpmap_pars_fragment: uG,
    clipping_planes_fragment: fG,
    clipping_planes_pars_fragment: dG,
    clipping_planes_pars_vertex: hG,
    clipping_planes_vertex: pG,
    color_fragment: mG,
    color_pars_fragment: gG,
    color_pars_vertex: vG,
    color_vertex: yG,
    common: _G,
    cube_uv_reflection_fragment: xG,
    defaultnormal_vertex: SG,
    displacementmap_pars_vertex: wG,
    displacementmap_vertex: MG,
    emissivemap_fragment: EG,
    emissivemap_pars_fragment: TG,
    encodings_fragment: AG,
    encodings_pars_fragment: RG,
    envmap_fragment: CG,
    envmap_common_pars_fragment: bG,
    envmap_pars_fragment: PG,
    envmap_pars_vertex: LG,
    envmap_physical_pars_fragment: GG,
    envmap_vertex: IG,
    fog_vertex: NG,
    fog_pars_vertex: DG,
    fog_fragment: UG,
    fog_pars_fragment: kG,
    gradientmap_pars_fragment: OG,
    lightmap_fragment: FG,
    lightmap_pars_fragment: zG,
    lights_lambert_fragment: BG,
    lights_lambert_pars_fragment: VG,
    lights_pars_begin: HG,
    lights_toon_fragment: WG,
    lights_toon_pars_fragment: XG,
    lights_phong_fragment: $G,
    lights_phong_pars_fragment: jG,
    lights_physical_fragment: YG,
    lights_physical_pars_fragment: qG,
    lights_fragment_begin: KG,
    lights_fragment_maps: ZG,
    lights_fragment_end: QG,
    logdepthbuf_fragment: JG,
    logdepthbuf_pars_fragment: eW,
    logdepthbuf_pars_vertex: tW,
    logdepthbuf_vertex: nW,
    map_fragment: iW,
    map_pars_fragment: rW,
    map_particle_fragment: sW,
    map_particle_pars_fragment: oW,
    metalnessmap_fragment: aW,
    metalnessmap_pars_fragment: lW,
    morphcolor_vertex: cW,
    morphnormal_vertex: uW,
    morphtarget_pars_vertex: fW,
    morphtarget_vertex: dW,
    normal_fragment_begin: hW,
    normal_fragment_maps: pW,
    normal_pars_fragment: mW,
    normal_pars_vertex: gW,
    normal_vertex: vW,
    normalmap_pars_fragment: yW,
    clearcoat_normal_fragment_begin: _W,
    clearcoat_normal_fragment_maps: xW,
    clearcoat_pars_fragment: SW,
    iridescence_pars_fragment: wW,
    output_fragment: MW,
    packing: EW,
    premultiplied_alpha_fragment: TW,
    project_vertex: AW,
    dithering_fragment: RW,
    dithering_pars_fragment: CW,
    roughnessmap_fragment: bW,
    roughnessmap_pars_fragment: PW,
    shadowmap_pars_fragment: LW,
    shadowmap_pars_vertex: IW,
    shadowmap_vertex: NW,
    shadowmask_pars_fragment: DW,
    skinbase_vertex: UW,
    skinning_pars_vertex: kW,
    skinning_vertex: OW,
    skinnormal_vertex: FW,
    specularmap_fragment: zW,
    specularmap_pars_fragment: BW,
    tonemapping_fragment: VW,
    tonemapping_pars_fragment: HW,
    transmission_fragment: GW,
    transmission_pars_fragment: WW,
    uv_pars_fragment: XW,
    uv_pars_vertex: $W,
    uv_vertex: jW,
    worldpos_vertex: YW,
    background_vert: qW,
    background_frag: KW,
    backgroundCube_vert: ZW,
    backgroundCube_frag: QW,
    cube_vert: JW,
    cube_frag: e8,
    depth_vert: t8,
    depth_frag: n8,
    distanceRGBA_vert: i8,
    distanceRGBA_frag: r8,
    equirect_vert: s8,
    equirect_frag: o8,
    linedashed_vert: a8,
    linedashed_frag: l8,
    meshbasic_vert: c8,
    meshbasic_frag: u8,
    meshlambert_vert: f8,
    meshlambert_frag: d8,
    meshmatcap_vert: h8,
    meshmatcap_frag: p8,
    meshnormal_vert: m8,
    meshnormal_frag: g8,
    meshphong_vert: v8,
    meshphong_frag: y8,
    meshphysical_vert: _8,
    meshphysical_frag: x8,
    meshtoon_vert: S8,
    meshtoon_frag: w8,
    points_vert: M8,
    points_frag: E8,
    shadow_vert: T8,
    shadow_frag: A8,
    sprite_vert: R8,
    sprite_frag: C8
}
  , ze = {
    common: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Rt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Rt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new Rt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new Rt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new Rt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new Rt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new Rt
        },
        normalScale: {
            value: new be(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new Rt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new Rt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new Rt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new Rt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Oe(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Rt
        }
    },
    sprite: {
        diffuse: {
            value: new Oe(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new be(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Rt
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Xr = {
    basic: {
        uniforms: yi([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.fog]),
        vertexShader: _t.meshbasic_vert,
        fragmentShader: _t.meshbasic_frag
    },
    lambert: {
        uniforms: yi([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.fog, ze.lights, {
            emissive: {
                value: new Oe(0)
            }
        }]),
        vertexShader: _t.meshlambert_vert,
        fragmentShader: _t.meshlambert_frag
    },
    phong: {
        uniforms: yi([ze.common, ze.specularmap, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.fog, ze.lights, {
            emissive: {
                value: new Oe(0)
            },
            specular: {
                value: new Oe(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: _t.meshphong_vert,
        fragmentShader: _t.meshphong_frag
    },
    standard: {
        uniforms: yi([ze.common, ze.envmap, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.roughnessmap, ze.metalnessmap, ze.fog, ze.lights, {
            emissive: {
                value: new Oe(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: _t.meshphysical_vert,
        fragmentShader: _t.meshphysical_frag
    },
    toon: {
        uniforms: yi([ze.common, ze.aomap, ze.lightmap, ze.emissivemap, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.gradientmap, ze.fog, ze.lights, {
            emissive: {
                value: new Oe(0)
            }
        }]),
        vertexShader: _t.meshtoon_vert,
        fragmentShader: _t.meshtoon_frag
    },
    matcap: {
        uniforms: yi([ze.common, ze.bumpmap, ze.normalmap, ze.displacementmap, ze.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: _t.meshmatcap_vert,
        fragmentShader: _t.meshmatcap_frag
    },
    points: {
        uniforms: yi([ze.points, ze.fog]),
        vertexShader: _t.points_vert,
        fragmentShader: _t.points_frag
    },
    dashed: {
        uniforms: yi([ze.common, ze.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: _t.linedashed_vert,
        fragmentShader: _t.linedashed_frag
    },
    depth: {
        uniforms: yi([ze.common, ze.displacementmap]),
        vertexShader: _t.depth_vert,
        fragmentShader: _t.depth_frag
    },
    normal: {
        uniforms: yi([ze.common, ze.bumpmap, ze.normalmap, ze.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: _t.meshnormal_vert,
        fragmentShader: _t.meshnormal_frag
    },
    sprite: {
        uniforms: yi([ze.sprite, ze.fog]),
        vertexShader: _t.sprite_vert,
        fragmentShader: _t.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Rt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: _t.background_vert,
        fragmentShader: _t.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: _t.backgroundCube_vert,
        fragmentShader: _t.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: _t.cube_vert,
        fragmentShader: _t.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: _t.equirect_vert,
        fragmentShader: _t.equirect_frag
    },
    distanceRGBA: {
        uniforms: yi([ze.common, ze.displacementmap, {
            referencePosition: {
                value: new z
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: _t.distanceRGBA_vert,
        fragmentShader: _t.distanceRGBA_frag
    },
    shadow: {
        uniforms: yi([ze.lights, ze.fog, {
            color: {
                value: new Oe(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: _t.shadow_vert,
        fragmentShader: _t.shadow_frag
    }
};
Xr.physical = {
    uniforms: yi([Xr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Rt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Rt
        },
        clearcoatNormalScale: {
            value: new be(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Rt
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Rt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Rt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Oe(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Rt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Rt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Rt
        },
        transmissionSamplerSize: {
            value: new be
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Rt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Oe(0)
        },
        specularColor: {
            value: new Oe(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Rt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Rt
        }
    }]),
    vertexShader: _t.meshphysical_vert,
    fragmentShader: _t.meshphysical_frag
};
const Rp = {
    r: 0,
    b: 0,
    g: 0
};
function b8(n, e, t, i, r, s, o) {
    const a = new Oe(0);
    let l = s === !0 ? 0 : 1, f, d, h = null, p = 0, m = null;
    function y(M, g) {
        let _ = !1
          , w = g.isScene === !0 ? g.background : null;
        switch (w && w.isTexture && (w = (g.backgroundBlurriness > 0 ? t : e).get(w)),
        w === null ? S(a, l) : w && w.isColor && (S(w, 1),
        _ = !0),
        n.xr.getEnvironmentBlendMode()) {
        case "opaque":
            _ = !0;
            break;
        case "additive":
            i.buffers.color.setClear(0, 0, 0, 1, o),
            _ = !0;
            break;
        case "alpha-blend":
            i.buffers.color.setClear(0, 0, 0, 0, o),
            _ = !0;
            break
        }
        (n.autoClear || _) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        w && (w.isCubeTexture || w.mapping === lu) ? (d === void 0 && (d = new zn(new oa(1,1,1),new Ms({
            name: "BackgroundCubeMaterial",
            uniforms: Jc(Xr.backgroundCube.uniforms),
            vertexShader: Xr.backgroundCube.vertexShader,
            fragmentShader: Xr.backgroundCube.fragmentShader,
            side: hi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        d.geometry.deleteAttribute("normal"),
        d.geometry.deleteAttribute("uv"),
        d.onBeforeRender = function(C, P, N) {
            this.matrixWorld.copyPosition(N.matrixWorld)
        }
        ,
        Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(d)),
        d.material.uniforms.envMap.value = w,
        d.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        d.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness,
        d.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        d.material.toneMapped = w.colorSpace !== lt,
        (h !== w || p !== w.version || m !== n.toneMapping) && (d.material.needsUpdate = !0,
        h = w,
        p = w.version,
        m = n.toneMapping),
        d.layers.enableAll(),
        M.unshift(d, d.geometry, d.material, 0, 0, null)) : w && w.isTexture && (f === void 0 && (f = new zn(new cu(2,2),new Ms({
            name: "BackgroundMaterial",
            uniforms: Jc(Xr.background.uniforms),
            vertexShader: Xr.background.vertexShader,
            fragmentShader: Xr.background.fragmentShader,
            side: Zr,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        f.geometry.deleteAttribute("normal"),
        Object.defineProperty(f.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(f)),
        f.material.uniforms.t2D.value = w,
        f.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        f.material.toneMapped = w.colorSpace !== lt,
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        f.material.uniforms.uvTransform.value.copy(w.matrix),
        (h !== w || p !== w.version || m !== n.toneMapping) && (f.material.needsUpdate = !0,
        h = w,
        p = w.version,
        m = n.toneMapping),
        f.layers.enableAll(),
        M.unshift(f, f.geometry, f.material, 0, 0, null))
    }
    function S(M, g) {
        M.getRGB(Rp, zL(n)),
        i.buffers.color.setClear(Rp.r, Rp.g, Rp.b, g, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(M, g=1) {
            a.set(M),
            l = g,
            S(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(M) {
            l = M,
            S(a, l)
        },
        render: y
    }
}
function P8(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , l = M(null);
    let f = l
      , d = !1;
    function h(Q, ie, fe, le, D) {
        let j = !1;
        if (o) {
            const X = S(le, fe, ie);
            f !== X && (f = X,
            m(f.object)),
            j = g(Q, le, fe, D),
            j && _(Q, le, fe, D)
        } else {
            const X = ie.wireframe === !0;
            (f.geometry !== le.id || f.program !== fe.id || f.wireframe !== X) && (f.geometry = le.id,
            f.program = fe.id,
            f.wireframe = X,
            j = !0)
        }
        D !== null && t.update(D, n.ELEMENT_ARRAY_BUFFER),
        (j || d) && (d = !1,
        N(Q, ie, fe, le),
        D !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(D).buffer))
    }
    function p() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function m(Q) {
        return i.isWebGL2 ? n.bindVertexArray(Q) : s.bindVertexArrayOES(Q)
    }
    function y(Q) {
        return i.isWebGL2 ? n.deleteVertexArray(Q) : s.deleteVertexArrayOES(Q)
    }
    function S(Q, ie, fe) {
        const le = fe.wireframe === !0;
        let D = a[Q.id];
        D === void 0 && (D = {},
        a[Q.id] = D);
        let j = D[ie.id];
        j === void 0 && (j = {},
        D[ie.id] = j);
        let X = j[le];
        return X === void 0 && (X = M(p()),
        j[le] = X),
        X
    }
    function M(Q) {
        const ie = []
          , fe = []
          , le = [];
        for (let D = 0; D < r; D++)
            ie[D] = 0,
            fe[D] = 0,
            le[D] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: ie,
            enabledAttributes: fe,
            attributeDivisors: le,
            object: Q,
            attributes: {},
            index: null
        }
    }
    function g(Q, ie, fe, le) {
        const D = f.attributes
          , j = ie.attributes;
        let X = 0;
        const ue = fe.getAttributes();
        for (const I in ue)
            if (ue[I].location >= 0) {
                const O = D[I];
                let J = j[I];
                if (J === void 0 && (I === "instanceMatrix" && Q.instanceMatrix && (J = Q.instanceMatrix),
                I === "instanceColor" && Q.instanceColor && (J = Q.instanceColor)),
                O === void 0 || O.attribute !== J || J && O.data !== J.data)
                    return !0;
                X++
            }
        return f.attributesNum !== X || f.index !== le
    }
    function _(Q, ie, fe, le) {
        const D = {}
          , j = ie.attributes;
        let X = 0;
        const ue = fe.getAttributes();
        for (const I in ue)
            if (ue[I].location >= 0) {
                let O = j[I];
                O === void 0 && (I === "instanceMatrix" && Q.instanceMatrix && (O = Q.instanceMatrix),
                I === "instanceColor" && Q.instanceColor && (O = Q.instanceColor));
                const J = {};
                J.attribute = O,
                O && O.data && (J.data = O.data),
                D[I] = J,
                X++
            }
        f.attributes = D,
        f.attributesNum = X,
        f.index = le
    }
    function w() {
        const Q = f.newAttributes;
        for (let ie = 0, fe = Q.length; ie < fe; ie++)
            Q[ie] = 0
    }
    function T(Q) {
        A(Q, 0)
    }
    function A(Q, ie) {
        const fe = f.newAttributes
          , le = f.enabledAttributes
          , D = f.attributeDivisors;
        fe[Q] = 1,
        le[Q] === 0 && (n.enableVertexAttribArray(Q),
        le[Q] = 1),
        D[Q] !== ie && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Q, ie),
        D[Q] = ie)
    }
    function C() {
        const Q = f.newAttributes
          , ie = f.enabledAttributes;
        for (let fe = 0, le = ie.length; fe < le; fe++)
            ie[fe] !== Q[fe] && (n.disableVertexAttribArray(fe),
            ie[fe] = 0)
    }
    function P(Q, ie, fe, le, D, j) {
        i.isWebGL2 === !0 && (fe === n.INT || fe === n.UNSIGNED_INT) ? n.vertexAttribIPointer(Q, ie, fe, D, j) : n.vertexAttribPointer(Q, ie, fe, le, D, j)
    }
    function N(Q, ie, fe, le) {
        if (i.isWebGL2 === !1 && (Q.isInstancedMesh || le.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        w();
        const D = le.attributes
          , j = fe.getAttributes()
          , X = ie.defaultAttributeValues;
        for (const ue in j) {
            const I = j[ue];
            if (I.location >= 0) {
                let U = D[ue];
                if (U === void 0 && (ue === "instanceMatrix" && Q.instanceMatrix && (U = Q.instanceMatrix),
                ue === "instanceColor" && Q.instanceColor && (U = Q.instanceColor)),
                U !== void 0) {
                    const O = U.normalized
                      , J = U.itemSize
                      , F = t.get(U);
                    if (F === void 0)
                        continue;
                    const B = F.buffer
                      , ae = F.type
                      , _e = F.bytesPerElement;
                    if (U.isInterleavedBufferAttribute) {
                        const pe = U.data
                          , Ee = pe.stride
                          , se = U.offset;
                        if (pe.isInstancedInterleavedBuffer) {
                            for (let oe = 0; oe < I.locationSize; oe++)
                                A(I.location + oe, pe.meshPerAttribute);
                            Q.isInstancedMesh !== !0 && le._maxInstanceCount === void 0 && (le._maxInstanceCount = pe.meshPerAttribute * pe.count)
                        } else
                            for (let oe = 0; oe < I.locationSize; oe++)
                                T(I.location + oe);
                        n.bindBuffer(n.ARRAY_BUFFER, B);
                        for (let oe = 0; oe < I.locationSize; oe++)
                            P(I.location + oe, J / I.locationSize, ae, O, Ee * _e, (se + J / I.locationSize * oe) * _e)
                    } else {
                        if (U.isInstancedBufferAttribute) {
                            for (let pe = 0; pe < I.locationSize; pe++)
                                A(I.location + pe, U.meshPerAttribute);
                            Q.isInstancedMesh !== !0 && le._maxInstanceCount === void 0 && (le._maxInstanceCount = U.meshPerAttribute * U.count)
                        } else
                            for (let pe = 0; pe < I.locationSize; pe++)
                                T(I.location + pe);
                        n.bindBuffer(n.ARRAY_BUFFER, B);
                        for (let pe = 0; pe < I.locationSize; pe++)
                            P(I.location + pe, J / I.locationSize, ae, O, J * _e, J / I.locationSize * pe * _e)
                    }
                } else if (X !== void 0) {
                    const O = X[ue];
                    if (O !== void 0)
                        switch (O.length) {
                        case 2:
                            n.vertexAttrib2fv(I.location, O);
                            break;
                        case 3:
                            n.vertexAttrib3fv(I.location, O);
                            break;
                        case 4:
                            n.vertexAttrib4fv(I.location, O);
                            break;
                        default:
                            n.vertexAttrib1fv(I.location, O)
                        }
                }
            }
        }
        C()
    }
    function b() {
        Z();
        for (const Q in a) {
            const ie = a[Q];
            for (const fe in ie) {
                const le = ie[fe];
                for (const D in le)
                    y(le[D].object),
                    delete le[D];
                delete ie[fe]
            }
            delete a[Q]
        }
    }
    function L(Q) {
        if (a[Q.id] === void 0)
            return;
        const ie = a[Q.id];
        for (const fe in ie) {
            const le = ie[fe];
            for (const D in le)
                y(le[D].object),
                delete le[D];
            delete ie[fe]
        }
        delete a[Q.id]
    }
    function Y(Q) {
        for (const ie in a) {
            const fe = a[ie];
            if (fe[Q.id] === void 0)
                continue;
            const le = fe[Q.id];
            for (const D in le)
                y(le[D].object),
                delete le[D];
            delete fe[Q.id]
        }
    }
    function Z() {
        $(),
        d = !0,
        f !== l && (f = l,
        m(f.object))
    }
    function $() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: h,
        reset: Z,
        resetDefaultState: $,
        dispose: b,
        releaseStatesOfGeometry: L,
        releaseStatesOfProgram: Y,
        initAttributes: w,
        enableAttribute: T,
        disableUnusedAttributes: C
    }
}
function L8(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(f) {
        s = f
    }
    function a(f, d) {
        n.drawArrays(s, f, d),
        t.update(d, s, 1)
    }
    function l(f, d, h) {
        if (h === 0)
            return;
        let p, m;
        if (r)
            p = n,
            m = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[m](s, f, d, h),
        t.update(d, s, h)
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l
}
function I8(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const P = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(P) {
        if (P === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            P = "mediump"
        }
        return P === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const f = o || e.has("WEBGL_draw_buffers")
      , d = t.logarithmicDepthBuffer === !0
      , h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , m = n.getParameter(n.MAX_TEXTURE_SIZE)
      , y = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , S = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , M = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , g = n.getParameter(n.MAX_VARYING_VECTORS)
      , _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , w = p > 0
      , T = o || e.has("OES_texture_float")
      , A = w && T
      , C = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: f,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: h,
        maxVertexTextures: p,
        maxTextureSize: m,
        maxCubemapSize: y,
        maxAttributes: S,
        maxVertexUniforms: M,
        maxVaryings: g,
        maxFragmentUniforms: _,
        vertexTextures: w,
        floatFragmentTextures: T,
        floatVertexTextures: A,
        maxSamples: C
    }
}
function N8(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new bo
      , a = new Rt
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, p) {
        const m = h.length !== 0 || p || i !== 0 || r;
        return r = p,
        i = h.length,
        m
    }
    ,
    this.beginShadows = function() {
        s = !0,
        d(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, p) {
        t = d(h, p, 0)
    }
    ,
    this.setState = function(h, p, m) {
        const y = h.clippingPlanes
          , S = h.clipIntersection
          , M = h.clipShadows
          , g = n.get(h);
        if (!r || y === null || y.length === 0 || s && !M)
            s ? d(null) : f();
        else {
            const _ = s ? 0 : i
              , w = _ * 4;
            let T = g.clippingState || null;
            l.value = T,
            T = d(y, p, w, m);
            for (let A = 0; A !== w; ++A)
                T[A] = t[A];
            g.clippingState = T,
            this.numIntersection = S ? this.numPlanes : 0,
            this.numPlanes += _
        }
    }
    ;
    function f() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function d(h, p, m, y) {
        const S = h !== null ? h.length : 0;
        let M = null;
        if (S !== 0) {
            if (M = l.value,
            y !== !0 || M === null) {
                const g = m + S * 4
                  , _ = p.matrixWorldInverse;
                a.getNormalMatrix(_),
                (M === null || M.length < g) && (M = new Float32Array(g));
                for (let w = 0, T = m; w !== S; ++w,
                T += 4)
                    o.copy(h[w]).applyMatrix4(_, a),
                    o.normal.toArray(M, T),
                    M[T + 3] = o.constant
            }
            l.value = M,
            l.needsUpdate = !0
        }
        return e.numPlanes = S,
        e.numIntersection = 0,
        M
    }
}
function D8(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === Yc ? o.mapping = Zo : a === ed && (o.mapping = Qo),
        o
    }
    function i(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === Yc || a === ed)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const f = new HL(l.height / 2);
                        return f.fromEquirectangularTexture(n, o),
                        e.set(o, f),
                        o.addEventListener("dispose", r),
                        t(f.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class dl extends Rd {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const f = (this.right - this.left) / this.view.fullWidth / this.zoom
              , d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += f * this.view.offsetX,
            o = s + f * this.view.width,
            a -= d * this.view.offsetY,
            l = a - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const _c = 4
  , rA = [.125, .215, .35, .446, .526, .582]
  , La = 20
  , Ly = new dl
  , sA = new Oe;
let Iy = null;
const Ca = (1 + Math.sqrt(5)) / 2
  , jl = 1 / Ca
  , oA = [new z(1,1,1), new z(-1,1,1), new z(1,1,-1), new z(-1,1,-1), new z(0,Ca,jl), new z(0,Ca,-jl), new z(jl,0,Ca), new z(-jl,0,Ca), new z(Ca,jl,0), new z(-Ca,jl,0)];
class Yx {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        Iy = this._renderer.getRenderTarget(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = cA(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = lA(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Iy),
        e.scissorTest = !1,
        Cp(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Zo || e.mapping === Qo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Iy = this._renderer.getRenderTarget();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: dn,
            minFilter: dn,
            generateMipmaps: !1,
            type: Kc,
            format: Ii,
            colorSpace: Qr,
            depthBuffer: !1
        }
          , r = aA(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = aA(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = U8(s)),
            this._blurMaterial = k8(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new zn(this._lodPlanes[0],e);
        this._renderer.compile(t, Ly)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Pn(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , f = [1, 1, 1, -1, -1, -1]
          , d = this._renderer
          , h = d.autoClear
          , p = d.toneMapping;
        d.getClearColor(sA),
        d.toneMapping = qr,
        d.autoClear = !1;
        const m = new Ki({
            name: "PMREM.Background",
            side: hi,
            depthWrite: !1,
            depthTest: !1
        })
          , y = new zn(new oa,m);
        let S = !1;
        const M = e.background;
        M ? M.isColor && (m.color.copy(M),
        e.background = null,
        S = !0) : (m.color.copy(sA),
        S = !0);
        for (let g = 0; g < 6; g++) {
            const _ = g % 3;
            _ === 0 ? (a.up.set(0, l[g], 0),
            a.lookAt(f[g], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[g]),
            a.lookAt(0, f[g], 0)) : (a.up.set(0, l[g], 0),
            a.lookAt(0, 0, f[g]));
            const w = this._cubeSize;
            Cp(r, _ * w, g > 2 ? w : 0, w, w),
            d.setRenderTarget(r),
            S && d.render(y, a),
            d.render(e, a)
        }
        y.geometry.dispose(),
        y.material.dispose(),
        d.toneMapping = p,
        d.autoClear = h,
        e.background = M
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === Zo || e.mapping === Qo;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = cA()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = lA());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new zn(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Cp(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, Ly)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = oA[(r - 1) % oA.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer
          , f = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3
          , h = new zn(this._lodPlanes[r],f)
          , p = f.uniforms
          , m = this._sizeLods[i] - 1
          , y = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * La - 1)
          , S = s / y
          , M = isFinite(s) ? 1 + Math.floor(d * S) : La;
        M > La && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${La}`);
        const g = [];
        let _ = 0;
        for (let P = 0; P < La; ++P) {
            const N = P / S
              , b = Math.exp(-N * N / 2);
            g.push(b),
            P === 0 ? _ += b : P < M && (_ += 2 * b)
        }
        for (let P = 0; P < g.length; P++)
            g[P] = g[P] / _;
        p.envMap.value = e.texture,
        p.samples.value = M,
        p.weights.value = g,
        p.latitudinal.value = o === "latitudinal",
        a && (p.poleAxis.value = a);
        const {_lodMax: w} = this;
        p.dTheta.value = y,
        p.mipInt.value = w - i;
        const T = this._sizeLods[r]
          , A = 3 * T * (r > w - _c ? r - w + _c : 0)
          , C = 4 * (this._cubeSize - T);
        Cp(t, A, C, 3 * T, 2 * T),
        l.setRenderTarget(t),
        l.render(h, Ly)
    }
}
function U8(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - _c + 1 + rA.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - _c ? l = rA[o - n + _c - 1] : o === 0 && (l = 0),
        i.push(l);
        const f = 1 / (a - 2)
          , d = -f
          , h = 1 + f
          , p = [d, d, h, d, h, h, d, d, h, h, d, h]
          , m = 6
          , y = 6
          , S = 3
          , M = 2
          , g = 1
          , _ = new Float32Array(S * y * m)
          , w = new Float32Array(M * y * m)
          , T = new Float32Array(g * y * m);
        for (let C = 0; C < m; C++) {
            const P = C % 3 * 2 / 3 - 1
              , N = C > 2 ? 0 : -1
              , b = [P, N, 0, P + 2 / 3, N, 0, P + 2 / 3, N + 1, 0, P, N, 0, P + 2 / 3, N + 1, 0, P, N + 1, 0];
            _.set(b, S * y * C),
            w.set(p, M * y * C);
            const L = [C, C, C, C, C, C];
            T.set(L, g * y * C)
        }
        const A = new ft;
        A.setAttribute("position", new Ht(_,S)),
        A.setAttribute("uv", new Ht(w,M)),
        A.setAttribute("faceIndex", new Ht(T,g)),
        e.push(A),
        r > _c && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function aA(n, e, t) {
    const i = new Jr(n,e,t);
    return i.texture.mapping = lu,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Cp(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function k8(n, e, t) {
    const i = new Float32Array(La)
      , r = new z(0,1,0);
    return new Ms({
        name: "SphericalGaussianBlur",
        defines: {
            n: La,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: H1(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Ks,
        depthTest: !1,
        depthWrite: !1
    })
}
function lA() {
    return new Ms({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: H1(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Ks,
        depthTest: !1,
        depthWrite: !1
    })
}
function cA() {
    return new Ms({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: H1(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Ks,
        depthTest: !1,
        depthWrite: !1
    })
}
function H1() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function O8(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , f = l === Yc || l === ed
              , d = l === Zo || l === Qo;
            if (f || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new Yx(n)),
                    h = f ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    e.set(a, h),
                    h.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const h = a.image;
                        if (f && h && h.height > 0 || d && h && r(h)) {
                            t === null && (t = new Yx(n));
                            const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p),
                            a.addEventListener("dispose", s),
                            p.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const f = 6;
        for (let d = 0; d < f; d++)
            a[d] !== void 0 && l++;
        return l === f
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const f = e.get(l);
        f !== void 0 && (e.delete(l),
        f.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function F8(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function z8(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const p = h.target;
        p.index !== null && e.remove(p.index);
        for (const y in p.attributes)
            e.remove(p.attributes[y]);
        p.removeEventListener("dispose", o),
        delete r[p.id];
        const m = s.get(p);
        m && (e.remove(m),
        s.delete(p)),
        i.releaseStatesOfGeometry(p),
        p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, p) {
        return r[p.id] === !0 || (p.addEventListener("dispose", o),
        r[p.id] = !0,
        t.memory.geometries++),
        p
    }
    function l(h) {
        const p = h.attributes;
        for (const y in p)
            e.update(p[y], n.ARRAY_BUFFER);
        const m = h.morphAttributes;
        for (const y in m) {
            const S = m[y];
            for (let M = 0, g = S.length; M < g; M++)
                e.update(S[M], n.ARRAY_BUFFER)
        }
    }
    function f(h) {
        const p = []
          , m = h.index
          , y = h.attributes.position;
        let S = 0;
        if (m !== null) {
            const _ = m.array;
            S = m.version;
            for (let w = 0, T = _.length; w < T; w += 3) {
                const A = _[w + 0]
                  , C = _[w + 1]
                  , P = _[w + 2];
                p.push(A, C, C, P, P, A)
            }
        } else {
            const _ = y.array;
            S = y.version;
            for (let w = 0, T = _.length / 3 - 1; w < T; w += 3) {
                const A = w + 0
                  , C = w + 1
                  , P = w + 2;
                p.push(A, C, C, P, P, A)
            }
        }
        const M = new (OL(p) ? V1 : h0)(p,1);
        M.version = S;
        const g = s.get(h);
        g && e.remove(g),
        s.set(h, M)
    }
    function d(h) {
        const p = s.get(h);
        if (p) {
            const m = h.index;
            m !== null && p.version < m.version && f(h)
        } else
            f(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: d
    }
}
function B8(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(p) {
        s = p
    }
    let a, l;
    function f(p) {
        a = p.type,
        l = p.bytesPerElement
    }
    function d(p, m) {
        n.drawElements(s, m, a, p * l),
        t.update(m, s, 1)
    }
    function h(p, m, y) {
        if (y === 0)
            return;
        let S, M;
        if (r)
            S = n,
            M = "drawElementsInstanced";
        else if (S = e.get("ANGLE_instanced_arrays"),
        M = "drawElementsInstancedANGLE",
        S === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        S[M](s, m, a, p * l, y),
        t.update(m, s, y)
    }
    this.setMode = o,
    this.setIndex = f,
    this.render = d,
    this.renderInstances = h
}
function V8(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function H8(n, e) {
    return n[0] - e[0]
}
function G8(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function W8(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new Ut
      , a = [];
    for (let f = 0; f < 8; f++)
        a[f] = [f, 0];
    function l(f, d, h) {
        const p = f.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const y = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color
              , S = y !== void 0 ? y.length : 0;
            let M = s.get(d);
            if (M === void 0 || M.count !== S) {
                let ie = function() {
                    $.dispose(),
                    s.delete(d),
                    d.removeEventListener("dispose", ie)
                };
                var m = ie;
                M !== void 0 && M.texture.dispose();
                const w = d.morphAttributes.position !== void 0
                  , T = d.morphAttributes.normal !== void 0
                  , A = d.morphAttributes.color !== void 0
                  , C = d.morphAttributes.position || []
                  , P = d.morphAttributes.normal || []
                  , N = d.morphAttributes.color || [];
                let b = 0;
                w === !0 && (b = 1),
                T === !0 && (b = 2),
                A === !0 && (b = 3);
                let L = d.attributes.position.count * b
                  , Y = 1;
                L > e.maxTextureSize && (Y = Math.ceil(L / e.maxTextureSize),
                L = e.maxTextureSize);
                const Z = new Float32Array(L * Y * 4 * S)
                  , $ = new d0(Z,L,Y,S);
                $.type = Ys,
                $.needsUpdate = !0;
                const Q = b * 4;
                for (let fe = 0; fe < S; fe++) {
                    const le = C[fe]
                      , D = P[fe]
                      , j = N[fe]
                      , X = L * Y * 4 * fe;
                    for (let ue = 0; ue < le.count; ue++) {
                        const I = ue * Q;
                        w === !0 && (o.fromBufferAttribute(le, ue),
                        Z[X + I + 0] = o.x,
                        Z[X + I + 1] = o.y,
                        Z[X + I + 2] = o.z,
                        Z[X + I + 3] = 0),
                        T === !0 && (o.fromBufferAttribute(D, ue),
                        Z[X + I + 4] = o.x,
                        Z[X + I + 5] = o.y,
                        Z[X + I + 6] = o.z,
                        Z[X + I + 7] = 0),
                        A === !0 && (o.fromBufferAttribute(j, ue),
                        Z[X + I + 8] = o.x,
                        Z[X + I + 9] = o.y,
                        Z[X + I + 10] = o.z,
                        Z[X + I + 11] = j.itemSize === 4 ? o.w : 1)
                    }
                }
                M = {
                    count: S,
                    texture: $,
                    size: new be(L,Y)
                },
                s.set(d, M),
                d.addEventListener("dispose", ie)
            }
            let g = 0;
            for (let w = 0; w < p.length; w++)
                g += p[w];
            const _ = d.morphTargetsRelative ? 1 : 1 - g;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
            h.getUniforms().setValue(n, "morphTargetInfluences", p),
            h.getUniforms().setValue(n, "morphTargetsTexture", M.texture, t),
            h.getUniforms().setValue(n, "morphTargetsTextureSize", M.size)
        } else {
            const y = p === void 0 ? 0 : p.length;
            let S = i[d.id];
            if (S === void 0 || S.length !== y) {
                S = [];
                for (let T = 0; T < y; T++)
                    S[T] = [T, 0];
                i[d.id] = S
            }
            for (let T = 0; T < y; T++) {
                const A = S[T];
                A[0] = T,
                A[1] = p[T]
            }
            S.sort(G8);
            for (let T = 0; T < 8; T++)
                T < y && S[T][1] ? (a[T][0] = S[T][0],
                a[T][1] = S[T][1]) : (a[T][0] = Number.MAX_SAFE_INTEGER,
                a[T][1] = 0);
            a.sort(H8);
            const M = d.morphAttributes.position
              , g = d.morphAttributes.normal;
            let _ = 0;
            for (let T = 0; T < 8; T++) {
                const A = a[T]
                  , C = A[0]
                  , P = A[1];
                C !== Number.MAX_SAFE_INTEGER && P ? (M && d.getAttribute("morphTarget" + T) !== M[C] && d.setAttribute("morphTarget" + T, M[C]),
                g && d.getAttribute("morphNormal" + T) !== g[C] && d.setAttribute("morphNormal" + T, g[C]),
                r[T] = P,
                _ += P) : (M && d.hasAttribute("morphTarget" + T) === !0 && d.deleteAttribute("morphTarget" + T),
                g && d.hasAttribute("morphNormal" + T) === !0 && d.deleteAttribute("morphNormal" + T),
                r[T] = 0)
            }
            const w = d.morphTargetsRelative ? 1 : 1 - _;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", w),
            h.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}
function X8(n, e, t, i) {
    let r = new WeakMap;
    function s(l) {
        const f = i.render.frame
          , d = l.geometry
          , h = e.get(l, d);
        return r.get(h) !== f && (e.update(h),
        r.set(h, f)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, n.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER)),
        h
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const f = l.target;
        f.removeEventListener("dispose", a),
        t.remove(f.instanceMatrix),
        f.instanceColor !== null && t.remove(f.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const WL = new en
  , XL = new d0
  , $L = new B1
  , jL = new Cd
  , uA = []
  , fA = []
  , dA = new Float32Array(16)
  , hA = new Float32Array(9)
  , pA = new Float32Array(4);
function uu(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = uA[r];
    if (s === void 0 && (s = new Float32Array(r),
    uA[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Bn(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function Vn(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function m0(n, e) {
    let t = fA[e];
    t === void 0 && (t = new Int32Array(e),
    fA[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function $8(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function j8(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2fv(this.addr, e),
        Vn(t, e)
    }
}
function Y8(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Bn(t, e))
            return;
        n.uniform3fv(this.addr, e),
        Vn(t, e)
    }
}
function q8(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4fv(this.addr, e),
        Vn(t, e)
    }
}
function K8(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        Vn(t, e)
    } else {
        if (Bn(t, i))
            return;
        pA.set(i),
        n.uniformMatrix2fv(this.addr, !1, pA),
        Vn(t, i)
    }
}
function Z8(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        Vn(t, e)
    } else {
        if (Bn(t, i))
            return;
        hA.set(i),
        n.uniformMatrix3fv(this.addr, !1, hA),
        Vn(t, i)
    }
}
function Q8(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Bn(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        Vn(t, e)
    } else {
        if (Bn(t, i))
            return;
        dA.set(i),
        n.uniformMatrix4fv(this.addr, !1, dA),
        Vn(t, i)
    }
}
function J8(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function e6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2iv(this.addr, e),
        Vn(t, e)
    }
}
function t6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Bn(t, e))
            return;
        n.uniform3iv(this.addr, e),
        Vn(t, e)
    }
}
function n6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4iv(this.addr, e),
        Vn(t, e)
    }
}
function i6(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function r6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Bn(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        Vn(t, e)
    }
}
function s6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Bn(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        Vn(t, e)
    }
}
function o6(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Bn(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        Vn(t, e)
    }
}
function a6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2D(e || WL, r)
}
function l6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || $L, r)
}
function c6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || jL, r)
}
function u6(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || XL, r)
}
function f6(n) {
    switch (n) {
    case 5126:
        return $8;
    case 35664:
        return j8;
    case 35665:
        return Y8;
    case 35666:
        return q8;
    case 35674:
        return K8;
    case 35675:
        return Z8;
    case 35676:
        return Q8;
    case 5124:
    case 35670:
        return J8;
    case 35667:
    case 35671:
        return e6;
    case 35668:
    case 35672:
        return t6;
    case 35669:
    case 35673:
        return n6;
    case 5125:
        return i6;
    case 36294:
        return r6;
    case 36295:
        return s6;
    case 36296:
        return o6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return a6;
    case 35679:
    case 36299:
    case 36307:
        return l6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return c6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return u6
    }
}
function d6(n, e) {
    n.uniform1fv(this.addr, e)
}
function h6(n, e) {
    const t = uu(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function p6(n, e) {
    const t = uu(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function m6(n, e) {
    const t = uu(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function g6(n, e) {
    const t = uu(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function v6(n, e) {
    const t = uu(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function y6(n, e) {
    const t = uu(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function _6(n, e) {
    n.uniform1iv(this.addr, e)
}
function x6(n, e) {
    n.uniform2iv(this.addr, e)
}
function S6(n, e) {
    n.uniform3iv(this.addr, e)
}
function w6(n, e) {
    n.uniform4iv(this.addr, e)
}
function M6(n, e) {
    n.uniform1uiv(this.addr, e)
}
function E6(n, e) {
    n.uniform2uiv(this.addr, e)
}
function T6(n, e) {
    n.uniform3uiv(this.addr, e)
}
function A6(n, e) {
    n.uniform4uiv(this.addr, e)
}
function R6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = m0(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Vn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || WL, s[o])
}
function C6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = m0(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Vn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || $L, s[o])
}
function b6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = m0(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Vn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || jL, s[o])
}
function P6(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = m0(t, r);
    Bn(i, s) || (n.uniform1iv(this.addr, s),
    Vn(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || XL, s[o])
}
function L6(n) {
    switch (n) {
    case 5126:
        return d6;
    case 35664:
        return h6;
    case 35665:
        return p6;
    case 35666:
        return m6;
    case 35674:
        return g6;
    case 35675:
        return v6;
    case 35676:
        return y6;
    case 5124:
    case 35670:
        return _6;
    case 35667:
    case 35671:
        return x6;
    case 35668:
    case 35672:
        return S6;
    case 35669:
    case 35673:
        return w6;
    case 5125:
        return M6;
    case 36294:
        return E6;
    case 36295:
        return T6;
    case 36296:
        return A6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return R6;
    case 35679:
    case 36299:
    case 36307:
        return C6;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return b6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return P6
    }
}
class I6 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = f6(t.type)
    }
}
class N6 {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = L6(t.type)
    }
}
class D6 {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const Ny = /(\w+)(\])?(\[|\.)?/g;
function mA(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function U6(n, e, t) {
    const i = n.name
      , r = i.length;
    for (Ny.lastIndex = 0; ; ) {
        const s = Ny.exec(i)
          , o = Ny.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , f = s[3];
        if (l && (a = a | 0),
        f === void 0 || f === "[" && o + 2 === r) {
            mA(t, f === void 0 ? new I6(a,n,e) : new N6(a,n,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new D6(a),
            mA(t, h)),
            t = h
        }
    }
}
class Sm {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            U6(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function gA(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
let k6 = 0;
function O6(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function F6(n) {
    switch (n) {
    case Qr:
        return ["Linear", "( value )"];
    case lt:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        ["Linear", "( value )"]
    }
}
function vA(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + O6(n.getShaderSource(e), o)
    } else
        return r
}
function z6(n, e) {
    const t = F6(e);
    return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function B6(n, e) {
    let t;
    switch (e) {
    case lL:
        t = "Linear";
        break;
    case cL:
        t = "Reinhard";
        break;
    case uL:
        t = "OptimizedCineon";
        break;
    case I1:
        t = "ACESFilmic";
        break;
    case fL:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function V6(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(gf).join(`
`)
}
function H6(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function G6(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function gf(n) {
    return n !== ""
}
function yA(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function _A(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const W6 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function qx(n) {
    return n.replace(W6, X6)
}
function X6(n, e) {
    const t = _t[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return qx(t)
}
const $6 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function xA(n) {
    return n.replace($6, j6)
}
function j6(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function SA(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function Y6(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === l0 ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === bc ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Hr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function q6(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Zo:
        case Qo:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case lu:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function K6(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Qo:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function Z6(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case Td:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case oL:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case aL:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function Q6(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function J6(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = Y6(t)
      , f = q6(t)
      , d = K6(t)
      , h = Z6(t)
      , p = Q6(t)
      , m = t.isWebGL2 ? "" : V6(t)
      , y = H6(s)
      , S = r.createProgram();
    let M, g, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (M = [y].filter(gf).join(`
`),
    M.length > 0 && (M += `
`),
    g = [m, y].filter(gf).join(`
`),
    g.length > 0 && (g += `
`)) : (M = [SA(t), "#define SHADER_NAME " + t.shaderName, y, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(gf).join(`
`),
    g = [m, SA(t), "#define SHADER_NAME " + t.shaderName, y, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== qr ? "#define TONE_MAPPING" : "", t.toneMapping !== qr ? _t.tonemapping_pars_fragment : "", t.toneMapping !== qr ? B6("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", _t.encodings_pars_fragment, z6("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(gf).join(`
`)),
    o = qx(o),
    o = yA(o, t),
    o = _A(o, t),
    a = qx(a),
    a = yA(a, t),
    a = _A(a, t),
    o = xA(o),
    a = xA(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`,
    M = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + M,
    g = ["#define varying in", t.glslVersion === $x ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === $x ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + g);
    const w = _ + M + o
      , T = _ + g + a
      , A = gA(r, r.VERTEX_SHADER, w)
      , C = gA(r, r.FRAGMENT_SHADER, T);
    if (r.attachShader(S, A),
    r.attachShader(S, C),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(S, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(S, 0, "position"),
    r.linkProgram(S),
    n.debug.checkShaderErrors) {
        const b = r.getProgramInfoLog(S).trim()
          , L = r.getShaderInfoLog(A).trim()
          , Y = r.getShaderInfoLog(C).trim();
        let Z = !0
          , $ = !0;
        if (r.getProgramParameter(S, r.LINK_STATUS) === !1)
            if (Z = !1,
            typeof n.debug.onShaderError == "function")
                n.debug.onShaderError(r, S, A, C);
            else {
                const Q = vA(r, A, "vertex")
                  , ie = vA(r, C, "fragment");
                console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(S, r.VALIDATE_STATUS) + `

Program Info Log: ` + b + `
` + Q + `
` + ie)
            }
        else
            b !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", b) : (L === "" || Y === "") && ($ = !1);
        $ && (this.diagnostics = {
            runnable: Z,
            programLog: b,
            vertexShader: {
                log: L,
                prefix: M
            },
            fragmentShader: {
                log: Y,
                prefix: g
            }
        })
    }
    r.deleteShader(A),
    r.deleteShader(C);
    let P;
    this.getUniforms = function() {
        return P === void 0 && (P = new Sm(r,S)),
        P
    }
    ;
    let N;
    return this.getAttributes = function() {
        return N === void 0 && (N = G6(r, S)),
        N
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(S),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = k6++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = S,
    this.vertexShader = A,
    this.fragmentShader = C,
    this
}
let e9 = 0;
class t9 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new n9(e),
        t.set(e, i)),
        i
    }
}
class n9 {
    constructor(e) {
        this.id = e9++,
        this.code = e,
        this.usedTimes = 0
    }
}
function i9(n, e, t, i, r, s, o) {
    const a = new Wa
      , l = new t9
      , f = []
      , d = r.isWebGL2
      , h = r.logarithmicDepthBuffer
      , p = r.vertexTextures;
    let m = r.precision;
    const y = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function S(b) {
        return b === 1 ? "uv1" : b === 2 ? "uv2" : b === 3 ? "uv3" : "uv"
    }
    function M(b, L, Y, Z, $) {
        const Q = Z.fog
          , ie = $.geometry
          , fe = b.isMeshStandardMaterial ? Z.environment : null
          , le = (b.isMeshStandardMaterial ? t : e).get(b.envMap || fe)
          , D = le && le.mapping === lu ? le.image.height : null
          , j = y[b.type];
        b.precision !== null && (m = r.getMaxPrecision(b.precision),
        m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead."));
        const X = ie.morphAttributes.position || ie.morphAttributes.normal || ie.morphAttributes.color
          , ue = X !== void 0 ? X.length : 0;
        let I = 0;
        ie.morphAttributes.position !== void 0 && (I = 1),
        ie.morphAttributes.normal !== void 0 && (I = 2),
        ie.morphAttributes.color !== void 0 && (I = 3);
        let U, O, J, F;
        if (j) {
            const Ge = Xr[j];
            U = Ge.vertexShader,
            O = Ge.fragmentShader
        } else
            U = b.vertexShader,
            O = b.fragmentShader,
            l.update(b),
            J = l.getVertexShaderID(b),
            F = l.getFragmentShaderID(b);
        const B = n.getRenderTarget()
          , ae = $.isInstancedMesh === !0
          , _e = !!b.map
          , pe = !!b.matcap
          , Ee = !!le
          , se = !!b.aoMap
          , oe = !!b.lightMap
          , ve = !!b.bumpMap
          , Ce = !!b.normalMap
          , Re = !!b.displacementMap
          , Le = !!b.emissiveMap
          , Be = !!b.metalnessMap
          , Ze = !!b.roughnessMap
          , Ye = b.clearcoat > 0
          , pt = b.iridescence > 0
          , G = b.sheen > 0
          , k = b.transmission > 0
          , ee = Ye && !!b.clearcoatMap
          , we = Ye && !!b.clearcoatNormalMap
          , Ie = Ye && !!b.clearcoatRoughnessMap
          , Fe = pt && !!b.iridescenceMap
          , Je = pt && !!b.iridescenceThicknessMap
          , We = G && !!b.sheenColorMap
          , Me = G && !!b.sheenRoughnessMap
          , Qe = !!b.specularMap
          , tt = !!b.specularColorMap
          , st = !!b.specularIntensityMap
          , Xe = k && !!b.transmissionMap
          , K = k && !!b.thicknessMap
          , q = !!b.gradientMap
          , xe = !!b.alphaMap
          , Ne = b.alphaTest > 0
          , H = !!b.extensions
          , te = !!ie.attributes.uv1
          , me = !!ie.attributes.uv2
          , Te = !!ie.attributes.uv3;
        return {
            isWebGL2: d,
            shaderID: j,
            shaderName: b.type,
            vertexShader: U,
            fragmentShader: O,
            defines: b.defines,
            customVertexShaderID: J,
            customFragmentShaderID: F,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: m,
            instancing: ae,
            instancingColor: ae && $.instanceColor !== null,
            supportsVertexTextures: p,
            outputColorSpace: B === null ? n.outputColorSpace : B.isXRRenderTarget === !0 ? B.texture.colorSpace : Qr,
            map: _e,
            matcap: pe,
            envMap: Ee,
            envMapMode: Ee && le.mapping,
            envMapCubeUVHeight: D,
            aoMap: se,
            lightMap: oe,
            bumpMap: ve,
            normalMap: Ce,
            displacementMap: p && Re,
            emissiveMap: Le,
            normalMapObjectSpace: Ce && b.normalMapType === NL,
            normalMapTangentSpace: Ce && b.normalMapType === sa,
            metalnessMap: Be,
            roughnessMap: Ze,
            clearcoat: Ye,
            clearcoatMap: ee,
            clearcoatNormalMap: we,
            clearcoatRoughnessMap: Ie,
            iridescence: pt,
            iridescenceMap: Fe,
            iridescenceThicknessMap: Je,
            sheen: G,
            sheenColorMap: We,
            sheenRoughnessMap: Me,
            specularMap: Qe,
            specularColorMap: tt,
            specularIntensityMap: st,
            transmission: k,
            transmissionMap: Xe,
            thicknessMap: K,
            gradientMap: q,
            opaque: b.transparent === !1 && b.blending === Va,
            alphaMap: xe,
            alphaTest: Ne,
            combine: b.combine,
            mapUv: _e && S(b.map.channel),
            aoMapUv: se && S(b.aoMap.channel),
            lightMapUv: oe && S(b.lightMap.channel),
            bumpMapUv: ve && S(b.bumpMap.channel),
            normalMapUv: Ce && S(b.normalMap.channel),
            displacementMapUv: Re && S(b.displacementMap.channel),
            emissiveMapUv: Le && S(b.emissiveMap.channel),
            metalnessMapUv: Be && S(b.metalnessMap.channel),
            roughnessMapUv: Ze && S(b.roughnessMap.channel),
            clearcoatMapUv: ee && S(b.clearcoatMap.channel),
            clearcoatNormalMapUv: we && S(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Ie && S(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Fe && S(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: Je && S(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: We && S(b.sheenColorMap.channel),
            sheenRoughnessMapUv: Me && S(b.sheenRoughnessMap.channel),
            specularMapUv: Qe && S(b.specularMap.channel),
            specularColorMapUv: tt && S(b.specularColorMap.channel),
            specularIntensityMapUv: st && S(b.specularIntensityMap.channel),
            transmissionMapUv: Xe && S(b.transmissionMap.channel),
            thicknessMapUv: K && S(b.thicknessMap.channel),
            alphaMapUv: xe && S(b.alphaMap.channel),
            vertexTangents: Ce && !!ie.attributes.tangent,
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === !0 && !!ie.attributes.color && ie.attributes.color.itemSize === 4,
            vertexUv1s: te,
            vertexUv2s: me,
            vertexUv3s: Te,
            pointsUvs: $.isPoints === !0 && !!ie.attributes.uv && (_e || xe),
            fog: !!Q,
            useFog: b.fog === !0,
            fogExp2: Q && Q.isFogExp2,
            flatShading: b.flatShading === !0,
            sizeAttenuation: b.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            skinning: $.isSkinnedMesh === !0,
            morphTargets: ie.morphAttributes.position !== void 0,
            morphNormals: ie.morphAttributes.normal !== void 0,
            morphColors: ie.morphAttributes.color !== void 0,
            morphTargetsCount: ue,
            morphTextureStride: I,
            numDirLights: L.directional.length,
            numPointLights: L.point.length,
            numSpotLights: L.spot.length,
            numSpotLightMaps: L.spotLightMap.length,
            numRectAreaLights: L.rectArea.length,
            numHemiLights: L.hemi.length,
            numDirLightShadows: L.directionalShadowMap.length,
            numPointLightShadows: L.pointShadowMap.length,
            numSpotLightShadows: L.spotShadowMap.length,
            numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: n.shadowMap.enabled && Y.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: b.toneMapped ? n.toneMapping : qr,
            useLegacyLights: n.useLegacyLights,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === $r,
            flipSided: b.side === hi,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: H && b.extensions.derivatives === !0,
            extensionFragDepth: H && b.extensions.fragDepth === !0,
            extensionDrawBuffers: H && b.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: H && b.extensions.shaderTextureLOD === !0,
            rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: b.customProgramCacheKey()
        }
    }
    function g(b) {
        const L = [];
        if (b.shaderID ? L.push(b.shaderID) : (L.push(b.customVertexShaderID),
        L.push(b.customFragmentShaderID)),
        b.defines !== void 0)
            for (const Y in b.defines)
                L.push(Y),
                L.push(b.defines[Y]);
        return b.isRawShaderMaterial === !1 && (_(L, b),
        w(L, b),
        L.push(n.outputColorSpace)),
        L.push(b.customProgramCacheKey),
        L.join()
    }
    function _(b, L) {
        b.push(L.precision),
        b.push(L.outputColorSpace),
        b.push(L.envMapMode),
        b.push(L.envMapCubeUVHeight),
        b.push(L.mapUv),
        b.push(L.alphaMapUv),
        b.push(L.lightMapUv),
        b.push(L.aoMapUv),
        b.push(L.bumpMapUv),
        b.push(L.normalMapUv),
        b.push(L.displacementMapUv),
        b.push(L.emissiveMapUv),
        b.push(L.metalnessMapUv),
        b.push(L.roughnessMapUv),
        b.push(L.clearcoatMapUv),
        b.push(L.clearcoatNormalMapUv),
        b.push(L.clearcoatRoughnessMapUv),
        b.push(L.iridescenceMapUv),
        b.push(L.iridescenceThicknessMapUv),
        b.push(L.sheenColorMapUv),
        b.push(L.sheenRoughnessMapUv),
        b.push(L.specularMapUv),
        b.push(L.specularColorMapUv),
        b.push(L.specularIntensityMapUv),
        b.push(L.transmissionMapUv),
        b.push(L.thicknessMapUv),
        b.push(L.combine),
        b.push(L.fogExp2),
        b.push(L.sizeAttenuation),
        b.push(L.morphTargetsCount),
        b.push(L.morphAttributeCount),
        b.push(L.numDirLights),
        b.push(L.numPointLights),
        b.push(L.numSpotLights),
        b.push(L.numSpotLightMaps),
        b.push(L.numHemiLights),
        b.push(L.numRectAreaLights),
        b.push(L.numDirLightShadows),
        b.push(L.numPointLightShadows),
        b.push(L.numSpotLightShadows),
        b.push(L.numSpotLightShadowsWithMaps),
        b.push(L.shadowMapType),
        b.push(L.toneMapping),
        b.push(L.numClippingPlanes),
        b.push(L.numClipIntersection),
        b.push(L.depthPacking)
    }
    function w(b, L) {
        a.disableAll(),
        L.isWebGL2 && a.enable(0),
        L.supportsVertexTextures && a.enable(1),
        L.instancing && a.enable(2),
        L.instancingColor && a.enable(3),
        L.matcap && a.enable(4),
        L.envMap && a.enable(5),
        L.normalMapObjectSpace && a.enable(6),
        L.normalMapTangentSpace && a.enable(7),
        L.clearcoat && a.enable(8),
        L.iridescence && a.enable(9),
        L.alphaTest && a.enable(10),
        L.vertexColors && a.enable(11),
        L.vertexAlphas && a.enable(12),
        L.vertexUv1s && a.enable(13),
        L.vertexUv2s && a.enable(14),
        L.vertexUv3s && a.enable(15),
        L.vertexTangents && a.enable(16),
        b.push(a.mask),
        a.disableAll(),
        L.fog && a.enable(0),
        L.useFog && a.enable(1),
        L.flatShading && a.enable(2),
        L.logarithmicDepthBuffer && a.enable(3),
        L.skinning && a.enable(4),
        L.morphTargets && a.enable(5),
        L.morphNormals && a.enable(6),
        L.morphColors && a.enable(7),
        L.premultipliedAlpha && a.enable(8),
        L.shadowMapEnabled && a.enable(9),
        L.useLegacyLights && a.enable(10),
        L.doubleSided && a.enable(11),
        L.flipSided && a.enable(12),
        L.useDepthPacking && a.enable(13),
        L.dithering && a.enable(14),
        L.transmission && a.enable(15),
        L.sheen && a.enable(16),
        L.opaque && a.enable(17),
        L.pointsUvs && a.enable(18),
        b.push(a.mask)
    }
    function T(b) {
        const L = y[b.type];
        let Y;
        if (L) {
            const Z = Xr[L];
            Y = BL.clone(Z.uniforms)
        } else
            Y = b.uniforms;
        return Y
    }
    function A(b, L) {
        let Y;
        for (let Z = 0, $ = f.length; Z < $; Z++) {
            const Q = f[Z];
            if (Q.cacheKey === L) {
                Y = Q,
                ++Y.usedTimes;
                break
            }
        }
        return Y === void 0 && (Y = new J6(n,L,b,s),
        f.push(Y)),
        Y
    }
    function C(b) {
        if (--b.usedTimes === 0) {
            const L = f.indexOf(b);
            f[L] = f[f.length - 1],
            f.pop(),
            b.destroy()
        }
    }
    function P(b) {
        l.remove(b)
    }
    function N() {
        l.dispose()
    }
    return {
        getParameters: M,
        getProgramCacheKey: g,
        getUniforms: T,
        acquireProgram: A,
        releaseProgram: C,
        releaseShaderCache: P,
        programs: f,
        dispose: N
    }
}
function r9() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function s9(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function wA(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function MA() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, p, m, y, S, M) {
        let g = n[e];
        return g === void 0 ? (g = {
            id: h.id,
            object: h,
            geometry: p,
            material: m,
            groupOrder: y,
            renderOrder: h.renderOrder,
            z: S,
            group: M
        },
        n[e] = g) : (g.id = h.id,
        g.object = h,
        g.geometry = p,
        g.material = m,
        g.groupOrder = y,
        g.renderOrder = h.renderOrder,
        g.z = S,
        g.group = M),
        e++,
        g
    }
    function a(h, p, m, y, S, M) {
        const g = o(h, p, m, y, S, M);
        m.transmission > 0 ? i.push(g) : m.transparent === !0 ? r.push(g) : t.push(g)
    }
    function l(h, p, m, y, S, M) {
        const g = o(h, p, m, y, S, M);
        m.transmission > 0 ? i.unshift(g) : m.transparent === !0 ? r.unshift(g) : t.unshift(g)
    }
    function f(h, p) {
        t.length > 1 && t.sort(h || s9),
        i.length > 1 && i.sort(p || wA),
        r.length > 1 && r.sort(p || wA)
    }
    function d() {
        for (let h = e, p = n.length; h < p; h++) {
            const m = n[h];
            if (m.id === null)
                break;
            m.id = null,
            m.object = null,
            m.geometry = null,
            m.material = null,
            m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: d,
        sort: f
    }
}
function o9() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new MA,
        n.set(i, [o])) : r >= s.length ? (o = new MA,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function a9() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new z,
                    color: new Oe
                };
                break;
            case "SpotLight":
                t = {
                    position: new z,
                    direction: new z,
                    color: new Oe,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new z,
                    color: new Oe,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new z,
                    skyColor: new Oe,
                    groundColor: new Oe
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Oe,
                    position: new z,
                    halfWidth: new z,
                    halfHeight: new z
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function l9() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new be
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new be
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new be,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let c9 = 0;
function u9(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function f9(n, e) {
    const t = new a9
      , i = l9()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let d = 0; d < 9; d++)
        r.probe.push(new z);
    const s = new z
      , o = new $e
      , a = new $e;
    function l(d, h) {
        let p = 0
          , m = 0
          , y = 0;
        for (let Y = 0; Y < 9; Y++)
            r.probe[Y].set(0, 0, 0);
        let S = 0
          , M = 0
          , g = 0
          , _ = 0
          , w = 0
          , T = 0
          , A = 0
          , C = 0
          , P = 0
          , N = 0;
        d.sort(u9);
        const b = h === !0 ? Math.PI : 1;
        for (let Y = 0, Z = d.length; Y < Z; Y++) {
            const $ = d[Y]
              , Q = $.color
              , ie = $.intensity
              , fe = $.distance
              , le = $.shadow && $.shadow.map ? $.shadow.map.texture : null;
            if ($.isAmbientLight)
                p += Q.r * ie * b,
                m += Q.g * ie * b,
                y += Q.b * ie * b;
            else if ($.isLightProbe)
                for (let D = 0; D < 9; D++)
                    r.probe[D].addScaledVector($.sh.coefficients[D], ie);
            else if ($.isDirectionalLight) {
                const D = t.get($);
                if (D.color.copy($.color).multiplyScalar($.intensity * b),
                $.castShadow) {
                    const j = $.shadow
                      , X = i.get($);
                    X.shadowBias = j.bias,
                    X.shadowNormalBias = j.normalBias,
                    X.shadowRadius = j.radius,
                    X.shadowMapSize = j.mapSize,
                    r.directionalShadow[S] = X,
                    r.directionalShadowMap[S] = le,
                    r.directionalShadowMatrix[S] = $.shadow.matrix,
                    T++
                }
                r.directional[S] = D,
                S++
            } else if ($.isSpotLight) {
                const D = t.get($);
                D.position.setFromMatrixPosition($.matrixWorld),
                D.color.copy(Q).multiplyScalar(ie * b),
                D.distance = fe,
                D.coneCos = Math.cos($.angle),
                D.penumbraCos = Math.cos($.angle * (1 - $.penumbra)),
                D.decay = $.decay,
                r.spot[g] = D;
                const j = $.shadow;
                if ($.map && (r.spotLightMap[P] = $.map,
                P++,
                j.updateMatrices($),
                $.castShadow && N++),
                r.spotLightMatrix[g] = j.matrix,
                $.castShadow) {
                    const X = i.get($);
                    X.shadowBias = j.bias,
                    X.shadowNormalBias = j.normalBias,
                    X.shadowRadius = j.radius,
                    X.shadowMapSize = j.mapSize,
                    r.spotShadow[g] = X,
                    r.spotShadowMap[g] = le,
                    C++
                }
                g++
            } else if ($.isRectAreaLight) {
                const D = t.get($);
                D.color.copy(Q).multiplyScalar(ie),
                D.halfWidth.set($.width * .5, 0, 0),
                D.halfHeight.set(0, $.height * .5, 0),
                r.rectArea[_] = D,
                _++
            } else if ($.isPointLight) {
                const D = t.get($);
                if (D.color.copy($.color).multiplyScalar($.intensity * b),
                D.distance = $.distance,
                D.decay = $.decay,
                $.castShadow) {
                    const j = $.shadow
                      , X = i.get($);
                    X.shadowBias = j.bias,
                    X.shadowNormalBias = j.normalBias,
                    X.shadowRadius = j.radius,
                    X.shadowMapSize = j.mapSize,
                    X.shadowCameraNear = j.camera.near,
                    X.shadowCameraFar = j.camera.far,
                    r.pointShadow[M] = X,
                    r.pointShadowMap[M] = le,
                    r.pointShadowMatrix[M] = $.shadow.matrix,
                    A++
                }
                r.point[M] = D,
                M++
            } else if ($.isHemisphereLight) {
                const D = t.get($);
                D.skyColor.copy($.color).multiplyScalar(ie * b),
                D.groundColor.copy($.groundColor).multiplyScalar(ie * b),
                r.hemi[w] = D,
                w++
            }
        }
        _ > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = ze.LTC_FLOAT_1,
        r.rectAreaLTC2 = ze.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = ze.LTC_HALF_1,
        r.rectAreaLTC2 = ze.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = p,
        r.ambient[1] = m,
        r.ambient[2] = y;
        const L = r.hash;
        (L.directionalLength !== S || L.pointLength !== M || L.spotLength !== g || L.rectAreaLength !== _ || L.hemiLength !== w || L.numDirectionalShadows !== T || L.numPointShadows !== A || L.numSpotShadows !== C || L.numSpotMaps !== P) && (r.directional.length = S,
        r.spot.length = g,
        r.rectArea.length = _,
        r.point.length = M,
        r.hemi.length = w,
        r.directionalShadow.length = T,
        r.directionalShadowMap.length = T,
        r.pointShadow.length = A,
        r.pointShadowMap.length = A,
        r.spotShadow.length = C,
        r.spotShadowMap.length = C,
        r.directionalShadowMatrix.length = T,
        r.pointShadowMatrix.length = A,
        r.spotLightMatrix.length = C + P - N,
        r.spotLightMap.length = P,
        r.numSpotLightShadowsWithMaps = N,
        L.directionalLength = S,
        L.pointLength = M,
        L.spotLength = g,
        L.rectAreaLength = _,
        L.hemiLength = w,
        L.numDirectionalShadows = T,
        L.numPointShadows = A,
        L.numSpotShadows = C,
        L.numSpotMaps = P,
        r.version = c9++)
    }
    function f(d, h) {
        let p = 0
          , m = 0
          , y = 0
          , S = 0
          , M = 0;
        const g = h.matrixWorldInverse;
        for (let _ = 0, w = d.length; _ < w; _++) {
            const T = d[_];
            if (T.isDirectionalLight) {
                const A = r.directional[p];
                A.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                A.direction.sub(s),
                A.direction.transformDirection(g),
                p++
            } else if (T.isSpotLight) {
                const A = r.spot[y];
                A.position.setFromMatrixPosition(T.matrixWorld),
                A.position.applyMatrix4(g),
                A.direction.setFromMatrixPosition(T.matrixWorld),
                s.setFromMatrixPosition(T.target.matrixWorld),
                A.direction.sub(s),
                A.direction.transformDirection(g),
                y++
            } else if (T.isRectAreaLight) {
                const A = r.rectArea[S];
                A.position.setFromMatrixPosition(T.matrixWorld),
                A.position.applyMatrix4(g),
                a.identity(),
                o.copy(T.matrixWorld),
                o.premultiply(g),
                a.extractRotation(o),
                A.halfWidth.set(T.width * .5, 0, 0),
                A.halfHeight.set(0, T.height * .5, 0),
                A.halfWidth.applyMatrix4(a),
                A.halfHeight.applyMatrix4(a),
                S++
            } else if (T.isPointLight) {
                const A = r.point[m];
                A.position.setFromMatrixPosition(T.matrixWorld),
                A.position.applyMatrix4(g),
                m++
            } else if (T.isHemisphereLight) {
                const A = r.hemi[M];
                A.direction.setFromMatrixPosition(T.matrixWorld),
                A.direction.transformDirection(g),
                M++
            }
        }
    }
    return {
        setup: l,
        setupView: f,
        state: r
    }
}
function EA(n, e) {
    const t = new f9(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(h) {
        i.push(h)
    }
    function a(h) {
        r.push(h)
    }
    function l(h) {
        t.setup(i, h)
    }
    function f(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: f,
        pushLight: o,
        pushShadow: a
    }
}
function d9(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new EA(n,e),
        t.set(s, [l])) : o >= a.length ? (l = new EA(n,e),
        a.push(l)) : l = a[o],
        l
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class G1 extends Nn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = LL,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class W1 extends Nn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const h9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , p9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function m9(n, e, t) {
    let i = new p0;
    const r = new be
      , s = new be
      , o = new Ut
      , a = new G1({
        depthPacking: IL
    })
      , l = new W1
      , f = {}
      , d = t.maxTextureSize
      , h = {
        [Zr]: hi,
        [hi]: Zr,
        [$r]: $r
    }
      , p = new Ms({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new be
            },
            radius: {
                value: 4
            }
        },
        vertexShader: h9,
        fragmentShader: p9
    })
      , m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const y = new ft;
    y.setAttribute("position", new Ht(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const S = new zn(y,p)
      , M = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = l0;
    let g = this.type;
    this.render = function(A, C, P) {
        if (M.enabled === !1 || M.autoUpdate === !1 && M.needsUpdate === !1 || A.length === 0)
            return;
        const N = n.getRenderTarget()
          , b = n.getActiveCubeFace()
          , L = n.getActiveMipmapLevel()
          , Y = n.state;
        Y.setBlending(Ks),
        Y.buffers.color.setClear(1, 1, 1, 1),
        Y.buffers.depth.setTest(!0),
        Y.setScissorTest(!1);
        const Z = g !== Hr && this.type === Hr
          , $ = g === Hr && this.type !== Hr;
        for (let Q = 0, ie = A.length; Q < ie; Q++) {
            const fe = A[Q]
              , le = fe.shadow;
            if (le === void 0) {
                console.warn("THREE.WebGLShadowMap:", fe, "has no shadow.");
                continue
            }
            if (le.autoUpdate === !1 && le.needsUpdate === !1)
                continue;
            r.copy(le.mapSize);
            const D = le.getFrameExtents();
            if (r.multiply(D),
            s.copy(le.mapSize),
            (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / D.x),
            r.x = s.x * D.x,
            le.mapSize.x = s.x),
            r.y > d && (s.y = Math.floor(d / D.y),
            r.y = s.y * D.y,
            le.mapSize.y = s.y)),
            le.map === null || Z === !0 || $ === !0) {
                const X = this.type !== Hr ? {
                    minFilter: _n,
                    magFilter: _n
                } : {};
                le.map !== null && le.map.dispose(),
                le.map = new Jr(r.x,r.y,X),
                le.map.texture.name = fe.name + ".shadowMap",
                le.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(le.map),
            n.clear();
            const j = le.getViewportCount();
            for (let X = 0; X < j; X++) {
                const ue = le.getViewport(X);
                o.set(s.x * ue.x, s.y * ue.y, s.x * ue.z, s.y * ue.w),
                Y.viewport(o),
                le.updateMatrices(fe, X),
                i = le.getFrustum(),
                T(C, P, le.camera, fe, this.type)
            }
            le.isPointLightShadow !== !0 && this.type === Hr && _(le, P),
            le.needsUpdate = !1
        }
        g = this.type,
        M.needsUpdate = !1,
        n.setRenderTarget(N, b, L)
    }
    ;
    function _(A, C) {
        const P = e.update(S);
        p.defines.VSM_SAMPLES !== A.blurSamples && (p.defines.VSM_SAMPLES = A.blurSamples,
        m.defines.VSM_SAMPLES = A.blurSamples,
        p.needsUpdate = !0,
        m.needsUpdate = !0),
        A.mapPass === null && (A.mapPass = new Jr(r.x,r.y)),
        p.uniforms.shadow_pass.value = A.map.texture,
        p.uniforms.resolution.value = A.mapSize,
        p.uniforms.radius.value = A.radius,
        n.setRenderTarget(A.mapPass),
        n.clear(),
        n.renderBufferDirect(C, null, P, p, S, null),
        m.uniforms.shadow_pass.value = A.mapPass.texture,
        m.uniforms.resolution.value = A.mapSize,
        m.uniforms.radius.value = A.radius,
        n.setRenderTarget(A.map),
        n.clear(),
        n.renderBufferDirect(C, null, P, m, S, null)
    }
    function w(A, C, P, N) {
        let b = null;
        const L = P.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (L !== void 0)
            b = L;
        else if (b = P.isPointLight === !0 ? l : a,
        n.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
            const Y = b.uuid
              , Z = C.uuid;
            let $ = f[Y];
            $ === void 0 && ($ = {},
            f[Y] = $);
            let Q = $[Z];
            Q === void 0 && (Q = b.clone(),
            $[Z] = Q),
            b = Q
        }
        if (b.visible = C.visible,
        b.wireframe = C.wireframe,
        N === Hr ? b.side = C.shadowSide !== null ? C.shadowSide : C.side : b.side = C.shadowSide !== null ? C.shadowSide : h[C.side],
        b.alphaMap = C.alphaMap,
        b.alphaTest = C.alphaTest,
        b.map = C.map,
        b.clipShadows = C.clipShadows,
        b.clippingPlanes = C.clippingPlanes,
        b.clipIntersection = C.clipIntersection,
        b.displacementMap = C.displacementMap,
        b.displacementScale = C.displacementScale,
        b.displacementBias = C.displacementBias,
        b.wireframeLinewidth = C.wireframeLinewidth,
        b.linewidth = C.linewidth,
        P.isPointLight === !0 && b.isMeshDistanceMaterial === !0) {
            const Y = n.properties.get(b);
            Y.light = P
        }
        return b
    }
    function T(A, C, P, N, b) {
        if (A.visible === !1)
            return;
        if (A.layers.test(C.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && b === Hr) && (!A.frustumCulled || i.intersectsObject(A))) {
            A.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, A.matrixWorld);
            const Z = e.update(A)
              , $ = A.material;
            if (Array.isArray($)) {
                const Q = Z.groups;
                for (let ie = 0, fe = Q.length; ie < fe; ie++) {
                    const le = Q[ie]
                      , D = $[le.materialIndex];
                    if (D && D.visible) {
                        const j = w(A, D, N, b);
                        n.renderBufferDirect(P, null, Z, j, A, le)
                    }
                }
            } else if ($.visible) {
                const Q = w(A, $, N, b);
                n.renderBufferDirect(P, null, Z, Q, A, null)
            }
        }
        const Y = A.children;
        for (let Z = 0, $ = Y.length; Z < $; Z++)
            T(Y[Z], C, P, N, b)
    }
}
function g9(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let H = !1;
        const te = new Ut;
        let me = null;
        const Te = new Ut(0,0,0,0);
        return {
            setMask: function(Pe) {
                me !== Pe && !H && (n.colorMask(Pe, Pe, Pe, Pe),
                me = Pe)
            },
            setLocked: function(Pe) {
                H = Pe
            },
            setClear: function(Pe, Ge, it, Dt, Bt) {
                Bt === !0 && (Pe *= Dt,
                Ge *= Dt,
                it *= Dt),
                te.set(Pe, Ge, it, Dt),
                Te.equals(te) === !1 && (n.clearColor(Pe, Ge, it, Dt),
                Te.copy(te))
            },
            reset: function() {
                H = !1,
                me = null,
                Te.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let H = !1
          , te = null
          , me = null
          , Te = null;
        return {
            setTest: function(Pe) {
                Pe ? B(n.DEPTH_TEST) : ae(n.DEPTH_TEST)
            },
            setMask: function(Pe) {
                te !== Pe && !H && (n.depthMask(Pe),
                te = Pe)
            },
            setFunc: function(Pe) {
                if (me !== Pe) {
                    switch (Pe) {
                    case JP:
                        n.depthFunc(n.NEVER);
                        break;
                    case eL:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case tL:
                        n.depthFunc(n.LESS);
                        break;
                    case Qm:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case nL:
                        n.depthFunc(n.EQUAL);
                        break;
                    case iL:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case rL:
                        n.depthFunc(n.GREATER);
                        break;
                    case sL:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    me = Pe
                }
            },
            setLocked: function(Pe) {
                H = Pe
            },
            setClear: function(Pe) {
                Te !== Pe && (n.clearDepth(Pe),
                Te = Pe)
            },
            reset: function() {
                H = !1,
                te = null,
                me = null,
                Te = null
            }
        }
    }
    function o() {
        let H = !1
          , te = null
          , me = null
          , Te = null
          , Pe = null
          , Ge = null
          , it = null
          , Dt = null
          , Bt = null;
        return {
            setTest: function(bt) {
                H || (bt ? B(n.STENCIL_TEST) : ae(n.STENCIL_TEST))
            },
            setMask: function(bt) {
                te !== bt && !H && (n.stencilMask(bt),
                te = bt)
            },
            setFunc: function(bt, qt, Dn) {
                (me !== bt || Te !== qt || Pe !== Dn) && (n.stencilFunc(bt, qt, Dn),
                me = bt,
                Te = qt,
                Pe = Dn)
            },
            setOp: function(bt, qt, Dn) {
                (Ge !== bt || it !== qt || Dt !== Dn) && (n.stencilOp(bt, qt, Dn),
                Ge = bt,
                it = qt,
                Dt = Dn)
            },
            setLocked: function(bt) {
                H = bt
            },
            setClear: function(bt) {
                Bt !== bt && (n.clearStencil(bt),
                Bt = bt)
            },
            reset: function() {
                H = !1,
                te = null,
                me = null,
                Te = null,
                Pe = null,
                Ge = null,
                it = null,
                Dt = null,
                Bt = null
            }
        }
    }
    const a = new r
      , l = new s
      , f = new o
      , d = new WeakMap
      , h = new WeakMap;
    let p = {}
      , m = {}
      , y = new WeakMap
      , S = []
      , M = null
      , g = !1
      , _ = null
      , w = null
      , T = null
      , A = null
      , C = null
      , P = null
      , N = null
      , b = !1
      , L = null
      , Y = null
      , Z = null
      , $ = null
      , Q = null;
    const ie = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let fe = !1
      , le = 0;
    const D = n.getParameter(n.VERSION);
    D.indexOf("WebGL") !== -1 ? (le = parseFloat(/^WebGL (\d)/.exec(D)[1]),
    fe = le >= 1) : D.indexOf("OpenGL ES") !== -1 && (le = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]),
    fe = le >= 2);
    let j = null
      , X = {};
    const ue = n.getParameter(n.SCISSOR_BOX)
      , I = n.getParameter(n.VIEWPORT)
      , U = new Ut().fromArray(ue)
      , O = new Ut().fromArray(I);
    function J(H, te, me, Te) {
        const Pe = new Uint8Array(4)
          , Ge = n.createTexture();
        n.bindTexture(H, Ge),
        n.texParameteri(H, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(H, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let it = 0; it < me; it++)
            i && (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) ? n.texImage3D(te, 0, n.RGBA, 1, 1, Te, 0, n.RGBA, n.UNSIGNED_BYTE, Pe) : n.texImage2D(te + it, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Pe);
        return Ge
    }
    const F = {};
    F[n.TEXTURE_2D] = J(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    F[n.TEXTURE_CUBE_MAP] = J(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    i && (F[n.TEXTURE_2D_ARRAY] = J(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    F[n.TEXTURE_3D] = J(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    f.setClear(0),
    B(n.DEPTH_TEST),
    l.setFunc(Qm),
    Re(!1),
    Le(vx),
    B(n.CULL_FACE),
    ve(Ks);
    function B(H) {
        p[H] !== !0 && (n.enable(H),
        p[H] = !0)
    }
    function ae(H) {
        p[H] !== !1 && (n.disable(H),
        p[H] = !1)
    }
    function _e(H, te) {
        return m[H] !== te ? (n.bindFramebuffer(H, te),
        m[H] = te,
        i && (H === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = te),
        H === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = te)),
        !0) : !1
    }
    function pe(H, te) {
        let me = S
          , Te = !1;
        if (H)
            if (me = y.get(te),
            me === void 0 && (me = [],
            y.set(te, me)),
            H.isWebGLMultipleRenderTargets) {
                const Pe = H.texture;
                if (me.length !== Pe.length || me[0] !== n.COLOR_ATTACHMENT0) {
                    for (let Ge = 0, it = Pe.length; Ge < it; Ge++)
                        me[Ge] = n.COLOR_ATTACHMENT0 + Ge;
                    me.length = Pe.length,
                    Te = !0
                }
            } else
                me[0] !== n.COLOR_ATTACHMENT0 && (me[0] = n.COLOR_ATTACHMENT0,
                Te = !0);
        else
            me[0] !== n.BACK && (me[0] = n.BACK,
            Te = !0);
        Te && (t.isWebGL2 ? n.drawBuffers(me) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(me))
    }
    function Ee(H) {
        return M !== H ? (n.useProgram(H),
        M = H,
        !0) : !1
    }
    const se = {
        [Pa]: n.FUNC_ADD,
        [HP]: n.FUNC_SUBTRACT,
        [GP]: n.FUNC_REVERSE_SUBTRACT
    };
    if (i)
        se[Sx] = n.MIN,
        se[wx] = n.MAX;
    else {
        const H = e.get("EXT_blend_minmax");
        H !== null && (se[Sx] = H.MIN_EXT,
        se[wx] = H.MAX_EXT)
    }
    const oe = {
        [WP]: n.ZERO,
        [XP]: n.ONE,
        [$P]: n.SRC_COLOR,
        [P1]: n.SRC_ALPHA,
        [QP]: n.SRC_ALPHA_SATURATE,
        [KP]: n.DST_COLOR,
        [YP]: n.DST_ALPHA,
        [jP]: n.ONE_MINUS_SRC_COLOR,
        [L1]: n.ONE_MINUS_SRC_ALPHA,
        [ZP]: n.ONE_MINUS_DST_COLOR,
        [qP]: n.ONE_MINUS_DST_ALPHA
    };
    function ve(H, te, me, Te, Pe, Ge, it, Dt) {
        if (H === Ks) {
            g === !0 && (ae(n.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (B(n.BLEND),
        g = !0),
        H !== VP) {
            if (H !== _ || Dt !== b) {
                if ((w !== Pa || C !== Pa) && (n.blendEquation(n.FUNC_ADD),
                w = Pa,
                C = Pa),
                Dt)
                    switch (H) {
                    case Va:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case yx:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case _x:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case xx:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", H);
                        break
                    }
                else
                    switch (H) {
                    case Va:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case yx:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case _x:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case xx:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", H);
                        break
                    }
                T = null,
                A = null,
                P = null,
                N = null,
                _ = H,
                b = Dt
            }
            return
        }
        Pe = Pe || te,
        Ge = Ge || me,
        it = it || Te,
        (te !== w || Pe !== C) && (n.blendEquationSeparate(se[te], se[Pe]),
        w = te,
        C = Pe),
        (me !== T || Te !== A || Ge !== P || it !== N) && (n.blendFuncSeparate(oe[me], oe[Te], oe[Ge], oe[it]),
        T = me,
        A = Te,
        P = Ge,
        N = it),
        _ = H,
        b = !1
    }
    function Ce(H, te) {
        H.side === $r ? ae(n.CULL_FACE) : B(n.CULL_FACE);
        let me = H.side === hi;
        te && (me = !me),
        Re(me),
        H.blending === Va && H.transparent === !1 ? ve(Ks) : ve(H.blending, H.blendEquation, H.blendSrc, H.blendDst, H.blendEquationAlpha, H.blendSrcAlpha, H.blendDstAlpha, H.premultipliedAlpha),
        l.setFunc(H.depthFunc),
        l.setTest(H.depthTest),
        l.setMask(H.depthWrite),
        a.setMask(H.colorWrite);
        const Te = H.stencilWrite;
        f.setTest(Te),
        Te && (f.setMask(H.stencilWriteMask),
        f.setFunc(H.stencilFunc, H.stencilRef, H.stencilFuncMask),
        f.setOp(H.stencilFail, H.stencilZFail, H.stencilZPass)),
        Ze(H.polygonOffset, H.polygonOffsetFactor, H.polygonOffsetUnits),
        H.alphaToCoverage === !0 ? B(n.SAMPLE_ALPHA_TO_COVERAGE) : ae(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Re(H) {
        L !== H && (H ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        L = H)
    }
    function Le(H) {
        H !== FP ? (B(n.CULL_FACE),
        H !== Y && (H === vx ? n.cullFace(n.BACK) : H === zP ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ae(n.CULL_FACE),
        Y = H
    }
    function Be(H) {
        H !== Z && (fe && n.lineWidth(H),
        Z = H)
    }
    function Ze(H, te, me) {
        H ? (B(n.POLYGON_OFFSET_FILL),
        ($ !== te || Q !== me) && (n.polygonOffset(te, me),
        $ = te,
        Q = me)) : ae(n.POLYGON_OFFSET_FILL)
    }
    function Ye(H) {
        H ? B(n.SCISSOR_TEST) : ae(n.SCISSOR_TEST)
    }
    function pt(H) {
        H === void 0 && (H = n.TEXTURE0 + ie - 1),
        j !== H && (n.activeTexture(H),
        j = H)
    }
    function G(H, te, me) {
        me === void 0 && (j === null ? me = n.TEXTURE0 + ie - 1 : me = j);
        let Te = X[me];
        Te === void 0 && (Te = {
            type: void 0,
            texture: void 0
        },
        X[me] = Te),
        (Te.type !== H || Te.texture !== te) && (j !== me && (n.activeTexture(me),
        j = me),
        n.bindTexture(H, te || F[H]),
        Te.type = H,
        Te.texture = te)
    }
    function k() {
        const H = X[j];
        H !== void 0 && H.type !== void 0 && (n.bindTexture(H.type, null),
        H.type = void 0,
        H.texture = void 0)
    }
    function ee() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function we() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Ie() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Fe() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Je() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function We() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Me() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Qe() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function tt() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function st() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (H) {
            console.error("THREE.WebGLState:", H)
        }
    }
    function Xe(H) {
        U.equals(H) === !1 && (n.scissor(H.x, H.y, H.z, H.w),
        U.copy(H))
    }
    function K(H) {
        O.equals(H) === !1 && (n.viewport(H.x, H.y, H.z, H.w),
        O.copy(H))
    }
    function q(H, te) {
        let me = h.get(te);
        me === void 0 && (me = new WeakMap,
        h.set(te, me));
        let Te = me.get(H);
        Te === void 0 && (Te = n.getUniformBlockIndex(te, H.name),
        me.set(H, Te))
    }
    function xe(H, te) {
        const Te = h.get(te).get(H);
        d.get(te) !== Te && (n.uniformBlockBinding(te, Te, H.__bindingPointIndex),
        d.set(te, Te))
    }
    function Ne() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        p = {},
        j = null,
        X = {},
        m = {},
        y = new WeakMap,
        S = [],
        M = null,
        g = !1,
        _ = null,
        w = null,
        T = null,
        A = null,
        C = null,
        P = null,
        N = null,
        b = !1,
        L = null,
        Y = null,
        Z = null,
        $ = null,
        Q = null,
        U.set(0, 0, n.canvas.width, n.canvas.height),
        O.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        l.reset(),
        f.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: f
        },
        enable: B,
        disable: ae,
        bindFramebuffer: _e,
        drawBuffers: pe,
        useProgram: Ee,
        setBlending: ve,
        setMaterial: Ce,
        setFlipSided: Re,
        setCullFace: Le,
        setLineWidth: Be,
        setPolygonOffset: Ze,
        setScissorTest: Ye,
        activeTexture: pt,
        bindTexture: G,
        unbindTexture: k,
        compressedTexImage2D: ee,
        compressedTexImage3D: we,
        texImage2D: tt,
        texImage3D: st,
        updateUBOMapping: q,
        uniformBlockBinding: xe,
        texStorage2D: Me,
        texStorage3D: Qe,
        texSubImage2D: Ie,
        texSubImage3D: Fe,
        compressedTexSubImage2D: Je,
        compressedTexSubImage3D: We,
        scissor: Xe,
        viewport: K,
        reset: Ne
    }
}
function v9(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , l = r.maxTextures
      , f = r.maxCubemapSize
      , d = r.maxTextureSize
      , h = r.maxSamples
      , p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , y = new WeakMap;
    let S;
    const M = new WeakMap;
    let g = !1;
    try {
        g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function _(G, k) {
        return g ? new OffscreenCanvas(G,k) : rd("canvas")
    }
    function w(G, k, ee, we) {
        let Ie = 1;
        if ((G.width > we || G.height > we) && (Ie = we / Math.max(G.width, G.height)),
        Ie < 1 || k === !0)
            if (typeof HTMLImageElement < "u" && G instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && G instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && G instanceof ImageBitmap) {
                const Fe = k ? kL : Math.floor
                  , Je = Fe(Ie * G.width)
                  , We = Fe(Ie * G.height);
                S === void 0 && (S = _(Je, We));
                const Me = ee ? _(Je, We) : S;
                return Me.width = Je,
                Me.height = We,
                Me.getContext("2d").drawImage(G, 0, 0, Je, We),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + G.width + "x" + G.height + ") to (" + Je + "x" + We + ")."),
                Me
            } else
                return "data"in G && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + G.width + "x" + G.height + ")."),
                G;
        return G
    }
    function T(G) {
        return jx(G.width) && jx(G.height)
    }
    function A(G) {
        return a ? !1 : G.wrapS !== On || G.wrapT !== On || G.minFilter !== _n && G.minFilter !== dn
    }
    function C(G, k) {
        return G.generateMipmaps && k && G.minFilter !== _n && G.minFilter !== dn
    }
    function P(G) {
        n.generateMipmap(G)
    }
    function N(G, k, ee, we, Ie=!1) {
        if (a === !1)
            return k;
        if (G !== null) {
            if (n[G] !== void 0)
                return n[G];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + G + "'")
        }
        let Fe = k;
        return k === n.RED && (ee === n.FLOAT && (Fe = n.R32F),
        ee === n.HALF_FLOAT && (Fe = n.R16F),
        ee === n.UNSIGNED_BYTE && (Fe = n.R8)),
        k === n.RG && (ee === n.FLOAT && (Fe = n.RG32F),
        ee === n.HALF_FLOAT && (Fe = n.RG16F),
        ee === n.UNSIGNED_BYTE && (Fe = n.RG8)),
        k === n.RGBA && (ee === n.FLOAT && (Fe = n.RGBA32F),
        ee === n.HALF_FLOAT && (Fe = n.RGBA16F),
        ee === n.UNSIGNED_BYTE && (Fe = we === lt && Ie === !1 ? n.SRGB8_ALPHA8 : n.RGBA8),
        ee === n.UNSIGNED_SHORT_4_4_4_4 && (Fe = n.RGBA4),
        ee === n.UNSIGNED_SHORT_5_5_5_1 && (Fe = n.RGB5_A1)),
        (Fe === n.R16F || Fe === n.R32F || Fe === n.RG16F || Fe === n.RG32F || Fe === n.RGBA16F || Fe === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        Fe
    }
    function b(G, k, ee) {
        return C(G, ee) === !0 || G.isFramebufferTexture && G.minFilter !== _n && G.minFilter !== dn ? Math.log2(Math.max(k.width, k.height)) + 1 : G.mipmaps !== void 0 && G.mipmaps.length > 0 ? G.mipmaps.length : G.isCompressedTexture && Array.isArray(G.image) ? k.mipmaps.length : 1
    }
    function L(G) {
        return G === _n || G === td || G === Pc ? n.NEAREST : n.LINEAR
    }
    function Y(G) {
        const k = G.target;
        k.removeEventListener("dispose", Y),
        $(k),
        k.isVideoTexture && y.delete(k)
    }
    function Z(G) {
        const k = G.target;
        k.removeEventListener("dispose", Z),
        ie(k)
    }
    function $(G) {
        const k = i.get(G);
        if (k.__webglInit === void 0)
            return;
        const ee = G.source
          , we = M.get(ee);
        if (we) {
            const Ie = we[k.__cacheKey];
            Ie.usedTimes--,
            Ie.usedTimes === 0 && Q(G),
            Object.keys(we).length === 0 && M.delete(ee)
        }
        i.remove(G)
    }
    function Q(G) {
        const k = i.get(G);
        n.deleteTexture(k.__webglTexture);
        const ee = G.source
          , we = M.get(ee);
        delete we[k.__cacheKey],
        o.memory.textures--
    }
    function ie(G) {
        const k = G.texture
          , ee = i.get(G)
          , we = i.get(k);
        if (we.__webglTexture !== void 0 && (n.deleteTexture(we.__webglTexture),
        o.memory.textures--),
        G.depthTexture && G.depthTexture.dispose(),
        G.isWebGLCubeRenderTarget)
            for (let Ie = 0; Ie < 6; Ie++)
                n.deleteFramebuffer(ee.__webglFramebuffer[Ie]),
                ee.__webglDepthbuffer && n.deleteRenderbuffer(ee.__webglDepthbuffer[Ie]);
        else {
            if (n.deleteFramebuffer(ee.__webglFramebuffer),
            ee.__webglDepthbuffer && n.deleteRenderbuffer(ee.__webglDepthbuffer),
            ee.__webglMultisampledFramebuffer && n.deleteFramebuffer(ee.__webglMultisampledFramebuffer),
            ee.__webglColorRenderbuffer)
                for (let Ie = 0; Ie < ee.__webglColorRenderbuffer.length; Ie++)
                    ee.__webglColorRenderbuffer[Ie] && n.deleteRenderbuffer(ee.__webglColorRenderbuffer[Ie]);
            ee.__webglDepthRenderbuffer && n.deleteRenderbuffer(ee.__webglDepthRenderbuffer)
        }
        if (G.isWebGLMultipleRenderTargets)
            for (let Ie = 0, Fe = k.length; Ie < Fe; Ie++) {
                const Je = i.get(k[Ie]);
                Je.__webglTexture && (n.deleteTexture(Je.__webglTexture),
                o.memory.textures--),
                i.remove(k[Ie])
            }
        i.remove(k),
        i.remove(G)
    }
    let fe = 0;
    function le() {
        fe = 0
    }
    function D() {
        const G = fe;
        return G >= l && console.warn("THREE.WebGLTextures: Trying to use " + G + " texture units while this GPU supports only " + l),
        fe += 1,
        G
    }
    function j(G) {
        const k = [];
        return k.push(G.wrapS),
        k.push(G.wrapT),
        k.push(G.wrapR || 0),
        k.push(G.magFilter),
        k.push(G.minFilter),
        k.push(G.anisotropy),
        k.push(G.internalFormat),
        k.push(G.format),
        k.push(G.type),
        k.push(G.generateMipmaps),
        k.push(G.premultiplyAlpha),
        k.push(G.flipY),
        k.push(G.unpackAlignment),
        k.push(G.colorSpace),
        k.join()
    }
    function X(G, k) {
        const ee = i.get(G);
        if (G.isVideoTexture && Ye(G),
        G.isRenderTargetTexture === !1 && G.version > 0 && ee.__version !== G.version) {
            const we = G.image;
            if (we === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (we.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ae(ee, G, k);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, ee.__webglTexture, n.TEXTURE0 + k)
    }
    function ue(G, k) {
        const ee = i.get(G);
        if (G.version > 0 && ee.__version !== G.version) {
            ae(ee, G, k);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, ee.__webglTexture, n.TEXTURE0 + k)
    }
    function I(G, k) {
        const ee = i.get(G);
        if (G.version > 0 && ee.__version !== G.version) {
            ae(ee, G, k);
            return
        }
        t.bindTexture(n.TEXTURE_3D, ee.__webglTexture, n.TEXTURE0 + k)
    }
    function U(G, k) {
        const ee = i.get(G);
        if (G.version > 0 && ee.__version !== G.version) {
            _e(ee, G, k);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, ee.__webglTexture, n.TEXTURE0 + k)
    }
    const O = {
        [Yn]: n.REPEAT,
        [On]: n.CLAMP_TO_EDGE,
        [qc]: n.MIRRORED_REPEAT
    }
      , J = {
        [_n]: n.NEAREST,
        [td]: n.NEAREST_MIPMAP_NEAREST,
        [Pc]: n.NEAREST_MIPMAP_LINEAR,
        [dn]: n.LINEAR,
        [u0]: n.LINEAR_MIPMAP_NEAREST,
        [ws]: n.LINEAR_MIPMAP_LINEAR
    };
    function F(G, k, ee) {
        if (ee ? (n.texParameteri(G, n.TEXTURE_WRAP_S, O[k.wrapS]),
        n.texParameteri(G, n.TEXTURE_WRAP_T, O[k.wrapT]),
        (G === n.TEXTURE_3D || G === n.TEXTURE_2D_ARRAY) && n.texParameteri(G, n.TEXTURE_WRAP_R, O[k.wrapR]),
        n.texParameteri(G, n.TEXTURE_MAG_FILTER, J[k.magFilter]),
        n.texParameteri(G, n.TEXTURE_MIN_FILTER, J[k.minFilter])) : (n.texParameteri(G, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
        n.texParameteri(G, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
        (G === n.TEXTURE_3D || G === n.TEXTURE_2D_ARRAY) && n.texParameteri(G, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
        (k.wrapS !== On || k.wrapT !== On) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(G, n.TEXTURE_MAG_FILTER, L(k.magFilter)),
        n.texParameteri(G, n.TEXTURE_MIN_FILTER, L(k.minFilter)),
        k.minFilter !== _n && k.minFilter !== dn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const we = e.get("EXT_texture_filter_anisotropic");
            if (k.magFilter === _n || k.minFilter !== Pc && k.minFilter !== ws || k.type === Ys && e.has("OES_texture_float_linear") === !1 || a === !1 && k.type === Kc && e.has("OES_texture_half_float_linear") === !1)
                return;
            (k.anisotropy > 1 || i.get(k).__currentAnisotropy) && (n.texParameterf(G, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(k.anisotropy, r.getMaxAnisotropy())),
            i.get(k).__currentAnisotropy = k.anisotropy)
        }
    }
    function B(G, k) {
        let ee = !1;
        G.__webglInit === void 0 && (G.__webglInit = !0,
        k.addEventListener("dispose", Y));
        const we = k.source;
        let Ie = M.get(we);
        Ie === void 0 && (Ie = {},
        M.set(we, Ie));
        const Fe = j(k);
        if (Fe !== G.__cacheKey) {
            Ie[Fe] === void 0 && (Ie[Fe] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            ee = !0),
            Ie[Fe].usedTimes++;
            const Je = Ie[G.__cacheKey];
            Je !== void 0 && (Ie[G.__cacheKey].usedTimes--,
            Je.usedTimes === 0 && Q(k)),
            G.__cacheKey = Fe,
            G.__webglTexture = Ie[Fe].texture
        }
        return ee
    }
    function ae(G, k, ee) {
        let we = n.TEXTURE_2D;
        (k.isDataArrayTexture || k.isCompressedArrayTexture) && (we = n.TEXTURE_2D_ARRAY),
        k.isData3DTexture && (we = n.TEXTURE_3D);
        const Ie = B(G, k)
          , Fe = k.source;
        t.bindTexture(we, G.__webglTexture, n.TEXTURE0 + ee);
        const Je = i.get(Fe);
        if (Fe.version !== Je.__version || Ie === !0) {
            t.activeTexture(n.TEXTURE0 + ee),
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, k.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, k.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
            const We = A(k) && T(k.image) === !1;
            let Me = w(k.image, We, !1, d);
            Me = pt(k, Me);
            const Qe = T(Me) || a
              , tt = s.convert(k.format, k.colorSpace);
            let st = s.convert(k.type)
              , Xe = N(k.internalFormat, tt, st, k.colorSpace);
            F(we, k, Qe);
            let K;
            const q = k.mipmaps
              , xe = a && k.isVideoTexture !== !0
              , Ne = Je.__version === void 0 || Ie === !0
              , H = b(k, Me, Qe);
            if (k.isDepthTexture)
                Xe = n.DEPTH_COMPONENT,
                a ? k.type === Ys ? Xe = n.DEPTH_COMPONENT32F : k.type === Uo ? Xe = n.DEPTH_COMPONENT24 : k.type === Ha ? Xe = n.DEPTH24_STENCIL8 : Xe = n.DEPTH_COMPONENT16 : k.type === Ys && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                k.format === $o && Xe === n.DEPTH_COMPONENT && k.type !== N1 && k.type !== Uo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                k.type = Uo,
                st = s.convert(k.type)),
                k.format === Ja && Xe === n.DEPTH_COMPONENT && (Xe = n.DEPTH_STENCIL,
                k.type !== Ha && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                k.type = Ha,
                st = s.convert(k.type))),
                Ne && (xe ? t.texStorage2D(n.TEXTURE_2D, 1, Xe, Me.width, Me.height) : t.texImage2D(n.TEXTURE_2D, 0, Xe, Me.width, Me.height, 0, tt, st, null));
            else if (k.isDataTexture)
                if (q.length > 0 && Qe) {
                    xe && Ne && t.texStorage2D(n.TEXTURE_2D, H, Xe, q[0].width, q[0].height);
                    for (let te = 0, me = q.length; te < me; te++)
                        K = q[te],
                        xe ? t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, K.width, K.height, tt, st, K.data) : t.texImage2D(n.TEXTURE_2D, te, Xe, K.width, K.height, 0, tt, st, K.data);
                    k.generateMipmaps = !1
                } else
                    xe ? (Ne && t.texStorage2D(n.TEXTURE_2D, H, Xe, Me.width, Me.height),
                    t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Me.width, Me.height, tt, st, Me.data)) : t.texImage2D(n.TEXTURE_2D, 0, Xe, Me.width, Me.height, 0, tt, st, Me.data);
            else if (k.isCompressedTexture)
                if (k.isCompressedArrayTexture) {
                    xe && Ne && t.texStorage3D(n.TEXTURE_2D_ARRAY, H, Xe, q[0].width, q[0].height, Me.depth);
                    for (let te = 0, me = q.length; te < me; te++)
                        K = q[te],
                        k.format !== Ii ? tt !== null ? xe ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, te, 0, 0, 0, K.width, K.height, Me.depth, tt, K.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, te, Xe, K.width, K.height, Me.depth, 0, K.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : xe ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, te, 0, 0, 0, K.width, K.height, Me.depth, tt, st, K.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, te, Xe, K.width, K.height, Me.depth, 0, tt, st, K.data)
                } else {
                    xe && Ne && t.texStorage2D(n.TEXTURE_2D, H, Xe, q[0].width, q[0].height);
                    for (let te = 0, me = q.length; te < me; te++)
                        K = q[te],
                        k.format !== Ii ? tt !== null ? xe ? t.compressedTexSubImage2D(n.TEXTURE_2D, te, 0, 0, K.width, K.height, tt, K.data) : t.compressedTexImage2D(n.TEXTURE_2D, te, Xe, K.width, K.height, 0, K.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : xe ? t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, K.width, K.height, tt, st, K.data) : t.texImage2D(n.TEXTURE_2D, te, Xe, K.width, K.height, 0, tt, st, K.data)
                }
            else if (k.isDataArrayTexture)
                xe ? (Ne && t.texStorage3D(n.TEXTURE_2D_ARRAY, H, Xe, Me.width, Me.height, Me.depth),
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Me.width, Me.height, Me.depth, tt, st, Me.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Xe, Me.width, Me.height, Me.depth, 0, tt, st, Me.data);
            else if (k.isData3DTexture)
                xe ? (Ne && t.texStorage3D(n.TEXTURE_3D, H, Xe, Me.width, Me.height, Me.depth),
                t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Me.width, Me.height, Me.depth, tt, st, Me.data)) : t.texImage3D(n.TEXTURE_3D, 0, Xe, Me.width, Me.height, Me.depth, 0, tt, st, Me.data);
            else if (k.isFramebufferTexture) {
                if (Ne)
                    if (xe)
                        t.texStorage2D(n.TEXTURE_2D, H, Xe, Me.width, Me.height);
                    else {
                        let te = Me.width
                          , me = Me.height;
                        for (let Te = 0; Te < H; Te++)
                            t.texImage2D(n.TEXTURE_2D, Te, Xe, te, me, 0, tt, st, null),
                            te >>= 1,
                            me >>= 1
                    }
            } else if (q.length > 0 && Qe) {
                xe && Ne && t.texStorage2D(n.TEXTURE_2D, H, Xe, q[0].width, q[0].height);
                for (let te = 0, me = q.length; te < me; te++)
                    K = q[te],
                    xe ? t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, tt, st, K) : t.texImage2D(n.TEXTURE_2D, te, Xe, tt, st, K);
                k.generateMipmaps = !1
            } else
                xe ? (Ne && t.texStorage2D(n.TEXTURE_2D, H, Xe, Me.width, Me.height),
                t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, tt, st, Me)) : t.texImage2D(n.TEXTURE_2D, 0, Xe, tt, st, Me);
            C(k, Qe) && P(we),
            Je.__version = Fe.version,
            k.onUpdate && k.onUpdate(k)
        }
        G.__version = k.version
    }
    function _e(G, k, ee) {
        if (k.image.length !== 6)
            return;
        const we = B(G, k)
          , Ie = k.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, G.__webglTexture, n.TEXTURE0 + ee);
        const Fe = i.get(Ie);
        if (Ie.version !== Fe.__version || we === !0) {
            t.activeTexture(n.TEXTURE0 + ee),
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, k.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, k.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
            const Je = k.isCompressedTexture || k.image[0].isCompressedTexture
              , We = k.image[0] && k.image[0].isDataTexture
              , Me = [];
            for (let te = 0; te < 6; te++)
                !Je && !We ? Me[te] = w(k.image[te], !1, !0, f) : Me[te] = We ? k.image[te].image : k.image[te],
                Me[te] = pt(k, Me[te]);
            const Qe = Me[0]
              , tt = T(Qe) || a
              , st = s.convert(k.format, k.colorSpace)
              , Xe = s.convert(k.type)
              , K = N(k.internalFormat, st, Xe, k.colorSpace)
              , q = a && k.isVideoTexture !== !0
              , xe = Fe.__version === void 0 || we === !0;
            let Ne = b(k, Qe, tt);
            F(n.TEXTURE_CUBE_MAP, k, tt);
            let H;
            if (Je) {
                q && xe && t.texStorage2D(n.TEXTURE_CUBE_MAP, Ne, K, Qe.width, Qe.height);
                for (let te = 0; te < 6; te++) {
                    H = Me[te].mipmaps;
                    for (let me = 0; me < H.length; me++) {
                        const Te = H[me];
                        k.format !== Ii ? st !== null ? q ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me, 0, 0, Te.width, Te.height, st, Te.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me, K, Te.width, Te.height, 0, Te.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : q ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me, 0, 0, Te.width, Te.height, st, Xe, Te.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me, K, Te.width, Te.height, 0, st, Xe, Te.data)
                    }
                }
            } else {
                H = k.mipmaps,
                q && xe && (H.length > 0 && Ne++,
                t.texStorage2D(n.TEXTURE_CUBE_MAP, Ne, K, Me[0].width, Me[0].height));
                for (let te = 0; te < 6; te++)
                    if (We) {
                        q ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, Me[te].width, Me[te].height, st, Xe, Me[te].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, K, Me[te].width, Me[te].height, 0, st, Xe, Me[te].data);
                        for (let me = 0; me < H.length; me++) {
                            const Pe = H[me].image[te].image;
                            q ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me + 1, 0, 0, Pe.width, Pe.height, st, Xe, Pe.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me + 1, K, Pe.width, Pe.height, 0, st, Xe, Pe.data)
                        }
                    } else {
                        q ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, st, Xe, Me[te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, K, st, Xe, Me[te]);
                        for (let me = 0; me < H.length; me++) {
                            const Te = H[me];
                            q ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me + 1, 0, 0, st, Xe, Te.image[te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, me + 1, K, st, Xe, Te.image[te])
                        }
                    }
            }
            C(k, tt) && P(n.TEXTURE_CUBE_MAP),
            Fe.__version = Ie.version,
            k.onUpdate && k.onUpdate(k)
        }
        G.__version = k.version
    }
    function pe(G, k, ee, we, Ie) {
        const Fe = s.convert(ee.format, ee.colorSpace)
          , Je = s.convert(ee.type)
          , We = N(ee.internalFormat, Fe, Je, ee.colorSpace);
        i.get(k).__hasExternalTextures || (Ie === n.TEXTURE_3D || Ie === n.TEXTURE_2D_ARRAY ? t.texImage3D(Ie, 0, We, k.width, k.height, k.depth, 0, Fe, Je, null) : t.texImage2D(Ie, 0, We, k.width, k.height, 0, Fe, Je, null)),
        t.bindFramebuffer(n.FRAMEBUFFER, G),
        Ze(k) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, we, Ie, i.get(ee).__webglTexture, 0, Be(k)) : (Ie === n.TEXTURE_2D || Ie >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Ie <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, we, Ie, i.get(ee).__webglTexture, 0),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function Ee(G, k, ee) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, G),
        k.depthBuffer && !k.stencilBuffer) {
            let we = n.DEPTH_COMPONENT16;
            if (ee || Ze(k)) {
                const Ie = k.depthTexture;
                Ie && Ie.isDepthTexture && (Ie.type === Ys ? we = n.DEPTH_COMPONENT32F : Ie.type === Uo && (we = n.DEPTH_COMPONENT24));
                const Fe = Be(k);
                Ze(k) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Fe, we, k.width, k.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, Fe, we, k.width, k.height)
            } else
                n.renderbufferStorage(n.RENDERBUFFER, we, k.width, k.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, G)
        } else if (k.depthBuffer && k.stencilBuffer) {
            const we = Be(k);
            ee && Ze(k) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, we, n.DEPTH24_STENCIL8, k.width, k.height) : Ze(k) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, we, n.DEPTH24_STENCIL8, k.width, k.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, k.width, k.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, G)
        } else {
            const we = k.isWebGLMultipleRenderTargets === !0 ? k.texture : [k.texture];
            for (let Ie = 0; Ie < we.length; Ie++) {
                const Fe = we[Ie]
                  , Je = s.convert(Fe.format, Fe.colorSpace)
                  , We = s.convert(Fe.type)
                  , Me = N(Fe.internalFormat, Je, We, Fe.colorSpace)
                  , Qe = Be(k);
                ee && Ze(k) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Qe, Me, k.width, k.height) : Ze(k) ? p.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Qe, Me, k.width, k.height) : n.renderbufferStorage(n.RENDERBUFFER, Me, k.width, k.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function se(G, k) {
        if (k && k.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, G),
        !(k.depthTexture && k.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(k.depthTexture).__webglTexture || k.depthTexture.image.width !== k.width || k.depthTexture.image.height !== k.height) && (k.depthTexture.image.width = k.width,
        k.depthTexture.image.height = k.height,
        k.depthTexture.needsUpdate = !0),
        X(k.depthTexture, 0);
        const we = i.get(k.depthTexture).__webglTexture
          , Ie = Be(k);
        if (k.depthTexture.format === $o)
            Ze(k) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, we, 0, Ie) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, we, 0);
        else if (k.depthTexture.format === Ja)
            Ze(k) ? p.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, we, 0, Ie) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, we, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function oe(G) {
        const k = i.get(G)
          , ee = G.isWebGLCubeRenderTarget === !0;
        if (G.depthTexture && !k.__autoAllocateDepthBuffer) {
            if (ee)
                throw new Error("target.depthTexture not supported in Cube render targets");
            se(k.__webglFramebuffer, G)
        } else if (ee) {
            k.__webglDepthbuffer = [];
            for (let we = 0; we < 6; we++)
                t.bindFramebuffer(n.FRAMEBUFFER, k.__webglFramebuffer[we]),
                k.__webglDepthbuffer[we] = n.createRenderbuffer(),
                Ee(k.__webglDepthbuffer[we], G, !1)
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, k.__webglFramebuffer),
            k.__webglDepthbuffer = n.createRenderbuffer(),
            Ee(k.__webglDepthbuffer, G, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function ve(G, k, ee) {
        const we = i.get(G);
        k !== void 0 && pe(we.__webglFramebuffer, G, G.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D),
        ee !== void 0 && oe(G)
    }
    function Ce(G) {
        const k = G.texture
          , ee = i.get(G)
          , we = i.get(k);
        G.addEventListener("dispose", Z),
        G.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = n.createTexture()),
        we.__version = k.version,
        o.memory.textures++);
        const Ie = G.isWebGLCubeRenderTarget === !0
          , Fe = G.isWebGLMultipleRenderTargets === !0
          , Je = T(G) || a;
        if (Ie) {
            ee.__webglFramebuffer = [];
            for (let We = 0; We < 6; We++)
                ee.__webglFramebuffer[We] = n.createFramebuffer()
        } else {
            if (ee.__webglFramebuffer = n.createFramebuffer(),
            Fe)
                if (r.drawBuffers) {
                    const We = G.texture;
                    for (let Me = 0, Qe = We.length; Me < Qe; Me++) {
                        const tt = i.get(We[Me]);
                        tt.__webglTexture === void 0 && (tt.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && G.samples > 0 && Ze(G) === !1) {
                const We = Fe ? k : [k];
                ee.__webglMultisampledFramebuffer = n.createFramebuffer(),
                ee.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, ee.__webglMultisampledFramebuffer);
                for (let Me = 0; Me < We.length; Me++) {
                    const Qe = We[Me];
                    ee.__webglColorRenderbuffer[Me] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, ee.__webglColorRenderbuffer[Me]);
                    const tt = s.convert(Qe.format, Qe.colorSpace)
                      , st = s.convert(Qe.type)
                      , Xe = N(Qe.internalFormat, tt, st, Qe.colorSpace, G.isXRRenderTarget === !0)
                      , K = Be(G);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, K, Xe, G.width, G.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Me, n.RENDERBUFFER, ee.__webglColorRenderbuffer[Me])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                G.depthBuffer && (ee.__webglDepthRenderbuffer = n.createRenderbuffer(),
                Ee(ee.__webglDepthRenderbuffer, G, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (Ie) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, we.__webglTexture),
            F(n.TEXTURE_CUBE_MAP, k, Je);
            for (let We = 0; We < 6; We++)
                pe(ee.__webglFramebuffer[We], G, k, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + We);
            C(k, Je) && P(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (Fe) {
            const We = G.texture;
            for (let Me = 0, Qe = We.length; Me < Qe; Me++) {
                const tt = We[Me]
                  , st = i.get(tt);
                t.bindTexture(n.TEXTURE_2D, st.__webglTexture),
                F(n.TEXTURE_2D, tt, Je),
                pe(ee.__webglFramebuffer, G, tt, n.COLOR_ATTACHMENT0 + Me, n.TEXTURE_2D),
                C(tt, Je) && P(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let We = n.TEXTURE_2D;
            (G.isWebGL3DRenderTarget || G.isWebGLArrayRenderTarget) && (a ? We = G.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(We, we.__webglTexture),
            F(We, k, Je),
            pe(ee.__webglFramebuffer, G, k, n.COLOR_ATTACHMENT0, We),
            C(k, Je) && P(We),
            t.unbindTexture()
        }
        G.depthBuffer && oe(G)
    }
    function Re(G) {
        const k = T(G) || a
          , ee = G.isWebGLMultipleRenderTargets === !0 ? G.texture : [G.texture];
        for (let we = 0, Ie = ee.length; we < Ie; we++) {
            const Fe = ee[we];
            if (C(Fe, k)) {
                const Je = G.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , We = i.get(Fe).__webglTexture;
                t.bindTexture(Je, We),
                P(Je),
                t.unbindTexture()
            }
        }
    }
    function Le(G) {
        if (a && G.samples > 0 && Ze(G) === !1) {
            const k = G.isWebGLMultipleRenderTargets ? G.texture : [G.texture]
              , ee = G.width
              , we = G.height;
            let Ie = n.COLOR_BUFFER_BIT;
            const Fe = []
              , Je = G.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , We = i.get(G)
              , Me = G.isWebGLMultipleRenderTargets === !0;
            if (Me)
                for (let Qe = 0; Qe < k.length; Qe++)
                    t.bindFramebuffer(n.FRAMEBUFFER, We.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.RENDERBUFFER, null),
                    t.bindFramebuffer(n.FRAMEBUFFER, We.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, We.__webglMultisampledFramebuffer),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, We.__webglFramebuffer);
            for (let Qe = 0; Qe < k.length; Qe++) {
                Fe.push(n.COLOR_ATTACHMENT0 + Qe),
                G.depthBuffer && Fe.push(Je);
                const tt = We.__ignoreDepthValues !== void 0 ? We.__ignoreDepthValues : !1;
                if (tt === !1 && (G.depthBuffer && (Ie |= n.DEPTH_BUFFER_BIT),
                G.stencilBuffer && (Ie |= n.STENCIL_BUFFER_BIT)),
                Me && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, We.__webglColorRenderbuffer[Qe]),
                tt === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Je]),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Je])),
                Me) {
                    const st = i.get(k[Qe]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, st, 0)
                }
                n.blitFramebuffer(0, 0, ee, we, 0, 0, ee, we, Ie, n.NEAREST),
                m && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Fe)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
            Me)
                for (let Qe = 0; Qe < k.length; Qe++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, We.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.RENDERBUFFER, We.__webglColorRenderbuffer[Qe]);
                    const tt = i.get(k[Qe]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, We.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.TEXTURE_2D, tt, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, We.__webglMultisampledFramebuffer)
        }
    }
    function Be(G) {
        return Math.min(h, G.samples)
    }
    function Ze(G) {
        const k = i.get(G);
        return a && G.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && k.__useRenderToTexture !== !1
    }
    function Ye(G) {
        const k = o.render.frame;
        y.get(G) !== k && (y.set(G, k),
        G.update())
    }
    function pt(G, k) {
        const ee = G.colorSpace
          , we = G.format
          , Ie = G.type;
        return G.isCompressedTexture === !0 || G.format === eg || ee !== Qr && ee !== Yo && (ee === lt ? a === !1 ? e.has("EXT_sRGB") === !0 && we === Ii ? (G.format = eg,
        G.minFilter = dn,
        G.generateMipmaps = !1) : k = z1.sRGBToLinear(k) : (we !== Ii || Ie !== to) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ee)),
        k
    }
    this.allocateTextureUnit = D,
    this.resetTextureUnits = le,
    this.setTexture2D = X,
    this.setTexture2DArray = ue,
    this.setTexture3D = I,
    this.setTextureCube = U,
    this.rebindTextures = ve,
    this.setupRenderTarget = Ce,
    this.updateRenderTargetMipmap = Re,
    this.updateMultisampleRenderTarget = Le,
    this.setupDepthRenderbuffer = oe,
    this.setupFrameBufferTexture = pe,
    this.useMultisampledRTT = Ze
}
function YL(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=Yo) {
        let a;
        if (s === to)
            return n.UNSIGNED_BYTE;
        if (s === mL)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === gL)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === dL)
            return n.BYTE;
        if (s === hL)
            return n.SHORT;
        if (s === N1)
            return n.UNSIGNED_SHORT;
        if (s === pL)
            return n.INT;
        if (s === Uo)
            return n.UNSIGNED_INT;
        if (s === Ys)
            return n.FLOAT;
        if (s === Kc)
            return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === vL)
            return n.ALPHA;
        if (s === Ii)
            return n.RGBA;
        if (s === yL)
            return n.LUMINANCE;
        if (s === _L)
            return n.LUMINANCE_ALPHA;
        if (s === $o)
            return n.DEPTH_COMPONENT;
        if (s === Ja)
            return n.DEPTH_STENCIL;
        if (s === eg)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === xL)
            return n.RED;
        if (s === SL)
            return n.RED_INTEGER;
        if (s === wL)
            return n.RG;
        if (s === ML)
            return n.RG_INTEGER;
        if (s === EL)
            return n.RGBA_INTEGER;
        if (s === pm || s === mm || s === gm || s === vm)
            if (o === lt)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === pm)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === mm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === gm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === vm)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === pm)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === mm)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === gm)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === vm)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === Mx || s === Ex || s === Tx || s === Ax)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === Mx)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === Ex)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === Tx)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === Ax)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === TL)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === Rx || s === Cx)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === Rx)
                    return o === lt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === Cx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === bx || s === Px || s === Lx || s === Ix || s === Nx || s === Dx || s === Ux || s === kx || s === Ox || s === Fx || s === zx || s === Bx || s === Vx || s === Hx)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === bx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === Px)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === Lx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === Ix)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === Nx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === Dx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === Ux)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === kx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === Ox)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === Fx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === zx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === Bx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === Vx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === Hx)
                    return o === lt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === ym)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === ym)
                    return o === lt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (s === AL || s === Gx || s === Wx || s === Xx)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === ym)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === Gx)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === Wx)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === Xx)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === Ha ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class qL extends Pn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class xr extends Lt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const y9 = {
    type: "move"
};
class Dy {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new xr,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new xr,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new z,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new z),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new xr,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new z,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new z),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , f = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (f && e.hand) {
                o = !0;
                for (const S of e.hand.values()) {
                    const M = t.getJointPose(S, i)
                      , g = this._getHandJoint(f, S);
                    M !== null && (g.matrix.fromArray(M.transform.matrix),
                    g.matrix.decompose(g.position, g.rotation, g.scale),
                    g.matrixWorldNeedsUpdate = !0,
                    g.jointRadius = M.radius),
                    g.visible = M !== null
                }
                const d = f.joints["index-finger-tip"]
                  , h = f.joints["thumb-tip"]
                  , p = d.position.distanceTo(h.position)
                  , m = .02
                  , y = .005;
                f.inputState.pinching && p > m + y ? (f.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !f.inputState.pinching && p <= m - y && (f.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(y9)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        f !== null && (f.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new xr;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class KL extends en {
    constructor(e, t, i, r, s, o, a, l, f, d) {
        if (d = d !== void 0 ? d : $o,
        d !== $o && d !== Ja)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && d === $o && (i = Uo),
        i === void 0 && d === Ja && (i = Ha),
        super(null, r, s, o, a, l, d, i, f),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : _n,
        this.minFilter = l !== void 0 ? l : _n,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class _9 extends so {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , f = null
          , d = null
          , h = null
          , p = null
          , m = null
          , y = null;
        const S = t.getContextAttributes();
        let M = null
          , g = null;
        const _ = []
          , w = []
          , T = new Set
          , A = new Map
          , C = new Pn;
        C.layers.enable(1),
        C.viewport = new Ut;
        const P = new Pn;
        P.layers.enable(2),
        P.viewport = new Ut;
        const N = [C, P]
          , b = new qL;
        b.layers.enable(1),
        b.layers.enable(2);
        let L = null
          , Y = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(U) {
            let O = _[U];
            return O === void 0 && (O = new Dy,
            _[U] = O),
            O.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(U) {
            let O = _[U];
            return O === void 0 && (O = new Dy,
            _[U] = O),
            O.getGripSpace()
        }
        ,
        this.getHand = function(U) {
            let O = _[U];
            return O === void 0 && (O = new Dy,
            _[U] = O),
            O.getHandSpace()
        }
        ;
        function Z(U) {
            const O = w.indexOf(U.inputSource);
            if (O === -1)
                return;
            const J = _[O];
            J !== void 0 && (J.update(U.inputSource, U.frame, f || o),
            J.dispatchEvent({
                type: U.type,
                data: U.inputSource
            }))
        }
        function $() {
            r.removeEventListener("select", Z),
            r.removeEventListener("selectstart", Z),
            r.removeEventListener("selectend", Z),
            r.removeEventListener("squeeze", Z),
            r.removeEventListener("squeezestart", Z),
            r.removeEventListener("squeezeend", Z),
            r.removeEventListener("end", $),
            r.removeEventListener("inputsourceschange", Q);
            for (let U = 0; U < _.length; U++) {
                const O = w[U];
                O !== null && (w[U] = null,
                _[U].disconnect(O))
            }
            L = null,
            Y = null,
            e.setRenderTarget(M),
            m = null,
            p = null,
            h = null,
            r = null,
            g = null,
            I.stop(),
            i.isPresenting = !1,
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(U) {
            s = U,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(U) {
            a = U,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return f || o
        }
        ,
        this.setReferenceSpace = function(U) {
            f = U
        }
        ,
        this.getBaseLayer = function() {
            return p !== null ? p : m
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return y
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(U) {
            if (r = U,
            r !== null) {
                if (M = e.getRenderTarget(),
                r.addEventListener("select", Z),
                r.addEventListener("selectstart", Z),
                r.addEventListener("selectend", Z),
                r.addEventListener("squeeze", Z),
                r.addEventListener("squeezestart", Z),
                r.addEventListener("squeezeend", Z),
                r.addEventListener("end", $),
                r.addEventListener("inputsourceschange", Q),
                S.xrCompatible !== !0 && await t.makeXRCompatible(),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const O = {
                        antialias: r.renderState.layers === void 0 ? S.antialias : !0,
                        alpha: !0,
                        depth: S.depth,
                        stencil: S.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(r,t,O),
                    r.updateRenderState({
                        baseLayer: m
                    }),
                    g = new Jr(m.framebufferWidth,m.framebufferHeight,{
                        format: Ii,
                        type: to,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: S.stencil
                    })
                } else {
                    let O = null
                      , J = null
                      , F = null;
                    S.depth && (F = S.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    O = S.stencil ? Ja : $o,
                    J = S.stencil ? Ha : Uo);
                    const B = {
                        colorFormat: t.RGBA8,
                        depthFormat: F,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    p = h.createProjectionLayer(B),
                    r.updateRenderState({
                        layers: [p]
                    }),
                    g = new Jr(p.textureWidth,p.textureHeight,{
                        format: Ii,
                        type: to,
                        depthTexture: new KL(p.textureWidth,p.textureHeight,J,void 0,void 0,void 0,void 0,void 0,void 0,O),
                        stencilBuffer: S.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: S.antialias ? 4 : 0
                    });
                    const ae = e.properties.get(g);
                    ae.__ignoreDepthValues = p.ignoreDepthValues
                }
                g.isXRRenderTarget = !0,
                this.setFoveation(l),
                f = null,
                o = await r.requestReferenceSpace(a),
                I.setContext(r),
                I.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ;
        function Q(U) {
            for (let O = 0; O < U.removed.length; O++) {
                const J = U.removed[O]
                  , F = w.indexOf(J);
                F >= 0 && (w[F] = null,
                _[F].disconnect(J))
            }
            for (let O = 0; O < U.added.length; O++) {
                const J = U.added[O];
                let F = w.indexOf(J);
                if (F === -1) {
                    for (let ae = 0; ae < _.length; ae++)
                        if (ae >= w.length) {
                            w.push(J),
                            F = ae;
                            break
                        } else if (w[ae] === null) {
                            w[ae] = J,
                            F = ae;
                            break
                        }
                    if (F === -1)
                        break
                }
                const B = _[F];
                B && B.connect(J)
            }
        }
        const ie = new z
          , fe = new z;
        function le(U, O, J) {
            ie.setFromMatrixPosition(O.matrixWorld),
            fe.setFromMatrixPosition(J.matrixWorld);
            const F = ie.distanceTo(fe)
              , B = O.projectionMatrix.elements
              , ae = J.projectionMatrix.elements
              , _e = B[14] / (B[10] - 1)
              , pe = B[14] / (B[10] + 1)
              , Ee = (B[9] + 1) / B[5]
              , se = (B[9] - 1) / B[5]
              , oe = (B[8] - 1) / B[0]
              , ve = (ae[8] + 1) / ae[0]
              , Ce = _e * oe
              , Re = _e * ve
              , Le = F / (-oe + ve)
              , Be = Le * -oe;
            O.matrixWorld.decompose(U.position, U.quaternion, U.scale),
            U.translateX(Be),
            U.translateZ(Le),
            U.matrixWorld.compose(U.position, U.quaternion, U.scale),
            U.matrixWorldInverse.copy(U.matrixWorld).invert();
            const Ze = _e + Le
              , Ye = pe + Le
              , pt = Ce - Be
              , G = Re + (F - Be)
              , k = Ee * pe / Ye * Ze
              , ee = se * pe / Ye * Ze;
            U.projectionMatrix.makePerspective(pt, G, k, ee, Ze, Ye),
            U.projectionMatrixInverse.copy(U.projectionMatrix).invert()
        }
        function D(U, O) {
            O === null ? U.matrixWorld.copy(U.matrix) : U.matrixWorld.multiplyMatrices(O.matrixWorld, U.matrix),
            U.matrixWorldInverse.copy(U.matrixWorld).invert()
        }
        this.updateCamera = function(U) {
            if (r === null)
                return;
            b.near = P.near = C.near = U.near,
            b.far = P.far = C.far = U.far,
            (L !== b.near || Y !== b.far) && (r.updateRenderState({
                depthNear: b.near,
                depthFar: b.far
            }),
            L = b.near,
            Y = b.far);
            const O = U.parent
              , J = b.cameras;
            D(b, O);
            for (let F = 0; F < J.length; F++)
                D(J[F], O);
            J.length === 2 ? le(b, C, P) : b.projectionMatrix.copy(C.projectionMatrix),
            j(U, b, O)
        }
        ;
        function j(U, O, J) {
            J === null ? U.matrix.copy(O.matrixWorld) : (U.matrix.copy(J.matrixWorld),
            U.matrix.invert(),
            U.matrix.multiply(O.matrixWorld)),
            U.matrix.decompose(U.position, U.quaternion, U.scale),
            U.updateMatrixWorld(!0);
            const F = U.children;
            for (let B = 0, ae = F.length; B < ae; B++)
                F[B].updateMatrixWorld(!0);
            U.projectionMatrix.copy(O.projectionMatrix),
            U.projectionMatrixInverse.copy(O.projectionMatrixInverse),
            U.isPerspectiveCamera && (U.fov = Qc * 2 * Math.atan(1 / U.projectionMatrix.elements[5]),
            U.zoom = 1)
        }
        this.getCamera = function() {
            return b
        }
        ,
        this.getFoveation = function() {
            if (!(p === null && m === null))
                return l
        }
        ,
        this.setFoveation = function(U) {
            l = U,
            p !== null && (p.fixedFoveation = U),
            m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = U)
        }
        ,
        this.getPlanes = function() {
            return T
        }
        ;
        let X = null;
        function ue(U, O) {
            if (d = O.getViewerPose(f || o),
            y = O,
            d !== null) {
                const J = d.views;
                m !== null && (e.setRenderTargetFramebuffer(g, m.framebuffer),
                e.setRenderTarget(g));
                let F = !1;
                J.length !== b.cameras.length && (b.cameras.length = 0,
                F = !0);
                for (let B = 0; B < J.length; B++) {
                    const ae = J[B];
                    let _e = null;
                    if (m !== null)
                        _e = m.getViewport(ae);
                    else {
                        const Ee = h.getViewSubImage(p, ae);
                        _e = Ee.viewport,
                        B === 0 && (e.setRenderTargetTextures(g, Ee.colorTexture, p.ignoreDepthValues ? void 0 : Ee.depthStencilTexture),
                        e.setRenderTarget(g))
                    }
                    let pe = N[B];
                    pe === void 0 && (pe = new Pn,
                    pe.layers.enable(B),
                    pe.viewport = new Ut,
                    N[B] = pe),
                    pe.matrix.fromArray(ae.transform.matrix),
                    pe.matrix.decompose(pe.position, pe.quaternion, pe.scale),
                    pe.projectionMatrix.fromArray(ae.projectionMatrix),
                    pe.projectionMatrixInverse.copy(pe.projectionMatrix).invert(),
                    pe.viewport.set(_e.x, _e.y, _e.width, _e.height),
                    B === 0 && (b.matrix.copy(pe.matrix),
                    b.matrix.decompose(b.position, b.quaternion, b.scale)),
                    F === !0 && b.cameras.push(pe)
                }
            }
            for (let J = 0; J < _.length; J++) {
                const F = w[J]
                  , B = _[J];
                F !== null && B !== void 0 && B.update(F, O, f || o)
            }
            if (X && X(U, O),
            O.detectedPlanes) {
                i.dispatchEvent({
                    type: "planesdetected",
                    data: O.detectedPlanes
                });
                let J = null;
                for (const F of T)
                    O.detectedPlanes.has(F) || (J === null && (J = []),
                    J.push(F));
                if (J !== null)
                    for (const F of J)
                        T.delete(F),
                        A.delete(F),
                        i.dispatchEvent({
                            type: "planeremoved",
                            data: F
                        });
                for (const F of O.detectedPlanes)
                    if (!T.has(F))
                        T.add(F),
                        A.set(F, O.lastChangedTime),
                        i.dispatchEvent({
                            type: "planeadded",
                            data: F
                        });
                    else {
                        const B = A.get(F);
                        F.lastChangedTime > B && (A.set(F, F.lastChangedTime),
                        i.dispatchEvent({
                            type: "planechanged",
                            data: F
                        }))
                    }
            }
            y = null
        }
        const I = new GL;
        I.setAnimationLoop(ue),
        this.setAnimationLoop = function(U) {
            X = U
        }
        ,
        this.dispose = function() {}
    }
}
function x9(n, e) {
    function t(M, g) {
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        g.value.copy(M.matrix)
    }
    function i(M, g) {
        g.color.getRGB(M.fogColor.value, zL(n)),
        g.isFog ? (M.fogNear.value = g.near,
        M.fogFar.value = g.far) : g.isFogExp2 && (M.fogDensity.value = g.density)
    }
    function r(M, g, _, w, T) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial ? s(M, g) : g.isMeshToonMaterial ? (s(M, g),
        h(M, g)) : g.isMeshPhongMaterial ? (s(M, g),
        d(M, g)) : g.isMeshStandardMaterial ? (s(M, g),
        p(M, g),
        g.isMeshPhysicalMaterial && m(M, g, T)) : g.isMeshMatcapMaterial ? (s(M, g),
        y(M, g)) : g.isMeshDepthMaterial ? s(M, g) : g.isMeshDistanceMaterial ? (s(M, g),
        S(M, g)) : g.isMeshNormalMaterial ? s(M, g) : g.isLineBasicMaterial ? (o(M, g),
        g.isLineDashedMaterial && a(M, g)) : g.isPointsMaterial ? l(M, g, _, w) : g.isSpriteMaterial ? f(M, g) : g.isShadowMaterial ? (M.color.value.copy(g.color),
        M.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1)
    }
    function s(M, g) {
        M.opacity.value = g.opacity,
        g.color && M.diffuse.value.copy(g.color),
        g.emissive && M.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
        g.map && (M.map.value = g.map,
        t(g.map, M.mapTransform)),
        g.alphaMap && (M.alphaMap.value = g.alphaMap,
        t(g.alphaMap, M.alphaMapTransform)),
        g.bumpMap && (M.bumpMap.value = g.bumpMap,
        t(g.bumpMap, M.bumpMapTransform),
        M.bumpScale.value = g.bumpScale,
        g.side === hi && (M.bumpScale.value *= -1)),
        g.normalMap && (M.normalMap.value = g.normalMap,
        t(g.normalMap, M.normalMapTransform),
        M.normalScale.value.copy(g.normalScale),
        g.side === hi && M.normalScale.value.negate()),
        g.displacementMap && (M.displacementMap.value = g.displacementMap,
        t(g.displacementMap, M.displacementMapTransform),
        M.displacementScale.value = g.displacementScale,
        M.displacementBias.value = g.displacementBias),
        g.emissiveMap && (M.emissiveMap.value = g.emissiveMap,
        t(g.emissiveMap, M.emissiveMapTransform)),
        g.specularMap && (M.specularMap.value = g.specularMap,
        t(g.specularMap, M.specularMapTransform)),
        g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest);
        const _ = e.get(g).envMap;
        if (_ && (M.envMap.value = _,
        M.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        M.reflectivity.value = g.reflectivity,
        M.ior.value = g.ior,
        M.refractionRatio.value = g.refractionRatio),
        g.lightMap) {
            M.lightMap.value = g.lightMap;
            const w = n.useLegacyLights === !0 ? Math.PI : 1;
            M.lightMapIntensity.value = g.lightMapIntensity * w,
            t(g.lightMap, M.lightMapTransform)
        }
        g.aoMap && (M.aoMap.value = g.aoMap,
        M.aoMapIntensity.value = g.aoMapIntensity,
        t(g.aoMap, M.aoMapTransform))
    }
    function o(M, g) {
        M.diffuse.value.copy(g.color),
        M.opacity.value = g.opacity,
        g.map && (M.map.value = g.map,
        t(g.map, M.mapTransform))
    }
    function a(M, g) {
        M.dashSize.value = g.dashSize,
        M.totalSize.value = g.dashSize + g.gapSize,
        M.scale.value = g.scale
    }
    function l(M, g, _, w) {
        M.diffuse.value.copy(g.color),
        M.opacity.value = g.opacity,
        M.size.value = g.size * _,
        M.scale.value = w * .5,
        g.map && (M.map.value = g.map,
        t(g.map, M.uvTransform)),
        g.alphaMap && (M.alphaMap.value = g.alphaMap),
        g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest)
    }
    function f(M, g) {
        M.diffuse.value.copy(g.color),
        M.opacity.value = g.opacity,
        M.rotation.value = g.rotation,
        g.map && (M.map.value = g.map,
        t(g.map, M.mapTransform)),
        g.alphaMap && (M.alphaMap.value = g.alphaMap),
        g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest)
    }
    function d(M, g) {
        M.specular.value.copy(g.specular),
        M.shininess.value = Math.max(g.shininess, 1e-4)
    }
    function h(M, g) {
        g.gradientMap && (M.gradientMap.value = g.gradientMap)
    }
    function p(M, g) {
        M.metalness.value = g.metalness,
        g.metalnessMap && (M.metalnessMap.value = g.metalnessMap,
        t(g.metalnessMap, M.metalnessMapTransform)),
        M.roughness.value = g.roughness,
        g.roughnessMap && (M.roughnessMap.value = g.roughnessMap,
        t(g.roughnessMap, M.roughnessMapTransform)),
        e.get(g).envMap && (M.envMapIntensity.value = g.envMapIntensity)
    }
    function m(M, g, _) {
        M.ior.value = g.ior,
        g.sheen > 0 && (M.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        M.sheenRoughness.value = g.sheenRoughness,
        g.sheenColorMap && (M.sheenColorMap.value = g.sheenColorMap,
        t(g.sheenColorMap, M.sheenColorMapTransform)),
        g.sheenRoughnessMap && (M.sheenRoughnessMap.value = g.sheenRoughnessMap,
        t(g.sheenRoughnessMap, M.sheenRoughnessMapTransform))),
        g.clearcoat > 0 && (M.clearcoat.value = g.clearcoat,
        M.clearcoatRoughness.value = g.clearcoatRoughness,
        g.clearcoatMap && (M.clearcoatMap.value = g.clearcoatMap,
        t(g.clearcoatMap, M.clearcoatMapTransform)),
        g.clearcoatRoughnessMap && (M.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap,
        t(g.clearcoatRoughnessMap, M.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap && (M.clearcoatNormalMap.value = g.clearcoatNormalMap,
        t(g.clearcoatNormalMap, M.clearcoatNormalMapTransform),
        M.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
        g.side === hi && M.clearcoatNormalScale.value.negate())),
        g.iridescence > 0 && (M.iridescence.value = g.iridescence,
        M.iridescenceIOR.value = g.iridescenceIOR,
        M.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0],
        M.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1],
        g.iridescenceMap && (M.iridescenceMap.value = g.iridescenceMap,
        t(g.iridescenceMap, M.iridescenceMapTransform)),
        g.iridescenceThicknessMap && (M.iridescenceThicknessMap.value = g.iridescenceThicknessMap,
        t(g.iridescenceThicknessMap, M.iridescenceThicknessMapTransform))),
        g.transmission > 0 && (M.transmission.value = g.transmission,
        M.transmissionSamplerMap.value = _.texture,
        M.transmissionSamplerSize.value.set(_.width, _.height),
        g.transmissionMap && (M.transmissionMap.value = g.transmissionMap,
        t(g.transmissionMap, M.transmissionMapTransform)),
        M.thickness.value = g.thickness,
        g.thicknessMap && (M.thicknessMap.value = g.thicknessMap,
        t(g.thicknessMap, M.thicknessMapTransform)),
        M.attenuationDistance.value = g.attenuationDistance,
        M.attenuationColor.value.copy(g.attenuationColor)),
        M.specularIntensity.value = g.specularIntensity,
        M.specularColor.value.copy(g.specularColor),
        g.specularColorMap && (M.specularColorMap.value = g.specularColorMap,
        t(g.specularColorMap, M.specularColorMapTransform)),
        g.specularIntensityMap && (M.specularIntensityMap.value = g.specularIntensityMap,
        t(g.specularIntensityMap, M.specularIntensityMapTransform))
    }
    function y(M, g) {
        g.matcap && (M.matcap.value = g.matcap)
    }
    function S(M, g) {
        const _ = e.get(g).light;
        M.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
        M.nearDistance.value = _.shadow.camera.near,
        M.farDistance.value = _.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function S9(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(_, w) {
        const T = w.program;
        i.uniformBlockBinding(_, T)
    }
    function f(_, w) {
        let T = r[_.id];
        T === void 0 && (y(_),
        T = d(_),
        r[_.id] = T,
        _.addEventListener("dispose", M));
        const A = w.program;
        i.updateUBOMapping(_, A);
        const C = e.render.frame;
        s[_.id] !== C && (p(_),
        s[_.id] = C)
    }
    function d(_) {
        const w = h();
        _.__bindingPointIndex = w;
        const T = n.createBuffer()
          , A = _.__size
          , C = _.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, T),
        n.bufferData(n.UNIFORM_BUFFER, A, C),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, w, T),
        T
    }
    function h() {
        for (let _ = 0; _ < a; _++)
            if (o.indexOf(_) === -1)
                return o.push(_),
                _;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function p(_) {
        const w = r[_.id]
          , T = _.uniforms
          , A = _.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, w);
        for (let C = 0, P = T.length; C < P; C++) {
            const N = T[C];
            if (m(N, C, A) === !0) {
                const b = N.__offset
                  , L = Array.isArray(N.value) ? N.value : [N.value];
                let Y = 0;
                for (let Z = 0; Z < L.length; Z++) {
                    const $ = L[Z]
                      , Q = S($);
                    typeof $ == "number" ? (N.__data[0] = $,
                    n.bufferSubData(n.UNIFORM_BUFFER, b + Y, N.__data)) : $.isMatrix3 ? (N.__data[0] = $.elements[0],
                    N.__data[1] = $.elements[1],
                    N.__data[2] = $.elements[2],
                    N.__data[3] = $.elements[0],
                    N.__data[4] = $.elements[3],
                    N.__data[5] = $.elements[4],
                    N.__data[6] = $.elements[5],
                    N.__data[7] = $.elements[0],
                    N.__data[8] = $.elements[6],
                    N.__data[9] = $.elements[7],
                    N.__data[10] = $.elements[8],
                    N.__data[11] = $.elements[0]) : ($.toArray(N.__data, Y),
                    Y += Q.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(n.UNIFORM_BUFFER, b, N.__data)
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function m(_, w, T) {
        const A = _.value;
        if (T[w] === void 0) {
            if (typeof A == "number")
                T[w] = A;
            else {
                const C = Array.isArray(A) ? A : [A]
                  , P = [];
                for (let N = 0; N < C.length; N++)
                    P.push(C[N].clone());
                T[w] = P
            }
            return !0
        } else if (typeof A == "number") {
            if (T[w] !== A)
                return T[w] = A,
                !0
        } else {
            const C = Array.isArray(T[w]) ? T[w] : [T[w]]
              , P = Array.isArray(A) ? A : [A];
            for (let N = 0; N < C.length; N++) {
                const b = C[N];
                if (b.equals(P[N]) === !1)
                    return b.copy(P[N]),
                    !0
            }
        }
        return !1
    }
    function y(_) {
        const w = _.uniforms;
        let T = 0;
        const A = 16;
        let C = 0;
        for (let P = 0, N = w.length; P < N; P++) {
            const b = w[P]
              , L = {
                boundary: 0,
                storage: 0
            }
              , Y = Array.isArray(b.value) ? b.value : [b.value];
            for (let Z = 0, $ = Y.length; Z < $; Z++) {
                const Q = Y[Z]
                  , ie = S(Q);
                L.boundary += ie.boundary,
                L.storage += ie.storage
            }
            if (b.__data = new Float32Array(L.storage / Float32Array.BYTES_PER_ELEMENT),
            b.__offset = T,
            P > 0) {
                C = T % A;
                const Z = A - C;
                C !== 0 && Z - L.boundary < 0 && (T += A - C,
                b.__offset = T)
            }
            T += L.storage
        }
        return C = T % A,
        C > 0 && (T += A - C),
        _.__size = T,
        _.__cache = {},
        this
    }
    function S(_) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof _ == "number" ? (w.boundary = 4,
        w.storage = 4) : _.isVector2 ? (w.boundary = 8,
        w.storage = 8) : _.isVector3 || _.isColor ? (w.boundary = 16,
        w.storage = 12) : _.isVector4 ? (w.boundary = 16,
        w.storage = 16) : _.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : _.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _),
        w
    }
    function M(_) {
        const w = _.target;
        w.removeEventListener("dispose", M);
        const T = o.indexOf(w.__bindingPointIndex);
        o.splice(T, 1),
        n.deleteBuffer(r[w.id]),
        delete r[w.id],
        delete s[w.id]
    }
    function g() {
        for (const _ in r)
            n.deleteBuffer(r[_]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: f,
        dispose: g
    }
}
function w9() {
    const n = rd("canvas");
    return n.style.display = "block",
    n
}
class X1 {
    constructor(e={}) {
        const {canvas: t=w9(), context: i=null, depth: r=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: f=!1, powerPreference: d="default", failIfMajorPerformanceCaveat: h=!1} = e;
        this.isWebGLRenderer = !0;
        let p;
        i !== null ? p = i.getContextAttributes().alpha : p = o;
        let m = null
          , y = null;
        const S = []
          , M = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.outputColorSpace = lt,
        this.useLegacyLights = !0,
        this.toneMapping = qr,
        this.toneMappingExposure = 1;
        const g = this;
        let _ = !1
          , w = 0
          , T = 0
          , A = null
          , C = -1
          , P = null;
        const N = new Ut
          , b = new Ut;
        let L = null
          , Y = t.width
          , Z = t.height
          , $ = 1
          , Q = null
          , ie = null;
        const fe = new Ut(0,0,Y,Z)
          , le = new Ut(0,0,Y,Z);
        let D = !1;
        const j = new p0;
        let X = !1
          , ue = !1
          , I = null;
        const U = new $e
          , O = new z
          , J = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function F() {
            return A === null ? $ : 1
        }
        let B = i;
        function ae(V, he) {
            for (let Se = 0; Se < V.length; Se++) {
                const ce = V[Se]
                  , Ae = t.getContext(ce, he);
                if (Ae !== null)
                    return Ae
            }
            return null
        }
        try {
            const V = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: f,
                powerPreference: d,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r ${a0}`),
            t.addEventListener("webglcontextlost", K, !1),
            t.addEventListener("webglcontextrestored", q, !1),
            t.addEventListener("webglcontextcreationerror", xe, !1),
            B === null) {
                const he = ["webgl2", "webgl", "experimental-webgl"];
                if (g.isWebGL1Renderer === !0 && he.shift(),
                B = ae(he, V),
                B === null)
                    throw ae(he) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            B.getShaderPrecisionFormat === void 0 && (B.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (V) {
            throw console.error("THREE.WebGLRenderer: " + V.message),
            V
        }
        let _e, pe, Ee, se, oe, ve, Ce, Re, Le, Be, Ze, Ye, pt, G, k, ee, we, Ie, Fe, Je, We, Me, Qe, tt;
        function st() {
            _e = new F8(B),
            pe = new I8(B,_e,e),
            _e.init(pe),
            Me = new YL(B,_e,pe),
            Ee = new g9(B,_e,pe),
            se = new V8(B),
            oe = new r9,
            ve = new v9(B,_e,Ee,oe,pe,Me,se),
            Ce = new D8(g),
            Re = new O8(g),
            Le = new J5(B,pe),
            Qe = new P8(B,_e,Le,pe),
            Be = new z8(B,Le,se,Qe),
            Ze = new X8(B,Be,Le,se),
            Fe = new W8(B,pe,ve),
            ee = new N8(oe),
            Ye = new i9(g,Ce,Re,_e,pe,Qe,ee),
            pt = new x9(g,oe),
            G = new o9,
            k = new d9(_e,pe),
            Ie = new b8(g,Ce,Re,Ee,Ze,p,l),
            we = new m9(g,Ze,pe),
            tt = new S9(B,se,pe,Ee),
            Je = new L8(B,_e,se,pe),
            We = new B8(B,_e,se,pe),
            se.programs = Ye.programs,
            g.capabilities = pe,
            g.extensions = _e,
            g.properties = oe,
            g.renderLists = G,
            g.shadowMap = we,
            g.state = Ee,
            g.info = se
        }
        st();
        const Xe = new _9(g,B);
        this.xr = Xe,
        this.getContext = function() {
            return B
        }
        ,
        this.getContextAttributes = function() {
            return B.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const V = _e.get("WEBGL_lose_context");
            V && V.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const V = _e.get("WEBGL_lose_context");
            V && V.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return $
        }
        ,
        this.setPixelRatio = function(V) {
            V !== void 0 && ($ = V,
            this.setSize(Y, Z, !1))
        }
        ,
        this.getSize = function(V) {
            return V.set(Y, Z)
        }
        ,
        this.setSize = function(V, he, Se=!0) {
            if (Xe.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            Y = V,
            Z = he,
            t.width = Math.floor(V * $),
            t.height = Math.floor(he * $),
            Se === !0 && (t.style.width = V + "px",
            t.style.height = he + "px"),
            this.setViewport(0, 0, V, he)
        }
        ,
        this.getDrawingBufferSize = function(V) {
            return V.set(Y * $, Z * $).floor()
        }
        ,
        this.setDrawingBufferSize = function(V, he, Se) {
            Y = V,
            Z = he,
            $ = Se,
            t.width = Math.floor(V * Se),
            t.height = Math.floor(he * Se),
            this.setViewport(0, 0, V, he)
        }
        ,
        this.getCurrentViewport = function(V) {
            return V.copy(N)
        }
        ,
        this.getViewport = function(V) {
            return V.copy(fe)
        }
        ,
        this.setViewport = function(V, he, Se, ce) {
            V.isVector4 ? fe.set(V.x, V.y, V.z, V.w) : fe.set(V, he, Se, ce),
            Ee.viewport(N.copy(fe).multiplyScalar($).floor())
        }
        ,
        this.getScissor = function(V) {
            return V.copy(le)
        }
        ,
        this.setScissor = function(V, he, Se, ce) {
            V.isVector4 ? le.set(V.x, V.y, V.z, V.w) : le.set(V, he, Se, ce),
            Ee.scissor(b.copy(le).multiplyScalar($).floor())
        }
        ,
        this.getScissorTest = function() {
            return D
        }
        ,
        this.setScissorTest = function(V) {
            Ee.setScissorTest(D = V)
        }
        ,
        this.setOpaqueSort = function(V) {
            Q = V
        }
        ,
        this.setTransparentSort = function(V) {
            ie = V
        }
        ,
        this.getClearColor = function(V) {
            return V.copy(Ie.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Ie.setClearColor.apply(Ie, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Ie.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Ie.setClearAlpha.apply(Ie, arguments)
        }
        ,
        this.clear = function(V=!0, he=!0, Se=!0) {
            let ce = 0;
            V && (ce |= B.COLOR_BUFFER_BIT),
            he && (ce |= B.DEPTH_BUFFER_BIT),
            Se && (ce |= B.STENCIL_BUFFER_BIT),
            B.clear(ce)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", K, !1),
            t.removeEventListener("webglcontextrestored", q, !1),
            t.removeEventListener("webglcontextcreationerror", xe, !1),
            G.dispose(),
            k.dispose(),
            oe.dispose(),
            Ce.dispose(),
            Re.dispose(),
            Ze.dispose(),
            Qe.dispose(),
            tt.dispose(),
            Ye.dispose(),
            Xe.dispose(),
            Xe.removeEventListener("sessionstart", Pe),
            Xe.removeEventListener("sessionend", Ge),
            I && (I.dispose(),
            I = null),
            it.stop()
        }
        ;
        function K(V) {
            V.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            _ = !0
        }
        function q() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            _ = !1;
            const V = se.autoReset
              , he = we.enabled
              , Se = we.autoUpdate
              , ce = we.needsUpdate
              , Ae = we.type;
            st(),
            se.autoReset = V,
            we.enabled = he,
            we.autoUpdate = Se,
            we.needsUpdate = ce,
            we.type = Ae
        }
        function xe(V) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", V.statusMessage)
        }
        function Ne(V) {
            const he = V.target;
            he.removeEventListener("dispose", Ne),
            H(he)
        }
        function H(V) {
            te(V),
            oe.remove(V)
        }
        function te(V) {
            const he = oe.get(V).programs;
            he !== void 0 && (he.forEach(function(Se) {
                Ye.releaseProgram(Se)
            }),
            V.isShaderMaterial && Ye.releaseShaderCache(V))
        }
        this.renderBufferDirect = function(V, he, Se, ce, Ae, rt) {
            he === null && (he = J);
            const at = Ae.isMesh && Ae.matrixWorld.determinant() < 0
              , ut = os(V, he, Se, ce, Ae);
            Ee.setMaterial(ce, at);
            let mt = Se.index
              , wt = 1;
            ce.wireframe === !0 && (mt = Be.getWireframeAttribute(Se),
            wt = 2);
            const Mt = Se.drawRange
              , Tt = Se.attributes.position;
            let Vt = Mt.start * wt
              , Kn = (Mt.start + Mt.count) * wt;
            rt !== null && (Vt = Math.max(Vt, rt.start * wt),
            Kn = Math.min(Kn, (rt.start + rt.count) * wt)),
            mt !== null ? (Vt = Math.max(Vt, 0),
            Kn = Math.min(Kn, mt.count)) : Tt != null && (Vt = Math.max(Vt, 0),
            Kn = Math.min(Kn, Tt.count));
            const zi = Kn - Vt;
            if (zi < 0 || zi === 1 / 0)
                return;
            Qe.setup(Ae, ce, ut, Se, mt);
            let br, Qt = Je;
            if (mt !== null && (br = Le.get(mt),
            Qt = We,
            Qt.setIndex(br)),
            Ae.isMesh)
                ce.wireframe === !0 ? (Ee.setLineWidth(ce.wireframeLinewidth * F()),
                Qt.setMode(B.LINES)) : Qt.setMode(B.TRIANGLES);
            else if (Ae.isLine) {
                let At = ce.linewidth;
                At === void 0 && (At = 1),
                Ee.setLineWidth(At * F()),
                Ae.isLineSegments ? Qt.setMode(B.LINES) : Ae.isLineLoop ? Qt.setMode(B.LINE_LOOP) : Qt.setMode(B.LINE_STRIP)
            } else
                Ae.isPoints ? Qt.setMode(B.POINTS) : Ae.isSprite && Qt.setMode(B.TRIANGLES);
            if (Ae.isInstancedMesh)
                Qt.renderInstances(Vt, zi, Ae.count);
            else if (Se.isInstancedBufferGeometry) {
                const At = Se._maxInstanceCount !== void 0 ? Se._maxInstanceCount : 1 / 0
                  , la = Math.min(Se.instanceCount, At);
                Qt.renderInstances(Vt, zi, la)
            } else
                Qt.render(Vt, zi)
        }
        ,
        this.compile = function(V, he) {
            function Se(ce, Ae, rt) {
                ce.transparent === !0 && ce.side === $r && ce.forceSinglePass === !1 ? (ce.side = hi,
                ce.needsUpdate = !0,
                Cr(ce, Ae, rt),
                ce.side = Zr,
                ce.needsUpdate = !0,
                Cr(ce, Ae, rt),
                ce.side = $r) : Cr(ce, Ae, rt)
            }
            y = k.get(V),
            y.init(),
            M.push(y),
            V.traverseVisible(function(ce) {
                ce.isLight && ce.layers.test(he.layers) && (y.pushLight(ce),
                ce.castShadow && y.pushShadow(ce))
            }),
            y.setupLights(g.useLegacyLights),
            V.traverse(function(ce) {
                const Ae = ce.material;
                if (Ae)
                    if (Array.isArray(Ae))
                        for (let rt = 0; rt < Ae.length; rt++) {
                            const at = Ae[rt];
                            Se(at, V, ce)
                        }
                    else
                        Se(Ae, V, ce)
            }),
            M.pop(),
            y = null
        }
        ;
        let me = null;
        function Te(V) {
            me && me(V)
        }
        function Pe() {
            it.stop()
        }
        function Ge() {
            it.start()
        }
        const it = new GL;
        it.setAnimationLoop(Te),
        typeof self < "u" && it.setContext(self),
        this.setAnimationLoop = function(V) {
            me = V,
            Xe.setAnimationLoop(V),
            V === null ? it.stop() : it.start()
        }
        ,
        Xe.addEventListener("sessionstart", Pe),
        Xe.addEventListener("sessionend", Ge),
        this.render = function(V, he) {
            if (he !== void 0 && he.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (_ === !0)
                return;
            V.matrixWorldAutoUpdate === !0 && V.updateMatrixWorld(),
            he.parent === null && he.matrixWorldAutoUpdate === !0 && he.updateMatrixWorld(),
            Xe.enabled === !0 && Xe.isPresenting === !0 && (Xe.cameraAutoUpdate === !0 && Xe.updateCamera(he),
            he = Xe.getCamera()),
            V.isScene === !0 && V.onBeforeRender(g, V, he, A),
            y = k.get(V, M.length),
            y.init(),
            M.push(y),
            U.multiplyMatrices(he.projectionMatrix, he.matrixWorldInverse),
            j.setFromProjectionMatrix(U),
            ue = this.localClippingEnabled,
            X = ee.init(this.clippingPlanes, ue),
            m = G.get(V, S.length),
            m.init(),
            S.push(m),
            Dt(V, he, 0, g.sortObjects),
            m.finish(),
            g.sortObjects === !0 && m.sort(Q, ie),
            X === !0 && ee.beginShadows();
            const Se = y.state.shadowsArray;
            if (we.render(Se, V, he),
            X === !0 && ee.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            Ie.render(m, V),
            y.setupLights(g.useLegacyLights),
            he.isArrayCamera) {
                const ce = he.cameras;
                for (let Ae = 0, rt = ce.length; Ae < rt; Ae++) {
                    const at = ce[Ae];
                    Bt(m, V, at, at.viewport)
                }
            } else
                Bt(m, V, he);
            A !== null && (ve.updateMultisampleRenderTarget(A),
            ve.updateRenderTargetMipmap(A)),
            V.isScene === !0 && V.onAfterRender(g, V, he),
            Qe.resetDefaultState(),
            C = -1,
            P = null,
            M.pop(),
            M.length > 0 ? y = M[M.length - 1] : y = null,
            S.pop(),
            S.length > 0 ? m = S[S.length - 1] : m = null
        }
        ;
        function Dt(V, he, Se, ce) {
            if (V.visible === !1)
                return;
            if (V.layers.test(he.layers)) {
                if (V.isGroup)
                    Se = V.renderOrder;
                else if (V.isLOD)
                    V.autoUpdate === !0 && V.update(he);
                else if (V.isLight)
                    y.pushLight(V),
                    V.castShadow && y.pushShadow(V);
                else if (V.isSprite) {
                    if (!V.frustumCulled || j.intersectsSprite(V)) {
                        ce && O.setFromMatrixPosition(V.matrixWorld).applyMatrix4(U);
                        const at = Ze.update(V)
                          , ut = V.material;
                        ut.visible && m.push(V, at, ut, Se, O.z, null)
                    }
                } else if ((V.isMesh || V.isLine || V.isPoints) && (!V.frustumCulled || j.intersectsObject(V))) {
                    V.isSkinnedMesh && V.skeleton.frame !== se.render.frame && (V.skeleton.update(),
                    V.skeleton.frame = se.render.frame);
                    const at = Ze.update(V)
                      , ut = V.material;
                    if (ce && (at.boundingSphere === null && at.computeBoundingSphere(),
                    O.copy(at.boundingSphere.center).applyMatrix4(V.matrixWorld).applyMatrix4(U)),
                    Array.isArray(ut)) {
                        const mt = at.groups;
                        for (let wt = 0, Mt = mt.length; wt < Mt; wt++) {
                            const Tt = mt[wt]
                              , Vt = ut[Tt.materialIndex];
                            Vt && Vt.visible && m.push(V, at, Vt, Se, O.z, Tt)
                        }
                    } else
                        ut.visible && m.push(V, at, ut, Se, O.z, null)
                }
            }
            const rt = V.children;
            for (let at = 0, ut = rt.length; at < ut; at++)
                Dt(rt[at], he, Se, ce)
        }
        function Bt(V, he, Se, ce) {
            const Ae = V.opaque
              , rt = V.transmissive
              , at = V.transparent;
            y.setupLightsView(Se),
            X === !0 && ee.setGlobalState(g.clippingPlanes, Se),
            rt.length > 0 && bt(Ae, rt, he, Se),
            ce && Ee.viewport(N.copy(ce)),
            Ae.length > 0 && qt(Ae, he, Se),
            rt.length > 0 && qt(rt, he, Se),
            at.length > 0 && qt(at, he, Se),
            Ee.buffers.depth.setTest(!0),
            Ee.buffers.depth.setMask(!0),
            Ee.buffers.color.setMask(!0),
            Ee.setPolygonOffset(!1)
        }
        function bt(V, he, Se, ce) {
            if (I === null) {
                const ut = pe.isWebGL2;
                I = new Jr(1024,1024,{
                    generateMipmaps: !0,
                    type: _e.has("EXT_color_buffer_half_float") ? Kc : to,
                    minFilter: ws,
                    samples: ut && a === !0 ? 4 : 0
                })
            }
            const Ae = g.getRenderTarget();
            g.setRenderTarget(I),
            g.clear();
            const rt = g.toneMapping;
            g.toneMapping = qr,
            qt(V, Se, ce),
            ve.updateMultisampleRenderTarget(I),
            ve.updateRenderTargetMipmap(I);
            let at = !1;
            for (let ut = 0, mt = he.length; ut < mt; ut++) {
                const wt = he[ut]
                  , Mt = wt.object
                  , Tt = wt.geometry
                  , Vt = wt.material
                  , Kn = wt.group;
                if (Vt.side === $r && Mt.layers.test(ce.layers)) {
                    const zi = Vt.side;
                    Vt.side = hi,
                    Vt.needsUpdate = !0,
                    Dn(Mt, Se, ce, Tt, Vt, Kn),
                    Vt.side = zi,
                    Vt.needsUpdate = !0,
                    at = !0
                }
            }
            at === !0 && (ve.updateMultisampleRenderTarget(I),
            ve.updateRenderTargetMipmap(I)),
            g.setRenderTarget(Ae),
            g.toneMapping = rt
        }
        function qt(V, he, Se) {
            const ce = he.isScene === !0 ? he.overrideMaterial : null;
            for (let Ae = 0, rt = V.length; Ae < rt; Ae++) {
                const at = V[Ae]
                  , ut = at.object
                  , mt = at.geometry
                  , wt = ce === null ? at.material : ce
                  , Mt = at.group;
                ut.layers.test(Se.layers) && Dn(ut, he, Se, mt, wt, Mt)
            }
        }
        function Dn(V, he, Se, ce, Ae, rt) {
            V.onBeforeRender(g, he, Se, ce, Ae, rt),
            V.modelViewMatrix.multiplyMatrices(Se.matrixWorldInverse, V.matrixWorld),
            V.normalMatrix.getNormalMatrix(V.modelViewMatrix),
            Ae.onBeforeRender(g, he, Se, ce, V, rt),
            Ae.transparent === !0 && Ae.side === $r && Ae.forceSinglePass === !1 ? (Ae.side = hi,
            Ae.needsUpdate = !0,
            g.renderBufferDirect(Se, he, ce, Ae, V, rt),
            Ae.side = Zr,
            Ae.needsUpdate = !0,
            g.renderBufferDirect(Se, he, ce, Ae, V, rt),
            Ae.side = $r) : g.renderBufferDirect(Se, he, ce, Ae, V, rt),
            V.onAfterRender(g, he, Se, ce, Ae, rt)
        }
        function Cr(V, he, Se) {
            he.isScene !== !0 && (he = J);
            const ce = oe.get(V)
              , Ae = y.state.lights
              , rt = y.state.shadowsArray
              , at = Ae.state.version
              , ut = Ye.getParameters(V, Ae.state, rt, he, Se)
              , mt = Ye.getProgramCacheKey(ut);
            let wt = ce.programs;
            ce.environment = V.isMeshStandardMaterial ? he.environment : null,
            ce.fog = he.fog,
            ce.envMap = (V.isMeshStandardMaterial ? Re : Ce).get(V.envMap || ce.environment),
            wt === void 0 && (V.addEventListener("dispose", Ne),
            wt = new Map,
            ce.programs = wt);
            let Mt = wt.get(mt);
            if (Mt !== void 0) {
                if (ce.currentProgram === Mt && ce.lightsStateVersion === at)
                    return ss(V, ut),
                    Mt
            } else
                ut.uniforms = Ye.getUniforms(V),
                V.onBuild(Se, ut, g),
                V.onBeforeCompile(ut, g),
                Mt = Ye.acquireProgram(ut, mt),
                wt.set(mt, Mt),
                ce.uniforms = ut.uniforms;
            const Tt = ce.uniforms;
            (!V.isShaderMaterial && !V.isRawShaderMaterial || V.clipping === !0) && (Tt.clippingPlanes = ee.uniform),
            ss(V, ut),
            ce.needsLights = R0(V),
            ce.lightsStateVersion = at,
            ce.needsLights && (Tt.ambientLightColor.value = Ae.state.ambient,
            Tt.lightProbe.value = Ae.state.probe,
            Tt.directionalLights.value = Ae.state.directional,
            Tt.directionalLightShadows.value = Ae.state.directionalShadow,
            Tt.spotLights.value = Ae.state.spot,
            Tt.spotLightShadows.value = Ae.state.spotShadow,
            Tt.rectAreaLights.value = Ae.state.rectArea,
            Tt.ltc_1.value = Ae.state.rectAreaLTC1,
            Tt.ltc_2.value = Ae.state.rectAreaLTC2,
            Tt.pointLights.value = Ae.state.point,
            Tt.pointLightShadows.value = Ae.state.pointShadow,
            Tt.hemisphereLights.value = Ae.state.hemi,
            Tt.directionalShadowMap.value = Ae.state.directionalShadowMap,
            Tt.directionalShadowMatrix.value = Ae.state.directionalShadowMatrix,
            Tt.spotShadowMap.value = Ae.state.spotShadowMap,
            Tt.spotLightMatrix.value = Ae.state.spotLightMatrix,
            Tt.spotLightMap.value = Ae.state.spotLightMap,
            Tt.pointShadowMap.value = Ae.state.pointShadowMap,
            Tt.pointShadowMatrix.value = Ae.state.pointShadowMatrix);
            const Vt = Mt.getUniforms()
              , Kn = Sm.seqWithValue(Vt.seq, Tt);
            return ce.currentProgram = Mt,
            ce.uniformsList = Kn,
            Mt
        }
        function ss(V, he) {
            const Se = oe.get(V);
            Se.outputColorSpace = he.outputColorSpace,
            Se.instancing = he.instancing,
            Se.skinning = he.skinning,
            Se.morphTargets = he.morphTargets,
            Se.morphNormals = he.morphNormals,
            Se.morphColors = he.morphColors,
            Se.morphTargetsCount = he.morphTargetsCount,
            Se.numClippingPlanes = he.numClippingPlanes,
            Se.numIntersection = he.numClipIntersection,
            Se.vertexAlphas = he.vertexAlphas,
            Se.vertexTangents = he.vertexTangents,
            Se.toneMapping = he.toneMapping
        }
        function os(V, he, Se, ce, Ae) {
            he.isScene !== !0 && (he = J),
            ve.resetTextureUnits();
            const rt = he.fog
              , at = ce.isMeshStandardMaterial ? he.environment : null
              , ut = A === null ? g.outputColorSpace : A.isXRRenderTarget === !0 ? A.texture.colorSpace : Qr
              , mt = (ce.isMeshStandardMaterial ? Re : Ce).get(ce.envMap || at)
              , wt = ce.vertexColors === !0 && !!Se.attributes.color && Se.attributes.color.itemSize === 4
              , Mt = !!ce.normalMap && !!Se.attributes.tangent
              , Tt = !!Se.morphAttributes.position
              , Vt = !!Se.morphAttributes.normal
              , Kn = !!Se.morphAttributes.color
              , zi = ce.toneMapped ? g.toneMapping : qr
              , br = Se.morphAttributes.position || Se.morphAttributes.normal || Se.morphAttributes.color
              , Qt = br !== void 0 ? br.length : 0
              , At = oe.get(ce)
              , la = y.state.lights;
            if (X === !0 && (ue === !0 || V !== P)) {
                const Yt = V === P && ce.id === C;
                ee.setState(ce, V, Yt)
            }
            let Tn = !1;
            ce.version === At.__version ? (At.needsLights && At.lightsStateVersion !== la.state.version || At.outputColorSpace !== ut || Ae.isInstancedMesh && At.instancing === !1 || !Ae.isInstancedMesh && At.instancing === !0 || Ae.isSkinnedMesh && At.skinning === !1 || !Ae.isSkinnedMesh && At.skinning === !0 || At.envMap !== mt || ce.fog === !0 && At.fog !== rt || At.numClippingPlanes !== void 0 && (At.numClippingPlanes !== ee.numPlanes || At.numIntersection !== ee.numIntersection) || At.vertexAlphas !== wt || At.vertexTangents !== Mt || At.morphTargets !== Tt || At.morphNormals !== Vt || At.morphColors !== Kn || At.toneMapping !== zi || pe.isWebGL2 === !0 && At.morphTargetsCount !== Qt) && (Tn = !0) : (Tn = !0,
            At.__version = ce.version);
            let Pr = At.currentProgram;
            Tn === !0 && (Pr = Cr(ce, he, Ae));
            let Rs = !1
              , Ei = !1
              , Gt = !1;
            const gt = Pr.getUniforms()
              , ii = At.uniforms;
            if (Ee.useProgram(Pr.program) && (Rs = !0,
            Ei = !0,
            Gt = !0),
            ce.id !== C && (C = ce.id,
            Ei = !0),
            Rs || P !== V) {
                if (gt.setValue(B, "projectionMatrix", V.projectionMatrix),
                pe.logarithmicDepthBuffer && gt.setValue(B, "logDepthBufFC", 2 / (Math.log(V.far + 1) / Math.LN2)),
                P !== V && (P = V,
                Ei = !0,
                Gt = !0),
                ce.isShaderMaterial || ce.isMeshPhongMaterial || ce.isMeshToonMaterial || ce.isMeshStandardMaterial || ce.envMap) {
                    const Yt = gt.map.cameraPosition;
                    Yt !== void 0 && Yt.setValue(B, O.setFromMatrixPosition(V.matrixWorld))
                }
                (ce.isMeshPhongMaterial || ce.isMeshToonMaterial || ce.isMeshLambertMaterial || ce.isMeshBasicMaterial || ce.isMeshStandardMaterial || ce.isShaderMaterial) && gt.setValue(B, "isOrthographic", V.isOrthographicCamera === !0),
                (ce.isMeshPhongMaterial || ce.isMeshToonMaterial || ce.isMeshLambertMaterial || ce.isMeshBasicMaterial || ce.isMeshStandardMaterial || ce.isShaderMaterial || ce.isShadowMaterial || Ae.isSkinnedMesh) && gt.setValue(B, "viewMatrix", V.matrixWorldInverse)
            }
            if (Ae.isSkinnedMesh) {
                gt.setOptional(B, Ae, "bindMatrix"),
                gt.setOptional(B, Ae, "bindMatrixInverse");
                const Yt = Ae.skeleton;
                Yt && (pe.floatVertexTextures ? (Yt.boneTexture === null && Yt.computeBoneTexture(),
                gt.setValue(B, "boneTexture", Yt.boneTexture, ve),
                gt.setValue(B, "boneTextureSize", Yt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            const An = Se.morphAttributes;
            if ((An.position !== void 0 || An.normal !== void 0 || An.color !== void 0 && pe.isWebGL2 === !0) && Fe.update(Ae, Se, Pr),
            (Ei || At.receiveShadow !== Ae.receiveShadow) && (At.receiveShadow = Ae.receiveShadow,
            gt.setValue(B, "receiveShadow", Ae.receiveShadow)),
            ce.isMeshGouraudMaterial && ce.envMap !== null && (ii.envMap.value = mt,
            ii.flipEnvMap.value = mt.isCubeTexture && mt.isRenderTargetTexture === !1 ? -1 : 1),
            Ei && (gt.setValue(B, "toneMappingExposure", g.toneMappingExposure),
            At.needsLights && gu(ii, Gt),
            rt && ce.fog === !0 && pt.refreshFogUniforms(ii, rt),
            pt.refreshMaterialUniforms(ii, ce, $, Z, I),
            Sm.upload(B, At.uniformsList, ii, ve)),
            ce.isShaderMaterial && ce.uniformsNeedUpdate === !0 && (Sm.upload(B, At.uniformsList, ii, ve),
            ce.uniformsNeedUpdate = !1),
            ce.isSpriteMaterial && gt.setValue(B, "center", Ae.center),
            gt.setValue(B, "modelViewMatrix", Ae.modelViewMatrix),
            gt.setValue(B, "normalMatrix", Ae.normalMatrix),
            gt.setValue(B, "modelMatrix", Ae.matrixWorld),
            ce.isShaderMaterial || ce.isRawShaderMaterial) {
                const Yt = ce.uniformsGroups;
                for (let Lr = 0, lo = Yt.length; Lr < lo; Lr++)
                    if (pe.isWebGL2) {
                        const Zn = Yt[Lr];
                        tt.update(Zn, Pr),
                        tt.bind(Zn, Pr)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return Pr
        }
        function gu(V, he) {
            V.ambientLightColor.needsUpdate = he,
            V.lightProbe.needsUpdate = he,
            V.directionalLights.needsUpdate = he,
            V.directionalLightShadows.needsUpdate = he,
            V.pointLights.needsUpdate = he,
            V.pointLightShadows.needsUpdate = he,
            V.spotLights.needsUpdate = he,
            V.spotLightShadows.needsUpdate = he,
            V.rectAreaLights.needsUpdate = he,
            V.hemisphereLights.needsUpdate = he
        }
        function R0(V) {
            return V.isMeshLambertMaterial || V.isMeshToonMaterial || V.isMeshPhongMaterial || V.isMeshStandardMaterial || V.isShadowMaterial || V.isShaderMaterial && V.lights === !0
        }
        this.getActiveCubeFace = function() {
            return w
        }
        ,
        this.getActiveMipmapLevel = function() {
            return T
        }
        ,
        this.getRenderTarget = function() {
            return A
        }
        ,
        this.setRenderTargetTextures = function(V, he, Se) {
            oe.get(V.texture).__webglTexture = he,
            oe.get(V.depthTexture).__webglTexture = Se;
            const ce = oe.get(V);
            ce.__hasExternalTextures = !0,
            ce.__hasExternalTextures && (ce.__autoAllocateDepthBuffer = Se === void 0,
            ce.__autoAllocateDepthBuffer || _e.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            ce.__useRenderToTexture = !1))
        }
        ,
        this.setRenderTargetFramebuffer = function(V, he) {
            const Se = oe.get(V);
            Se.__webglFramebuffer = he,
            Se.__useDefaultFramebuffer = he === void 0
        }
        ,
        this.setRenderTarget = function(V, he=0, Se=0) {
            A = V,
            w = he,
            T = Se;
            let ce = !0
              , Ae = null
              , rt = !1
              , at = !1;
            if (V) {
                const mt = oe.get(V);
                mt.__useDefaultFramebuffer !== void 0 ? (Ee.bindFramebuffer(B.FRAMEBUFFER, null),
                ce = !1) : mt.__webglFramebuffer === void 0 ? ve.setupRenderTarget(V) : mt.__hasExternalTextures && ve.rebindTextures(V, oe.get(V.texture).__webglTexture, oe.get(V.depthTexture).__webglTexture);
                const wt = V.texture;
                (wt.isData3DTexture || wt.isDataArrayTexture || wt.isCompressedArrayTexture) && (at = !0);
                const Mt = oe.get(V).__webglFramebuffer;
                V.isWebGLCubeRenderTarget ? (Ae = Mt[he],
                rt = !0) : pe.isWebGL2 && V.samples > 0 && ve.useMultisampledRTT(V) === !1 ? Ae = oe.get(V).__webglMultisampledFramebuffer : Ae = Mt,
                N.copy(V.viewport),
                b.copy(V.scissor),
                L = V.scissorTest
            } else
                N.copy(fe).multiplyScalar($).floor(),
                b.copy(le).multiplyScalar($).floor(),
                L = D;
            if (Ee.bindFramebuffer(B.FRAMEBUFFER, Ae) && pe.drawBuffers && ce && Ee.drawBuffers(V, Ae),
            Ee.viewport(N),
            Ee.scissor(b),
            Ee.setScissorTest(L),
            rt) {
                const mt = oe.get(V.texture);
                B.framebufferTexture2D(B.FRAMEBUFFER, B.COLOR_ATTACHMENT0, B.TEXTURE_CUBE_MAP_POSITIVE_X + he, mt.__webglTexture, Se)
            } else if (at) {
                const mt = oe.get(V.texture)
                  , wt = he || 0;
                B.framebufferTextureLayer(B.FRAMEBUFFER, B.COLOR_ATTACHMENT0, mt.__webglTexture, Se || 0, wt)
            }
            C = -1
        }
        ,
        this.readRenderTargetPixels = function(V, he, Se, ce, Ae, rt, at) {
            if (!(V && V.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let ut = oe.get(V).__webglFramebuffer;
            if (V.isWebGLCubeRenderTarget && at !== void 0 && (ut = ut[at]),
            ut) {
                Ee.bindFramebuffer(B.FRAMEBUFFER, ut);
                try {
                    const mt = V.texture
                      , wt = mt.format
                      , Mt = mt.type;
                    if (wt !== Ii && Me.convert(wt) !== B.getParameter(B.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const Tt = Mt === Kc && (_e.has("EXT_color_buffer_half_float") || pe.isWebGL2 && _e.has("EXT_color_buffer_float"));
                    if (Mt !== to && Me.convert(Mt) !== B.getParameter(B.IMPLEMENTATION_COLOR_READ_TYPE) && !(Mt === Ys && (pe.isWebGL2 || _e.has("OES_texture_float") || _e.has("WEBGL_color_buffer_float"))) && !Tt) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    he >= 0 && he <= V.width - ce && Se >= 0 && Se <= V.height - Ae && B.readPixels(he, Se, ce, Ae, Me.convert(wt), Me.convert(Mt), rt)
                } finally {
                    const mt = A !== null ? oe.get(A).__webglFramebuffer : null;
                    Ee.bindFramebuffer(B.FRAMEBUFFER, mt)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(V, he, Se=0) {
            const ce = Math.pow(2, -Se)
              , Ae = Math.floor(he.image.width * ce)
              , rt = Math.floor(he.image.height * ce);
            ve.setTexture2D(he, 0),
            B.copyTexSubImage2D(B.TEXTURE_2D, Se, 0, 0, V.x, V.y, Ae, rt),
            Ee.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(V, he, Se, ce=0) {
            const Ae = he.image.width
              , rt = he.image.height
              , at = Me.convert(Se.format)
              , ut = Me.convert(Se.type);
            ve.setTexture2D(Se, 0),
            B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL, Se.flipY),
            B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Se.premultiplyAlpha),
            B.pixelStorei(B.UNPACK_ALIGNMENT, Se.unpackAlignment),
            he.isDataTexture ? B.texSubImage2D(B.TEXTURE_2D, ce, V.x, V.y, Ae, rt, at, ut, he.image.data) : he.isCompressedTexture ? B.compressedTexSubImage2D(B.TEXTURE_2D, ce, V.x, V.y, he.mipmaps[0].width, he.mipmaps[0].height, at, he.mipmaps[0].data) : B.texSubImage2D(B.TEXTURE_2D, ce, V.x, V.y, at, ut, he.image),
            ce === 0 && Se.generateMipmaps && B.generateMipmap(B.TEXTURE_2D),
            Ee.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(V, he, Se, ce, Ae=0) {
            if (g.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const rt = V.max.x - V.min.x + 1
              , at = V.max.y - V.min.y + 1
              , ut = V.max.z - V.min.z + 1
              , mt = Me.convert(ce.format)
              , wt = Me.convert(ce.type);
            let Mt;
            if (ce.isData3DTexture)
                ve.setTexture3D(ce, 0),
                Mt = B.TEXTURE_3D;
            else if (ce.isDataArrayTexture)
                ve.setTexture2DArray(ce, 0),
                Mt = B.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL, ce.flipY),
            B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha),
            B.pixelStorei(B.UNPACK_ALIGNMENT, ce.unpackAlignment);
            const Tt = B.getParameter(B.UNPACK_ROW_LENGTH)
              , Vt = B.getParameter(B.UNPACK_IMAGE_HEIGHT)
              , Kn = B.getParameter(B.UNPACK_SKIP_PIXELS)
              , zi = B.getParameter(B.UNPACK_SKIP_ROWS)
              , br = B.getParameter(B.UNPACK_SKIP_IMAGES)
              , Qt = Se.isCompressedTexture ? Se.mipmaps[0] : Se.image;
            B.pixelStorei(B.UNPACK_ROW_LENGTH, Qt.width),
            B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, Qt.height),
            B.pixelStorei(B.UNPACK_SKIP_PIXELS, V.min.x),
            B.pixelStorei(B.UNPACK_SKIP_ROWS, V.min.y),
            B.pixelStorei(B.UNPACK_SKIP_IMAGES, V.min.z),
            Se.isDataTexture || Se.isData3DTexture ? B.texSubImage3D(Mt, Ae, he.x, he.y, he.z, rt, at, ut, mt, wt, Qt.data) : Se.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            B.compressedTexSubImage3D(Mt, Ae, he.x, he.y, he.z, rt, at, ut, mt, Qt.data)) : B.texSubImage3D(Mt, Ae, he.x, he.y, he.z, rt, at, ut, mt, wt, Qt),
            B.pixelStorei(B.UNPACK_ROW_LENGTH, Tt),
            B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, Vt),
            B.pixelStorei(B.UNPACK_SKIP_PIXELS, Kn),
            B.pixelStorei(B.UNPACK_SKIP_ROWS, zi),
            B.pixelStorei(B.UNPACK_SKIP_IMAGES, br),
            Ae === 0 && ce.generateMipmaps && B.generateMipmap(Mt),
            Ee.unbindTexture()
        }
        ,
        this.initTexture = function(V) {
            V.isCubeTexture ? ve.setTextureCube(V, 0) : V.isData3DTexture ? ve.setTexture3D(V, 0) : V.isDataArrayTexture || V.isCompressedArrayTexture ? ve.setTexture2DArray(V, 0) : ve.setTexture2D(V, 0),
            Ee.unbindTexture()
        }
        ,
        this.resetState = function() {
            w = 0,
            T = 0,
            A = null,
            Ee.reset(),
            Qe.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get physicallyCorrectLights() {
        return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        !this.useLegacyLights
    }
    set physicallyCorrectLights(e) {
        console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        this.useLegacyLights = !e
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace === lt ? jo : k1
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace = e === jo ? lt : Qr
    }
}
class ZL extends X1 {
}
ZL.prototype.isWebGL1Renderer = !0;
class g0 {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Oe(e),
        this.density = t
    }
    clone() {
        return new g0(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class v0 {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Oe(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new v0(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class tg extends Lt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class bd {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = id,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Qi()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Qi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Qi()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const vi = new z;
class Jo {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            vi.fromBufferAttribute(this, t),
            vi.applyMatrix4(e),
            this.setXYZ(t, vi.x, vi.y, vi.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vi.fromBufferAttribute(this, t),
            vi.applyNormalMatrix(e),
            this.setXYZ(t, vi.x, vi.y, vi.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            vi.fromBufferAttribute(this, t),
            vi.transformDirection(e),
            this.setXYZ(t, vi.x, vi.y, vi.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = xt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Yi(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = xt(t, this.array),
        i = xt(i, this.array),
        r = xt(r, this.array),
        s = xt(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new Ht(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Jo(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class $1 extends Nn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Yl;
const Ju = new z
  , ql = new z
  , Kl = new z
  , Zl = new be
  , ef = new be
  , QL = new $e
  , bp = new z
  , tf = new z
  , Pp = new z
  , TA = new be
  , Uy = new be
  , AA = new be;
class JL extends Lt {
    constructor(e) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Yl === void 0) {
            Yl = new ft;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new bd(t,5);
            Yl.setIndex([0, 1, 2, 0, 2, 3]),
            Yl.setAttribute("position", new Jo(i,3,0,!1)),
            Yl.setAttribute("uv", new Jo(i,2,3,!1))
        }
        this.geometry = Yl,
        this.material = e !== void 0 ? e : new $1,
        this.center = new be(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        ql.setFromMatrixScale(this.matrixWorld),
        QL.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        Kl.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ql.multiplyScalar(-Kl.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        Lp(bp.set(-.5, -.5, 0), Kl, o, ql, r, s),
        Lp(tf.set(.5, -.5, 0), Kl, o, ql, r, s),
        Lp(Pp.set(.5, .5, 0), Kl, o, ql, r, s),
        TA.set(0, 0),
        Uy.set(1, 0),
        AA.set(1, 1);
        let a = e.ray.intersectTriangle(bp, tf, Pp, !1, Ju);
        if (a === null && (Lp(tf.set(-.5, .5, 0), Kl, o, ql, r, s),
        Uy.set(0, 1),
        a = e.ray.intersectTriangle(bp, Pp, tf, !1, Ju),
        a === null))
            return;
        const l = e.ray.origin.distanceTo(Ju);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Ju.clone(),
            uv: Li.getInterpolation(Ju, bp, tf, Pp, TA, Uy, AA, new be),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function Lp(n, e, t, i, r, s) {
    Zl.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? (ef.x = s * Zl.x - r * Zl.y,
    ef.y = r * Zl.x + s * Zl.y) : ef.copy(Zl),
    n.copy(e),
    n.x += ef.x,
    n.y += ef.y,
    n.applyMatrix4(QL)
}
const Ip = new z
  , RA = new z;
class eI extends Lt {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Ip.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(Ip);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Ip.setFromMatrixPosition(e.matrixWorld),
            RA.setFromMatrixPosition(this.matrixWorld);
            const i = Ip.distanceTo(RA) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const CA = new z
  , bA = new Ut
  , PA = new Ut
  , M9 = new z
  , LA = new $e
  , Ql = new z;
class y0 extends zn {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new $e,
        this.bindMatrixInverse = new $e,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new ts),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            Ql.fromBufferAttribute(t, i),
            this.applyBoneTransform(i, Ql),
            this.boundingBox.expandByPoint(Ql)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new ns),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            Ql.fromBufferAttribute(t, i),
            this.applyBoneTransform(i, Ql),
            this.boundingSphere.expandByPoint(Ql)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Ut
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        bA.fromBufferAttribute(r.attributes.skinIndex, e),
        PA.fromBufferAttribute(r.attributes.skinWeight, e),
        CA.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = PA.getComponent(s);
            if (o !== 0) {
                const a = bA.getComponent(s);
                LA.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(M9.copy(CA).applyMatrix4(LA), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
    boneTransform(e, t) {
        return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
        this.applyBoneTransform(e, t)
    }
}
class eu extends Lt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Ic extends en {
    constructor(e=null, t=1, i=1, r, s, o, a, l, f=_n, d=_n, h, p) {
        super(null, o, a, l, f, d, r, s, h, p),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const IA = new $e
  , E9 = new $e;
class fu {
    constructor(e=[], t=[]) {
        this.uuid = Qi(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new $e)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new $e;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : E9;
            IA.multiplyMatrices(a, t[s]),
            IA.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new fu(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = UL(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Ic(t,e,e,Ii,Ys);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new eu),
            this.bones.push(o),
            this.boneInverses.push(new $e().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class tu extends Ht {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Jl = new $e
  , NA = new $e
  , Np = []
  , DA = new ts
  , T9 = new $e
  , nf = new zn
  , rf = new ns;
class j1 extends zn {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new tu(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.count = i,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, T9)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new ts),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Jl),
            DA.copy(e.boundingBox).applyMatrix4(Jl),
            this.boundingBox.union(DA)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new ns),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Jl),
            rf.copy(e.boundingSphere).applyMatrix4(Jl),
            this.boundingSphere.union(rf)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (nf.geometry = this.geometry,
        nf.material = this.material,
        nf.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        rf.copy(this.boundingSphere),
        rf.applyMatrix4(i),
        e.ray.intersectsSphere(rf) !== !1))
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, Jl),
                NA.multiplyMatrices(i, Jl),
                nf.matrixWorld = NA,
                nf.raycast(e, Np);
                for (let o = 0, a = Np.length; o < a; o++) {
                    const l = Np[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                Np.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new tu(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class ni extends Nn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const UA = new z
  , kA = new z
  , OA = new $e
  , ky = new Ad
  , Dp = new ns;
class Es extends Lt {
    constructor(e=new ft, t=new ni) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                UA.fromBufferAttribute(t, r - 1),
                kA.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += UA.distanceTo(kA);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Dp.copy(i.boundingSphere),
        Dp.applyMatrix4(r),
        Dp.radius += s,
        e.ray.intersectsSphere(Dp) === !1)
            return;
        OA.copy(r).invert(),
        ky.copy(e.ray).applyMatrix4(OA);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , f = new z
          , d = new z
          , h = new z
          , p = new z
          , m = this.isLineSegments ? 2 : 1
          , y = i.index
          , M = i.attributes.position;
        if (y !== null) {
            const g = Math.max(0, o.start)
              , _ = Math.min(y.count, o.start + o.count);
            for (let w = g, T = _ - 1; w < T; w += m) {
                const A = y.getX(w)
                  , C = y.getX(w + 1);
                if (f.fromBufferAttribute(M, A),
                d.fromBufferAttribute(M, C),
                ky.distanceSqToSegment(f, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const N = e.ray.origin.distanceTo(p);
                N < e.near || N > e.far || t.push({
                    distance: N,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const g = Math.max(0, o.start)
              , _ = Math.min(M.count, o.start + o.count);
            for (let w = g, T = _ - 1; w < T; w += m) {
                if (f.fromBufferAttribute(M, w),
                d.fromBufferAttribute(M, w + 1),
                ky.distanceSqToSegment(f, d, p, h) > l)
                    continue;
                p.applyMatrix4(this.matrixWorld);
                const C = e.ray.origin.distanceTo(p);
                C < e.near || C > e.far || t.push({
                    distance: C,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: w,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const FA = new z
  , zA = new z;
class is extends Es {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                FA.fromBufferAttribute(t, r),
                zA.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + FA.distanceTo(zA);
            e.setAttribute("lineDistance", new je(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class Y1 extends Es {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class _0 extends Nn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const BA = new $e
  , Kx = new Ad
  , Up = new ns
  , kp = new z;
class q1 extends Lt {
    constructor(e=new ft, t=new _0) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Up.copy(i.boundingSphere),
        Up.applyMatrix4(r),
        Up.radius += s,
        e.ray.intersectsSphere(Up) === !1)
            return;
        BA.copy(r).invert(),
        Kx.copy(e.ray).applyMatrix4(BA);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , f = i.index
          , h = i.attributes.position;
        if (f !== null) {
            const p = Math.max(0, o.start)
              , m = Math.min(f.count, o.start + o.count);
            for (let y = p, S = m; y < S; y++) {
                const M = f.getX(y);
                kp.fromBufferAttribute(h, M),
                VA(kp, M, l, r, e, t, this)
            }
        } else {
            const p = Math.max(0, o.start)
              , m = Math.min(h.count, o.start + o.count);
            for (let y = p, S = m; y < S; y++)
                kp.fromBufferAttribute(h, y),
                VA(kp, y, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function VA(n, e, t, i, r, s, o) {
    const a = Kx.distanceSqToPoint(n);
    if (a < t) {
        const l = new z;
        Kx.closestPointToPoint(n, l),
        l.applyMatrix4(i);
        const f = r.ray.origin.distanceTo(l);
        if (f < r.near || f > r.far)
            return;
        s.push({
            distance: f,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class A9 extends en {
    constructor(e, t, i, r, s, o, a, l, f) {
        super(e, t, i, r, s, o, a, l, f),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : dn,
        this.magFilter = s !== void 0 ? s : dn,
        this.generateMipmaps = !1;
        const d = this;
        function h() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class R9 extends en {
    constructor(e, t, i) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.format = i,
        this.magFilter = _n,
        this.minFilter = _n,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class K1 extends en {
    constructor(e, t, i, r, s, o, a, l, f, d, h, p) {
        super(null, o, a, l, f, d, r, s, h, p),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class C9 extends K1 {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = On
    }
}
class b9 extends en {
    constructor(e, t, i, r, s, o, a, l, f) {
        super(e, t, i, r, s, o, a, l, f),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Ar {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, l = s - 1, f;
        for (; a <= l; )
            if (r = Math.floor(a + (l - a) / 2),
            f = i[r] - o,
            f < 0)
                a = r + 1;
            else if (f > 0)
                l = r - 1;
            else {
                l = r;
                break
            }
        if (r = l,
        i[r] === o)
            return r / (s - 1);
        const d = i[r]
          , p = i[r + 1] - d
          , m = (o - d) / p;
        return (r + m) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new be : new z);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new z
          , r = []
          , s = []
          , o = []
          , a = new z
          , l = new $e;
        for (let m = 0; m <= e; m++) {
            const y = m / e;
            r[m] = this.getTangentAt(y, new z)
        }
        s[0] = new z,
        o[0] = new z;
        let f = Number.MAX_VALUE;
        const d = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , p = Math.abs(r[0].z);
        d <= f && (f = d,
        i.set(1, 0, 0)),
        h <= f && (f = h,
        i.set(0, 1, 0)),
        p <= f && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(),
            o[m] = o[m - 1].clone(),
            a.crossVectors(r[m - 1], r[m]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const y = Math.acos(xn(r[m - 1].dot(r[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, y))
            }
            o[m].crossVectors(r[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos(xn(s[0].dot(s[e]), -1, 1));
            m /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let y = 1; y <= e; y++)
                s[y].applyMatrix4(l.makeRotationAxis(r[y], m * y)),
                o[y].crossVectors(r[y], s[y])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class x0 extends Ar {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new be
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , f = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , p = l - this.aX
              , m = f - this.aY;
            l = p * d - m * h + this.aX,
            f = p * h + m * d + this.aY
        }
        return i.set(l, f)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class tI extends x0 {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function Z1() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, f) {
            r(o, a, f * (a - s), f * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, f, d, h) {
            let p = (o - s) / f - (a - s) / (f + d) + (a - o) / d
              , m = (a - o) / d - (l - o) / (d + h) + (l - a) / h;
            p *= d,
            m *= d,
            r(o, a, p, m)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const Op = new z
  , Oy = new Z1
  , Fy = new Z1
  , zy = new Z1;
class nI extends Ar {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new z) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let f, d;
        this.closed || a > 0 ? f = r[(a - 1) % s] : (Op.subVectors(r[0], r[1]).add(r[0]),
        f = Op);
        const h = r[a % s]
          , p = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (Op.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        d = Op),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let y = Math.pow(f.distanceToSquared(h), m)
              , S = Math.pow(h.distanceToSquared(p), m)
              , M = Math.pow(p.distanceToSquared(d), m);
            S < 1e-4 && (S = 1),
            y < 1e-4 && (y = S),
            M < 1e-4 && (M = S),
            Oy.initNonuniformCatmullRom(f.x, h.x, p.x, d.x, y, S, M),
            Fy.initNonuniformCatmullRom(f.y, h.y, p.y, d.y, y, S, M),
            zy.initNonuniformCatmullRom(f.z, h.z, p.z, d.z, y, S, M)
        } else
            this.curveType === "catmullrom" && (Oy.initCatmullRom(f.x, h.x, p.x, d.x, this.tension),
            Fy.initCatmullRom(f.y, h.y, p.y, d.y, this.tension),
            zy.initCatmullRom(f.z, h.z, p.z, d.z, this.tension));
        return i.set(Oy.calc(l), Fy.calc(l), zy.calc(l)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new z().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function HA(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function P9(n, e) {
    const t = 1 - n;
    return t * t * e
}
function L9(n, e) {
    return 2 * (1 - n) * n * e
}
function I9(n, e) {
    return n * n * e
}
function If(n, e, t, i) {
    return P9(n, e) + L9(n, t) + I9(n, i)
}
function N9(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function D9(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function U9(n, e) {
    return 3 * (1 - n) * n * n * e
}
function k9(n, e) {
    return n * n * n * e
}
function Nf(n, e, t, i, r) {
    return N9(n, e) + D9(n, t) + U9(n, i) + k9(n, r)
}
class Q1 extends Ar {
    constructor(e=new be, t=new be, i=new be, r=new be) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new be) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Nf(e, r.x, s.x, o.x, a.x), Nf(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class iI extends Ar {
    constructor(e=new z, t=new z, i=new z, r=new z) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new z) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Nf(e, r.x, s.x, o.x, a.x), Nf(e, r.y, s.y, o.y, a.y), Nf(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class S0 extends Ar {
    constructor(e=new be, t=new be) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new be) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new be) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class rI extends Ar {
    constructor(e=new z, t=new z) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new z) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new z) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class J1 extends Ar {
    constructor(e=new be, t=new be, i=new be) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new be) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(If(e, r.x, s.x, o.x), If(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class ew extends Ar {
    constructor(e=new z, t=new z, i=new z) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new z) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(If(e, r.x, s.x, o.x), If(e, r.y, s.y, o.y), If(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class tw extends Ar {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new be) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = r[o === 0 ? o : o - 1]
          , f = r[o]
          , d = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(HA(a, l.x, f.x, d.x, h.x), HA(a, l.y, f.y, d.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new be().fromArray(r))
        }
        return this
    }
}
var nw = Object.freeze({
    __proto__: null,
    ArcCurve: tI,
    CatmullRomCurve3: nI,
    CubicBezierCurve: Q1,
    CubicBezierCurve3: iI,
    EllipseCurve: x0,
    LineCurve: S0,
    LineCurve3: rI,
    QuadraticBezierCurve: J1,
    QuadraticBezierCurve3: ew,
    SplineCurve: tw
});
class sI extends Ar {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new S0(t,e))
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , l = a.getLength()
                  , f = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(f, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let f = 0; f < l.length; f++) {
                const d = l[f];
                i && i.equals(d) || (t.push(d),
                i = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new nw[r.type]().fromJSON(r))
        }
        return this
    }
}
class sd extends sI {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new be,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new S0(this.currentPoint.clone(),new be(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new J1(this.currentPoint.clone(),new be(e,t),new be(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new Q1(this.currentPoint.clone(),new be(e,t),new be(i,r),new be(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new tw(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const f = this.currentPoint.x
          , d = this.currentPoint.y;
        return this.absellipse(e + f, t + d, i, r, s, o, a, l),
        this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const f = new x0(e,t,i,r,s,o,a,l);
        if (this.curves.length > 0) {
            const h = f.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(f);
        const d = f.getPoint(1);
        return this.currentPoint.copy(d),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class du extends ft {
    constructor(e=[new be(0,-.5), new be(.5,0), new be(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = xn(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , f = []
          , d = 1 / t
          , h = new z
          , p = new be
          , m = new z
          , y = new z
          , S = new z;
        let M = 0
          , g = 0;
        for (let _ = 0; _ <= e.length - 1; _++)
            switch (_) {
            case 0:
                M = e[_ + 1].x - e[_].x,
                g = e[_ + 1].y - e[_].y,
                m.x = g * 1,
                m.y = -M,
                m.z = g * 0,
                S.copy(m),
                m.normalize(),
                l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(S.x, S.y, S.z);
                break;
            default:
                M = e[_ + 1].x - e[_].x,
                g = e[_ + 1].y - e[_].y,
                m.x = g * 1,
                m.y = -M,
                m.z = g * 0,
                y.copy(m),
                m.x += S.x,
                m.y += S.y,
                m.z += S.z,
                m.normalize(),
                l.push(m.x, m.y, m.z),
                S.copy(y)
            }
        for (let _ = 0; _ <= t; _++) {
            const w = i + _ * d * r
              , T = Math.sin(w)
              , A = Math.cos(w);
            for (let C = 0; C <= e.length - 1; C++) {
                h.x = e[C].x * T,
                h.y = e[C].y,
                h.z = e[C].x * A,
                o.push(h.x, h.y, h.z),
                p.x = _ / t,
                p.y = C / (e.length - 1),
                a.push(p.x, p.y);
                const P = l[3 * C + 0] * T
                  , N = l[3 * C + 1]
                  , b = l[3 * C + 0] * A;
                f.push(P, N, b)
            }
        }
        for (let _ = 0; _ < t; _++)
            for (let w = 0; w < e.length - 1; w++) {
                const T = w + _ * e.length
                  , A = T
                  , C = T + e.length
                  , P = T + e.length + 1
                  , N = T + 1;
                s.push(A, C, N),
                s.push(P, N, C)
            }
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("uv", new je(a,2)),
        this.setAttribute("normal", new je(f,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new du(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class Pd extends du {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new sd;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new Pd(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class Ld extends ft {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , l = []
          , f = new z
          , d = new be;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let h = 0, p = 3; h <= t; h++,
        p += 3) {
            const m = i + h / t * r;
            f.x = e * Math.cos(m),
            f.y = e * Math.sin(m),
            o.push(f.x, f.y, f.z),
            a.push(0, 0, 1),
            d.x = (o[p] / e + 1) / 2,
            d.y = (o[p + 1] / e + 1) / 2,
            l.push(d.x, d.y)
        }
        for (let h = 1; h <= t; h++)
            s.push(h, h + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new je(o,3)),
        this.setAttribute("normal", new je(a,3)),
        this.setAttribute("uv", new je(l,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ld(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class hl extends ft {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const f = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const d = []
          , h = []
          , p = []
          , m = [];
        let y = 0;
        const S = []
          , M = i / 2;
        let g = 0;
        _(),
        o === !1 && (e > 0 && w(!0),
        t > 0 && w(!1)),
        this.setIndex(d),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function _() {
            const T = new z
              , A = new z;
            let C = 0;
            const P = (t - e) / i;
            for (let N = 0; N <= s; N++) {
                const b = []
                  , L = N / s
                  , Y = L * (t - e) + e;
                for (let Z = 0; Z <= r; Z++) {
                    const $ = Z / r
                      , Q = $ * l + a
                      , ie = Math.sin(Q)
                      , fe = Math.cos(Q);
                    A.x = Y * ie,
                    A.y = -L * i + M,
                    A.z = Y * fe,
                    h.push(A.x, A.y, A.z),
                    T.set(ie, P, fe).normalize(),
                    p.push(T.x, T.y, T.z),
                    m.push($, 1 - L),
                    b.push(y++)
                }
                S.push(b)
            }
            for (let N = 0; N < r; N++)
                for (let b = 0; b < s; b++) {
                    const L = S[b][N]
                      , Y = S[b + 1][N]
                      , Z = S[b + 1][N + 1]
                      , $ = S[b][N + 1];
                    d.push(L, Y, $),
                    d.push(Y, Z, $),
                    C += 6
                }
            f.addGroup(g, C, 0),
            g += C
        }
        function w(T) {
            const A = y
              , C = new be
              , P = new z;
            let N = 0;
            const b = T === !0 ? e : t
              , L = T === !0 ? 1 : -1;
            for (let Z = 1; Z <= r; Z++)
                h.push(0, M * L, 0),
                p.push(0, L, 0),
                m.push(.5, .5),
                y++;
            const Y = y;
            for (let Z = 0; Z <= r; Z++) {
                const Q = Z / r * l + a
                  , ie = Math.cos(Q)
                  , fe = Math.sin(Q);
                P.x = b * fe,
                P.y = M * L,
                P.z = b * ie,
                h.push(P.x, P.y, P.z),
                p.push(0, L, 0),
                C.x = ie * .5 + .5,
                C.y = fe * .5 * L + .5,
                m.push(C.x, C.y),
                y++
            }
            for (let Z = 0; Z < r; Z++) {
                const $ = A + Z
                  , Q = Y + Z;
                T === !0 ? d.push(Q, Q + 1, $) : d.push(Q + 1, Q, $),
                N += 3
            }
            f.addGroup(g, N, T === !0 ? 1 : 2),
            g += N
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new hl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Id extends hl {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Id(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class oo extends ft {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        a(r),
        f(i),
        d(),
        this.setAttribute("position", new je(s,3)),
        this.setAttribute("normal", new je(s.slice(),3)),
        this.setAttribute("uv", new je(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(_) {
            const w = new z
              , T = new z
              , A = new z;
            for (let C = 0; C < t.length; C += 3)
                m(t[C + 0], w),
                m(t[C + 1], T),
                m(t[C + 2], A),
                l(w, T, A, _)
        }
        function l(_, w, T, A) {
            const C = A + 1
              , P = [];
            for (let N = 0; N <= C; N++) {
                P[N] = [];
                const b = _.clone().lerp(T, N / C)
                  , L = w.clone().lerp(T, N / C)
                  , Y = C - N;
                for (let Z = 0; Z <= Y; Z++)
                    Z === 0 && N === C ? P[N][Z] = b : P[N][Z] = b.clone().lerp(L, Z / Y)
            }
            for (let N = 0; N < C; N++)
                for (let b = 0; b < 2 * (C - N) - 1; b++) {
                    const L = Math.floor(b / 2);
                    b % 2 === 0 ? (p(P[N][L + 1]),
                    p(P[N + 1][L]),
                    p(P[N][L])) : (p(P[N][L + 1]),
                    p(P[N + 1][L + 1]),
                    p(P[N + 1][L]))
                }
        }
        function f(_) {
            const w = new z;
            for (let T = 0; T < s.length; T += 3)
                w.x = s[T + 0],
                w.y = s[T + 1],
                w.z = s[T + 2],
                w.normalize().multiplyScalar(_),
                s[T + 0] = w.x,
                s[T + 1] = w.y,
                s[T + 2] = w.z
        }
        function d() {
            const _ = new z;
            for (let w = 0; w < s.length; w += 3) {
                _.x = s[w + 0],
                _.y = s[w + 1],
                _.z = s[w + 2];
                const T = M(_) / 2 / Math.PI + .5
                  , A = g(_) / Math.PI + .5;
                o.push(T, 1 - A)
            }
            y(),
            h()
        }
        function h() {
            for (let _ = 0; _ < o.length; _ += 6) {
                const w = o[_ + 0]
                  , T = o[_ + 2]
                  , A = o[_ + 4]
                  , C = Math.max(w, T, A)
                  , P = Math.min(w, T, A);
                C > .9 && P < .1 && (w < .2 && (o[_ + 0] += 1),
                T < .2 && (o[_ + 2] += 1),
                A < .2 && (o[_ + 4] += 1))
            }
        }
        function p(_) {
            s.push(_.x, _.y, _.z)
        }
        function m(_, w) {
            const T = _ * 3;
            w.x = e[T + 0],
            w.y = e[T + 1],
            w.z = e[T + 2]
        }
        function y() {
            const _ = new z
              , w = new z
              , T = new z
              , A = new z
              , C = new be
              , P = new be
              , N = new be;
            for (let b = 0, L = 0; b < s.length; b += 9,
            L += 6) {
                _.set(s[b + 0], s[b + 1], s[b + 2]),
                w.set(s[b + 3], s[b + 4], s[b + 5]),
                T.set(s[b + 6], s[b + 7], s[b + 8]),
                C.set(o[L + 0], o[L + 1]),
                P.set(o[L + 2], o[L + 3]),
                N.set(o[L + 4], o[L + 5]),
                A.copy(_).add(w).add(T).divideScalar(3);
                const Y = M(A);
                S(C, L + 0, _, Y),
                S(P, L + 2, w, Y),
                S(N, L + 4, T, Y)
            }
        }
        function S(_, w, T, A) {
            A < 0 && _.x === 1 && (o[w] = _.x - 1),
            T.x === 0 && T.z === 0 && (o[w] = A / 2 / Math.PI + .5)
        }
        function M(_) {
            return Math.atan2(_.z, -_.x)
        }
        function g(_) {
            return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new oo(e.vertices,e.indices,e.radius,e.details)
    }
}
class Nd extends oo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Nd(e.radius,e.detail)
    }
}
const Fp = new z
  , zp = new z
  , By = new z
  , Bp = new Li;
class oI extends ft {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(Ga * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , l = o ? o.count : a.count
              , f = [0, 0, 0]
              , d = ["a", "b", "c"]
              , h = new Array(3)
              , p = {}
              , m = [];
            for (let y = 0; y < l; y += 3) {
                o ? (f[0] = o.getX(y),
                f[1] = o.getX(y + 1),
                f[2] = o.getX(y + 2)) : (f[0] = y,
                f[1] = y + 1,
                f[2] = y + 2);
                const {a: S, b: M, c: g} = Bp;
                if (S.fromBufferAttribute(a, f[0]),
                M.fromBufferAttribute(a, f[1]),
                g.fromBufferAttribute(a, f[2]),
                Bp.getNormal(By),
                h[0] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(S.z * r)}`,
                h[1] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`,
                h[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let _ = 0; _ < 3; _++) {
                        const w = (_ + 1) % 3
                          , T = h[_]
                          , A = h[w]
                          , C = Bp[d[_]]
                          , P = Bp[d[w]]
                          , N = `${T}_ ${A}`
                          , b = `${A}_ ${T}`;
                        b in p && p[b] ? (By.dot(p[b].normal) <= s && (m.push(C.x, C.y, C.z),
                        m.push(P.x, P.y, P.z)),
                        p[b] = null) : N in p || (p[N] = {
                            index0: f[_],
                            index1: f[w],
                            normal: By.clone()
                        })
                    }
            }
            for (const y in p)
                if (p[y]) {
                    const {index0: S, index1: M} = p[y];
                    Fp.fromBufferAttribute(a, S),
                    zp.fromBufferAttribute(a, M),
                    m.push(Fp.x, Fp.y, Fp.z),
                    m.push(zp.x, zp.y, zp.z)
                }
            this.setAttribute("position", new je(m,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class Xa extends sd {
    constructor(e) {
        super(e),
        this.uuid = Qi(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new sd().fromJSON(r))
        }
        return this
    }
}
const O9 = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = aI(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, f, d, h, p, m;
        if (i && (s = H9(n, e, s, t)),
        n.length > 80 * t) {
            a = f = n[0],
            l = d = n[1];
            for (let y = t; y < r; y += t)
                h = n[y],
                p = n[y + 1],
                h < a && (a = h),
                p < l && (l = p),
                h > f && (f = h),
                p > d && (d = p);
            m = Math.max(f - a, d - l),
            m = m !== 0 ? 32767 / m : 0
        }
        return od(s, o, t, a, l, m, 0),
        o
    }
};
function aI(n, e, t, i, r) {
    let s, o;
    if (r === J9(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = GA(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = GA(s, n[s], n[s + 1], o);
    return o && w0(o, o.next) && (ld(o),
    o = o.next),
    o
}
function tl(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (w0(t, t.next) || hn(t.prev, t, t.next) === 0)) {
            if (ld(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function od(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && j9(n, i, r, s);
    let a = n, l, f;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        f = n.next,
        s ? z9(n, i, r, s) : F9(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(f.i / t | 0),
            ld(n),
            n = f.next,
            a = f.next;
            continue
        }
        if (n = f,
        n === a) {
            o ? o === 1 ? (n = B9(tl(n), e, t),
            od(n, e, t, i, r, s, 2)) : o === 2 && V9(n, e, t, i, r, s) : od(tl(n), e, t, i, r, s, 1);
            break
        }
    }
}
function F9(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (hn(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , l = t.y
      , f = i.y
      , d = r < s ? r < o ? r : o : s < o ? s : o
      , h = a < l ? a < f ? a : f : l < f ? l : f
      , p = r > s ? r > o ? r : o : s > o ? s : o
      , m = a > l ? a > f ? a : f : l > f ? l : f;
    let y = i.next;
    for (; y !== e; ) {
        if (y.x >= d && y.x <= p && y.y >= h && y.y <= m && xc(r, a, s, l, o, f, y.x, y.y) && hn(y.prev, y, y.next) >= 0)
            return !1;
        y = y.next
    }
    return !0
}
function z9(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (hn(r, s, o) >= 0)
        return !1;
    const a = r.x
      , l = s.x
      , f = o.x
      , d = r.y
      , h = s.y
      , p = o.y
      , m = a < l ? a < f ? a : f : l < f ? l : f
      , y = d < h ? d < p ? d : p : h < p ? h : p
      , S = a > l ? a > f ? a : f : l > f ? l : f
      , M = d > h ? d > p ? d : p : h > p ? h : p
      , g = Zx(m, y, e, t, i)
      , _ = Zx(S, M, e, t, i);
    let w = n.prevZ
      , T = n.nextZ;
    for (; w && w.z >= g && T && T.z <= _; ) {
        if (w.x >= m && w.x <= S && w.y >= y && w.y <= M && w !== r && w !== o && xc(a, d, l, h, f, p, w.x, w.y) && hn(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        T.x >= m && T.x <= S && T.y >= y && T.y <= M && T !== r && T !== o && xc(a, d, l, h, f, p, T.x, T.y) && hn(T.prev, T, T.next) >= 0))
            return !1;
        T = T.nextZ
    }
    for (; w && w.z >= g; ) {
        if (w.x >= m && w.x <= S && w.y >= y && w.y <= M && w !== r && w !== o && xc(a, d, l, h, f, p, w.x, w.y) && hn(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; T && T.z <= _; ) {
        if (T.x >= m && T.x <= S && T.y >= y && T.y <= M && T !== r && T !== o && xc(a, d, l, h, f, p, T.x, T.y) && hn(T.prev, T, T.next) >= 0)
            return !1;
        T = T.nextZ
    }
    return !0
}
function B9(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !w0(r, s) && lI(r, i, i.next, s) && ad(r, s) && ad(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        ld(i),
        ld(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return tl(i)
}
function V9(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && K9(o, a)) {
                let l = cI(o, a);
                o = tl(o, o.next),
                l = tl(l, l.next),
                od(o, e, t, i, r, s, 0),
                od(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function H9(n, e, t, i) {
    const r = [];
    let s, o, a, l, f;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        l = s < o - 1 ? e[s + 1] * i : n.length,
        f = aI(n, a, l, i, !1),
        f === f.next && (f.steiner = !0),
        r.push(q9(f));
    for (r.sort(G9),
    s = 0; s < r.length; s++)
        t = W9(r[s], t);
    return t
}
function G9(n, e) {
    return n.x - e.x
}
function W9(n, e) {
    const t = X9(n, e);
    if (!t)
        return e;
    const i = cI(t, n);
    return tl(i, i.next),
    tl(t, t.next)
}
function X9(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (p <= s && p > i && (i = p,
            r = t.x < t.next.x ? t : t.next,
            p === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , l = r.x
      , f = r.y;
    let d = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= l && s !== t.x && xc(o < f ? s : i, o, l, f, o < f ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        ad(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && $9(r, t))) && (r = t,
        d = h)),
        t = t.next;
    while (t !== a);
    return r
}
function $9(n, e) {
    return hn(n.prev, n, e.prev) < 0 && hn(e.next, n, n.next) < 0
}
function j9(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = Zx(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    Y9(r)
}
function Y9(n) {
    let e, t, i, r, s, o, a, l, f = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < f && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (l = f; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        f *= 2
    } while (o > 1);
    return n
}
function Zx(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function q9(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function xc(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function K9(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !Z9(n, e) && (ad(n, e) && ad(e, n) && Q9(n, e) && (hn(n.prev, n, e.prev) || hn(n, e.prev, e)) || w0(n, e) && hn(n.prev, n, n.next) > 0 && hn(e.prev, e, e.next) > 0)
}
function hn(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function w0(n, e) {
    return n.x === e.x && n.y === e.y
}
function lI(n, e, t, i) {
    const r = Hp(hn(n, e, t))
      , s = Hp(hn(n, e, i))
      , o = Hp(hn(t, i, n))
      , a = Hp(hn(t, i, e));
    return !!(r !== s && o !== a || r === 0 && Vp(n, t, e) || s === 0 && Vp(n, i, e) || o === 0 && Vp(t, n, i) || a === 0 && Vp(t, e, i))
}
function Vp(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function Hp(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function Z9(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && lI(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function ad(n, e) {
    return hn(n.prev, n, n.next) < 0 ? hn(n, e, n.next) >= 0 && hn(n, n.prev, e) >= 0 : hn(n, e, n.prev) < 0 || hn(n, n.next, e) < 0
}
function Q9(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function cI(n, e) {
    const t = new Qx(n.i,n.x,n.y)
      , i = new Qx(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function GA(n, e, t, i) {
    const r = new Qx(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function ld(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function Qx(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function J9(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class Ss {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return Ss.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        WA(e),
        XA(i, e);
        let o = e.length;
        t.forEach(WA);
        for (let l = 0; l < t.length; l++)
            r.push(o),
            o += t[l].length,
            XA(i, t[l]);
        const a = O9.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function WA(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function XA(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Dd extends ft {
    constructor(e=new Xa([new be(.5,.5), new be(-.5,.5), new be(-.5,-.5), new be(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a];
            o(f)
        }
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("uv", new je(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , f = t.curveSegments !== void 0 ? t.curveSegments : 12
              , d = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , m = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , y = t.bevelSize !== void 0 ? t.bevelSize : m - .1
              , S = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , M = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const g = t.extrudePath
              , _ = t.UVGenerator !== void 0 ? t.UVGenerator : e7;
            let w, T = !1, A, C, P, N;
            g && (w = g.getSpacedPoints(d),
            T = !0,
            p = !1,
            A = g.computeFrenetFrames(d, !1),
            C = new z,
            P = new z,
            N = new z),
            p || (M = 0,
            m = 0,
            y = 0,
            S = 0);
            const b = a.extractPoints(f);
            let L = b.shape;
            const Y = b.holes;
            if (!Ss.isClockWise(L)) {
                L = L.reverse();
                for (let se = 0, oe = Y.length; se < oe; se++) {
                    const ve = Y[se];
                    Ss.isClockWise(ve) && (Y[se] = ve.reverse())
                }
            }
            const $ = Ss.triangulateShape(L, Y)
              , Q = L;
            for (let se = 0, oe = Y.length; se < oe; se++) {
                const ve = Y[se];
                L = L.concat(ve)
            }
            function ie(se, oe, ve) {
                return oe || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                se.clone().addScaledVector(oe, ve)
            }
            const fe = L.length
              , le = $.length;
            function D(se, oe, ve) {
                let Ce, Re, Le;
                const Be = se.x - oe.x
                  , Ze = se.y - oe.y
                  , Ye = ve.x - se.x
                  , pt = ve.y - se.y
                  , G = Be * Be + Ze * Ze
                  , k = Be * pt - Ze * Ye;
                if (Math.abs(k) > Number.EPSILON) {
                    const ee = Math.sqrt(G)
                      , we = Math.sqrt(Ye * Ye + pt * pt)
                      , Ie = oe.x - Ze / ee
                      , Fe = oe.y + Be / ee
                      , Je = ve.x - pt / we
                      , We = ve.y + Ye / we
                      , Me = ((Je - Ie) * pt - (We - Fe) * Ye) / (Be * pt - Ze * Ye);
                    Ce = Ie + Be * Me - se.x,
                    Re = Fe + Ze * Me - se.y;
                    const Qe = Ce * Ce + Re * Re;
                    if (Qe <= 2)
                        return new be(Ce,Re);
                    Le = Math.sqrt(Qe / 2)
                } else {
                    let ee = !1;
                    Be > Number.EPSILON ? Ye > Number.EPSILON && (ee = !0) : Be < -Number.EPSILON ? Ye < -Number.EPSILON && (ee = !0) : Math.sign(Ze) === Math.sign(pt) && (ee = !0),
                    ee ? (Ce = -Ze,
                    Re = Be,
                    Le = Math.sqrt(G)) : (Ce = Be,
                    Re = Ze,
                    Le = Math.sqrt(G / 2))
                }
                return new be(Ce / Le,Re / Le)
            }
            const j = [];
            for (let se = 0, oe = Q.length, ve = oe - 1, Ce = se + 1; se < oe; se++,
            ve++,
            Ce++)
                ve === oe && (ve = 0),
                Ce === oe && (Ce = 0),
                j[se] = D(Q[se], Q[ve], Q[Ce]);
            const X = [];
            let ue, I = j.concat();
            for (let se = 0, oe = Y.length; se < oe; se++) {
                const ve = Y[se];
                ue = [];
                for (let Ce = 0, Re = ve.length, Le = Re - 1, Be = Ce + 1; Ce < Re; Ce++,
                Le++,
                Be++)
                    Le === Re && (Le = 0),
                    Be === Re && (Be = 0),
                    ue[Ce] = D(ve[Ce], ve[Le], ve[Be]);
                X.push(ue),
                I = I.concat(ue)
            }
            for (let se = 0; se < M; se++) {
                const oe = se / M
                  , ve = m * Math.cos(oe * Math.PI / 2)
                  , Ce = y * Math.sin(oe * Math.PI / 2) + S;
                for (let Re = 0, Le = Q.length; Re < Le; Re++) {
                    const Be = ie(Q[Re], j[Re], Ce);
                    B(Be.x, Be.y, -ve)
                }
                for (let Re = 0, Le = Y.length; Re < Le; Re++) {
                    const Be = Y[Re];
                    ue = X[Re];
                    for (let Ze = 0, Ye = Be.length; Ze < Ye; Ze++) {
                        const pt = ie(Be[Ze], ue[Ze], Ce);
                        B(pt.x, pt.y, -ve)
                    }
                }
            }
            const U = y + S;
            for (let se = 0; se < fe; se++) {
                const oe = p ? ie(L[se], I[se], U) : L[se];
                T ? (P.copy(A.normals[0]).multiplyScalar(oe.x),
                C.copy(A.binormals[0]).multiplyScalar(oe.y),
                N.copy(w[0]).add(P).add(C),
                B(N.x, N.y, N.z)) : B(oe.x, oe.y, 0)
            }
            for (let se = 1; se <= d; se++)
                for (let oe = 0; oe < fe; oe++) {
                    const ve = p ? ie(L[oe], I[oe], U) : L[oe];
                    T ? (P.copy(A.normals[se]).multiplyScalar(ve.x),
                    C.copy(A.binormals[se]).multiplyScalar(ve.y),
                    N.copy(w[se]).add(P).add(C),
                    B(N.x, N.y, N.z)) : B(ve.x, ve.y, h / d * se)
                }
            for (let se = M - 1; se >= 0; se--) {
                const oe = se / M
                  , ve = m * Math.cos(oe * Math.PI / 2)
                  , Ce = y * Math.sin(oe * Math.PI / 2) + S;
                for (let Re = 0, Le = Q.length; Re < Le; Re++) {
                    const Be = ie(Q[Re], j[Re], Ce);
                    B(Be.x, Be.y, h + ve)
                }
                for (let Re = 0, Le = Y.length; Re < Le; Re++) {
                    const Be = Y[Re];
                    ue = X[Re];
                    for (let Ze = 0, Ye = Be.length; Ze < Ye; Ze++) {
                        const pt = ie(Be[Ze], ue[Ze], Ce);
                        T ? B(pt.x, pt.y + w[d - 1].y, w[d - 1].x + ve) : B(pt.x, pt.y, h + ve)
                    }
                }
            }
            O(),
            J();
            function O() {
                const se = r.length / 3;
                if (p) {
                    let oe = 0
                      , ve = fe * oe;
                    for (let Ce = 0; Ce < le; Ce++) {
                        const Re = $[Ce];
                        ae(Re[2] + ve, Re[1] + ve, Re[0] + ve)
                    }
                    oe = d + M * 2,
                    ve = fe * oe;
                    for (let Ce = 0; Ce < le; Ce++) {
                        const Re = $[Ce];
                        ae(Re[0] + ve, Re[1] + ve, Re[2] + ve)
                    }
                } else {
                    for (let oe = 0; oe < le; oe++) {
                        const ve = $[oe];
                        ae(ve[2], ve[1], ve[0])
                    }
                    for (let oe = 0; oe < le; oe++) {
                        const ve = $[oe];
                        ae(ve[0] + fe * d, ve[1] + fe * d, ve[2] + fe * d)
                    }
                }
                i.addGroup(se, r.length / 3 - se, 0)
            }
            function J() {
                const se = r.length / 3;
                let oe = 0;
                F(Q, oe),
                oe += Q.length;
                for (let ve = 0, Ce = Y.length; ve < Ce; ve++) {
                    const Re = Y[ve];
                    F(Re, oe),
                    oe += Re.length
                }
                i.addGroup(se, r.length / 3 - se, 1)
            }
            function F(se, oe) {
                let ve = se.length;
                for (; --ve >= 0; ) {
                    const Ce = ve;
                    let Re = ve - 1;
                    Re < 0 && (Re = se.length - 1);
                    for (let Le = 0, Be = d + M * 2; Le < Be; Le++) {
                        const Ze = fe * Le
                          , Ye = fe * (Le + 1)
                          , pt = oe + Ce + Ze
                          , G = oe + Re + Ze
                          , k = oe + Re + Ye
                          , ee = oe + Ce + Ye;
                        _e(pt, G, k, ee)
                    }
                }
            }
            function B(se, oe, ve) {
                l.push(se),
                l.push(oe),
                l.push(ve)
            }
            function ae(se, oe, ve) {
                pe(se),
                pe(oe),
                pe(ve);
                const Ce = r.length / 3
                  , Re = _.generateTopUV(i, r, Ce - 3, Ce - 2, Ce - 1);
                Ee(Re[0]),
                Ee(Re[1]),
                Ee(Re[2])
            }
            function _e(se, oe, ve, Ce) {
                pe(se),
                pe(oe),
                pe(Ce),
                pe(oe),
                pe(ve),
                pe(Ce);
                const Re = r.length / 3
                  , Le = _.generateSideWallUV(i, r, Re - 6, Re - 3, Re - 2, Re - 1);
                Ee(Le[0]),
                Ee(Le[1]),
                Ee(Le[3]),
                Ee(Le[1]),
                Ee(Le[2]),
                Ee(Le[3])
            }
            function pe(se) {
                r.push(l[se * 3 + 0]),
                r.push(l[se * 3 + 1]),
                r.push(l[se * 3 + 2])
            }
            function Ee(se) {
                s.push(se.x),
                s.push(se.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return t7(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new nw[r.type]().fromJSON(r)),
        new Dd(i,e.options)
    }
}
const e7 = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , l = e[i * 3 + 1]
          , f = e[r * 3]
          , d = e[r * 3 + 1];
        return [new be(s,o), new be(a,l), new be(f,d)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , f = e[i * 3]
          , d = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , p = e[r * 3]
          , m = e[r * 3 + 1]
          , y = e[r * 3 + 2]
          , S = e[s * 3]
          , M = e[s * 3 + 1]
          , g = e[s * 3 + 2];
        return Math.abs(a - d) < Math.abs(o - f) ? [new be(o,1 - l), new be(f,1 - h), new be(p,1 - y), new be(S,1 - g)] : [new be(a,1 - l), new be(d,1 - h), new be(m,1 - y), new be(M,1 - g)]
    }
};
function t7(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Ud extends oo {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ud(e.radius,e.detail)
    }
}
class hu extends oo {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new hu(e.radius,e.detail)
    }
}
class kd extends ft {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const a = []
          , l = []
          , f = []
          , d = [];
        let h = e;
        const p = (t - e) / r
          , m = new z
          , y = new be;
        for (let S = 0; S <= r; S++) {
            for (let M = 0; M <= i; M++) {
                const g = s + M / i * o;
                m.x = h * Math.cos(g),
                m.y = h * Math.sin(g),
                l.push(m.x, m.y, m.z),
                f.push(0, 0, 1),
                y.x = (m.x / t + 1) / 2,
                y.y = (m.y / t + 1) / 2,
                d.push(y.x, y.y)
            }
            h += p
        }
        for (let S = 0; S < r; S++) {
            const M = S * (i + 1);
            for (let g = 0; g < i; g++) {
                const _ = g + M
                  , w = _
                  , T = _ + i + 1
                  , A = _ + i + 2
                  , C = _ + 1;
                a.push(w, T, C),
                a.push(T, A, C)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(f,3)),
        this.setAttribute("uv", new je(d,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new kd(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class Od extends ft {
    constructor(e=new Xa([new be(0,.5), new be(-.5,-.5), new be(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let a = 0
          , l = 0;
        if (Array.isArray(e) === !1)
            f(e);
        else
            for (let d = 0; d < e.length; d++)
                f(e[d]),
                this.addGroup(a, l, d),
                a += l,
                l = 0;
        this.setIndex(i),
        this.setAttribute("position", new je(r,3)),
        this.setAttribute("normal", new je(s,3)),
        this.setAttribute("uv", new je(o,2));
        function f(d) {
            const h = r.length / 3
              , p = d.extractPoints(t);
            let m = p.shape;
            const y = p.holes;
            Ss.isClockWise(m) === !1 && (m = m.reverse());
            for (let M = 0, g = y.length; M < g; M++) {
                const _ = y[M];
                Ss.isClockWise(_) === !0 && (y[M] = _.reverse())
            }
            const S = Ss.triangulateShape(m, y);
            for (let M = 0, g = y.length; M < g; M++) {
                const _ = y[M];
                m = m.concat(_)
            }
            for (let M = 0, g = m.length; M < g; M++) {
                const _ = m[M];
                r.push(_.x, _.y, 0),
                s.push(0, 0, 1),
                o.push(_.x, _.y)
            }
            for (let M = 0, g = S.length; M < g; M++) {
                const _ = S[M]
                  , w = _[0] + h
                  , T = _[1] + h
                  , A = _[2] + h;
                i.push(w, T, A),
                l += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return n7(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new Od(i,e.curveSegments)
    }
}
function n7(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class pu extends ft {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let f = 0;
        const d = []
          , h = new z
          , p = new z
          , m = []
          , y = []
          , S = []
          , M = [];
        for (let g = 0; g <= i; g++) {
            const _ = []
              , w = g / i;
            let T = 0;
            g === 0 && o === 0 ? T = .5 / t : g === i && l === Math.PI && (T = -.5 / t);
            for (let A = 0; A <= t; A++) {
                const C = A / t;
                h.x = -e * Math.cos(r + C * s) * Math.sin(o + w * a),
                h.y = e * Math.cos(o + w * a),
                h.z = e * Math.sin(r + C * s) * Math.sin(o + w * a),
                y.push(h.x, h.y, h.z),
                p.copy(h).normalize(),
                S.push(p.x, p.y, p.z),
                M.push(C + T, 1 - w),
                _.push(f++)
            }
            d.push(_)
        }
        for (let g = 0; g < i; g++)
            for (let _ = 0; _ < t; _++) {
                const w = d[g][_ + 1]
                  , T = d[g][_]
                  , A = d[g + 1][_]
                  , C = d[g + 1][_ + 1];
                (g !== 0 || o > 0) && m.push(w, T, C),
                (g !== i - 1 || l < Math.PI) && m.push(T, A, C)
            }
        this.setIndex(m),
        this.setAttribute("position", new je(y,3)),
        this.setAttribute("normal", new je(S,3)),
        this.setAttribute("uv", new je(M,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new pu(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Fd extends oo {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Fd(e.radius,e.detail)
    }
}
class zd extends ft {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , a = []
          , l = []
          , f = []
          , d = new z
          , h = new z
          , p = new z;
        for (let m = 0; m <= i; m++)
            for (let y = 0; y <= r; y++) {
                const S = y / r * s
                  , M = m / i * Math.PI * 2;
                h.x = (e + t * Math.cos(M)) * Math.cos(S),
                h.y = (e + t * Math.cos(M)) * Math.sin(S),
                h.z = t * Math.sin(M),
                a.push(h.x, h.y, h.z),
                d.x = e * Math.cos(S),
                d.y = e * Math.sin(S),
                p.subVectors(h, d).normalize(),
                l.push(p.x, p.y, p.z),
                f.push(y / r),
                f.push(m / i)
            }
        for (let m = 1; m <= i; m++)
            for (let y = 1; y <= r; y++) {
                const S = (r + 1) * m + y - 1
                  , M = (r + 1) * (m - 1) + y - 1
                  , g = (r + 1) * (m - 1) + y
                  , _ = (r + 1) * m + y;
                o.push(S, M, _),
                o.push(M, g, _)
            }
        this.setIndex(o),
        this.setAttribute("position", new je(a,3)),
        this.setAttribute("normal", new je(l,3)),
        this.setAttribute("uv", new je(f,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new zd(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class Bd extends ft {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const a = []
          , l = []
          , f = []
          , d = []
          , h = new z
          , p = new z
          , m = new z
          , y = new z
          , S = new z
          , M = new z
          , g = new z;
        for (let w = 0; w <= i; ++w) {
            const T = w / i * s * Math.PI * 2;
            _(T, s, o, e, m),
            _(T + .01, s, o, e, y),
            M.subVectors(y, m),
            g.addVectors(y, m),
            S.crossVectors(M, g),
            g.crossVectors(S, M),
            S.normalize(),
            g.normalize();
            for (let A = 0; A <= r; ++A) {
                const C = A / r * Math.PI * 2
                  , P = -t * Math.cos(C)
                  , N = t * Math.sin(C);
                h.x = m.x + (P * g.x + N * S.x),
                h.y = m.y + (P * g.y + N * S.y),
                h.z = m.z + (P * g.z + N * S.z),
                l.push(h.x, h.y, h.z),
                p.subVectors(h, m).normalize(),
                f.push(p.x, p.y, p.z),
                d.push(w / i),
                d.push(A / r)
            }
        }
        for (let w = 1; w <= i; w++)
            for (let T = 1; T <= r; T++) {
                const A = (r + 1) * (w - 1) + (T - 1)
                  , C = (r + 1) * w + (T - 1)
                  , P = (r + 1) * w + T
                  , N = (r + 1) * (w - 1) + T;
                a.push(A, C, N),
                a.push(C, P, N)
            }
        this.setIndex(a),
        this.setAttribute("position", new je(l,3)),
        this.setAttribute("normal", new je(f,3)),
        this.setAttribute("uv", new je(d,2));
        function _(w, T, A, C, P) {
            const N = Math.cos(w)
              , b = Math.sin(w)
              , L = A / T * w
              , Y = Math.cos(L);
            P.x = C * (2 + Y) * .5 * N,
            P.y = C * (2 + Y) * b * .5,
            P.z = C * Math.sin(L) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Bd(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Vd extends ft {
    constructor(e=new ew(new z(-1,-1,0),new z(-1,1,0),new z(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new z
          , l = new z
          , f = new be;
        let d = new z;
        const h = []
          , p = []
          , m = []
          , y = [];
        S(),
        this.setIndex(y),
        this.setAttribute("position", new je(h,3)),
        this.setAttribute("normal", new je(p,3)),
        this.setAttribute("uv", new je(m,2));
        function S() {
            for (let w = 0; w < t; w++)
                M(w);
            M(s === !1 ? t : 0),
            _(),
            g()
        }
        function M(w) {
            d = e.getPointAt(w / t, d);
            const T = o.normals[w]
              , A = o.binormals[w];
            for (let C = 0; C <= r; C++) {
                const P = C / r * Math.PI * 2
                  , N = Math.sin(P)
                  , b = -Math.cos(P);
                l.x = b * T.x + N * A.x,
                l.y = b * T.y + N * A.y,
                l.z = b * T.z + N * A.z,
                l.normalize(),
                p.push(l.x, l.y, l.z),
                a.x = d.x + i * l.x,
                a.y = d.y + i * l.y,
                a.z = d.z + i * l.z,
                h.push(a.x, a.y, a.z)
            }
        }
        function g() {
            for (let w = 1; w <= t; w++)
                for (let T = 1; T <= r; T++) {
                    const A = (r + 1) * (w - 1) + (T - 1)
                      , C = (r + 1) * w + (T - 1)
                      , P = (r + 1) * w + T
                      , N = (r + 1) * (w - 1) + T;
                    y.push(A, C, N),
                    y.push(C, P, N)
                }
        }
        function _() {
            for (let w = 0; w <= t; w++)
                for (let T = 0; T <= r; T++)
                    f.x = w / t,
                    f.y = T / r,
                    m.push(f.x, f.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Vd(new nw[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class uI extends ft {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new z
              , s = new z;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let f = 0, d = l.length; f < d; ++f) {
                    const h = l[f]
                      , p = h.start
                      , m = h.count;
                    for (let y = p, S = p + m; y < S; y += 3)
                        for (let M = 0; M < 3; M++) {
                            const g = a.getX(y + M)
                              , _ = a.getX(y + (M + 1) % 3);
                            r.fromBufferAttribute(o, g),
                            s.fromBufferAttribute(o, _),
                            $A(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let f = 0; f < 3; f++) {
                        const d = 3 * a + f
                          , h = 3 * a + (f + 1) % 3;
                        r.fromBufferAttribute(o, d),
                        s.fromBufferAttribute(o, h),
                        $A(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new je(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function $A(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var jA = Object.freeze({
    __proto__: null,
    BoxGeometry: oa,
    CapsuleGeometry: Pd,
    CircleGeometry: Ld,
    ConeGeometry: Id,
    CylinderGeometry: hl,
    DodecahedronGeometry: Nd,
    EdgesGeometry: oI,
    ExtrudeGeometry: Dd,
    IcosahedronGeometry: Ud,
    LatheGeometry: du,
    OctahedronGeometry: hu,
    PlaneGeometry: cu,
    PolyhedronGeometry: oo,
    RingGeometry: kd,
    ShapeGeometry: Od,
    SphereGeometry: pu,
    TetrahedronGeometry: Fd,
    TorusGeometry: zd,
    TorusKnotGeometry: Bd,
    TubeGeometry: Vd,
    WireframeGeometry: uI
});
class fI extends Nn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Oe(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class dI extends Ms {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Hd extends Nn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Oe(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class ao extends Hd {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new be(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return xn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Oe(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Oe(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Oe(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class Df extends Nn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Oe(16777215),
        this.specular = new Oe(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Td,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class hI extends Nn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class pI extends Nn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class iw extends Nn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Oe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Oe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Td,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class mI extends Nn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Oe(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = sa,
        this.normalScale = new be(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class gI extends ni {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function pr(n, e, t) {
    return rw(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t)
}
function Fa(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function rw(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function vI(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function Jx(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            r[o++] = n[a + l]
    }
    return r
}
function sw(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function i7(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const f = s.tracks[l]
          , d = f.getValueSize()
          , h = []
          , p = [];
        for (let m = 0; m < f.times.length; ++m) {
            const y = f.times[m] * r;
            if (!(y < t || y >= i)) {
                h.push(f.times[m]);
                for (let S = 0; S < d; ++S)
                    p.push(f.values[m * d + S])
            }
        }
        h.length !== 0 && (f.times = Fa(h, f.times.constructor),
        f.values = Fa(p, f.values.constructor),
        o.push(f))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l)
        a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l)
        s.tracks[l].shift(-1 * a);
    return s.resetDuration(),
    s
}
function r7(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o]
          , l = a.ValueTypeName;
        if (l === "bool" || l === "string")
            continue;
        const f = n.tracks.find(function(g) {
            return g.name === a.name && g.ValueTypeName === l
        });
        if (f === void 0)
            continue;
        let d = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let p = 0;
        const m = f.getValueSize();
        f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
        const y = a.times.length - 1;
        let S;
        if (s <= a.times[0]) {
            const g = d
              , _ = h - d;
            S = pr(a.values, g, _)
        } else if (s >= a.times[y]) {
            const g = y * h + d
              , _ = g + h - d;
            S = pr(a.values, g, _)
        } else {
            const g = a.createInterpolant()
              , _ = d
              , w = h - d;
            g.evaluate(s),
            S = pr(g.resultBuffer, _, w)
        }
        l === "quaternion" && new In().fromArray(S).normalize().conjugate().toArray(S);
        const M = f.times.length;
        for (let g = 0; g < M; ++g) {
            const _ = g * m + p;
            if (l === "quaternion")
                In.multiplyQuaternionsFlat(f.values, _, S, 0, f.values, _);
            else {
                const w = m - p * 2;
                for (let T = 0; T < w; ++T)
                    f.values[_ + T] -= S[T]
            }
        }
    }
    return n.blendMode = D1,
    n
}
const s7 = {
    arraySlice: pr,
    convertArray: Fa,
    isTypedArray: rw,
    getKeyframeOrder: vI,
    sortedArray: Jx,
    flattenJSON: sw,
    subclip: i7,
    makeClipAdditive: r7
};
class mu {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2,
                        s = a);
                        for (let l = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === l)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class yI extends mu {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Ua,
            endingEnd: Ua
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = r[s]
          , l = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case ka:
                s = e,
                a = 2 * t - i;
                break;
            case nd:
                s = r.length - 2,
                a = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                a = i
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case ka:
                o = e,
                l = 2 * i - t;
                break;
            case nd:
                o = 1,
                l = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const f = (i - t) * .5
          , d = this.valueSize;
        this._weightPrev = f / (t - a),
        this._weightNext = f / (l - i),
        this._offsetPrev = s * d,
        this._offsetNext = o * d
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , f = l - a
          , d = this._offsetPrev
          , h = this._offsetNext
          , p = this._weightPrev
          , m = this._weightNext
          , y = (i - t) / (r - t)
          , S = y * y
          , M = S * y
          , g = -p * M + 2 * p * S - p * y
          , _ = (1 + p) * M + (-1.5 - 2 * p) * S + (-.5 + p) * y + 1
          , w = (-1 - m) * M + (1.5 + m) * S + .5 * y
          , T = m * M - m * S;
        for (let A = 0; A !== a; ++A)
            s[A] = g * o[d + A] + _ * o[f + A] + w * o[l + A] + T * o[h + A];
        return s
    }
}
class ow extends mu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , f = l - a
          , d = (i - t) / (r - t)
          , h = 1 - d;
        for (let p = 0; p !== a; ++p)
            s[p] = o[f + p] * h + o[l + p] * d;
        return s
    }
}
class _I extends mu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class rs {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Fa(t, this.TimeBufferType),
        this.values = Fa(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: Fa(e.times, Array),
                values: Fa(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new _I(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new ow(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new yI(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Zc:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case el:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case _m:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Zc;
        case this.InterpolantFactoryMethodLinear:
            return el;
        case this.InterpolantFactoryMethodSmooth:
            return _m
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = pr(i, s, o),
            this.values = pr(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && rw(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const f = r[a];
                if (isNaN(f)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = pr(this.times)
          , t = pr(this.values)
          , i = this.getValueSize()
          , r = this.getInterpolation() === _m
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const f = e[a]
              , d = e[a + 1];
            if (f !== d && (a !== 1 || f !== e[0]))
                if (r)
                    l = !0;
                else {
                    const h = a * i
                      , p = h - i
                      , m = h + i;
                    for (let y = 0; y !== i; ++y) {
                        const S = t[h + y];
                        if (S !== t[p + y] || S !== t[m + y]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i
                      , p = o * i;
                    for (let m = 0; m !== i; ++m)
                        t[p + m] = t[h + m]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, f = 0; f !== i; ++f)
                t[l + f] = t[a + f];
            ++o
        }
        return o !== e.length ? (this.times = pr(e, 0, o),
        this.values = pr(t, 0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = pr(this.times, 0)
          , t = pr(this.values, 0)
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
rs.prototype.TimeBufferType = Float32Array;
rs.prototype.ValueBufferType = Float32Array;
rs.prototype.DefaultInterpolation = el;
class pl extends rs {
}
pl.prototype.ValueTypeName = "bool";
pl.prototype.ValueBufferType = Array;
pl.prototype.DefaultInterpolation = Zc;
pl.prototype.InterpolantFactoryMethodLinear = void 0;
pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class aw extends rs {
}
aw.prototype.ValueTypeName = "color";
class nl extends rs {
}
nl.prototype.ValueTypeName = "number";
class xI extends mu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (i - t) / (r - t);
        let f = e * a;
        for (let d = f + a; f !== d; f += 4)
            In.slerpFlat(s, 0, o, f - a, o, f, l);
        return s
    }
}
class no extends rs {
    InterpolantFactoryMethodLinear(e) {
        return new xI(this.times,this.values,this.getValueSize(),e)
    }
}
no.prototype.ValueTypeName = "quaternion";
no.prototype.DefaultInterpolation = el;
no.prototype.InterpolantFactoryMethodSmooth = void 0;
class ml extends rs {
}
ml.prototype.ValueTypeName = "string";
ml.prototype.ValueBufferType = Array;
ml.prototype.DefaultInterpolation = Zc;
ml.prototype.InterpolantFactoryMethodLinear = void 0;
ml.prototype.InterpolantFactoryMethodSmooth = void 0;
class il extends rs {
}
il.prototype.ValueTypeName = "vector";
class rl {
    constructor(e, t=-1, i, r=f0) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Qi(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(a7(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(rs.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , f = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            f.push(0, 1, 0);
            const d = vI(l);
            l = Jx(l, 1, d),
            f = Jx(f, 1, d),
            !r && l[0] === 0 && (l.push(s),
            f.push(f[0])),
            o.push(new nl(".morphTargetInfluences[" + t[a].name + "]",l,f).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a]
              , d = f.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let p = r[h];
                p || (r[h] = p = []),
                p.push(f)
            }
        }
        const o = [];
        for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(h, p, m, y, S) {
            if (m.length !== 0) {
                const M = []
                  , g = [];
                sw(m, M, g, y),
                M.length !== 0 && S.push(new h(p,M,g))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const f = e.hierarchy || [];
        for (let h = 0; h < f.length; h++) {
            const p = f[h].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const m = {};
                    let y;
                    for (y = 0; y < p.length; y++)
                        if (p[y].morphTargets)
                            for (let S = 0; S < p[y].morphTargets.length; S++)
                                m[p[y].morphTargets[S]] = -1;
                    for (const S in m) {
                        const M = []
                          , g = [];
                        for (let _ = 0; _ !== p[y].morphTargets.length; ++_) {
                            const w = p[y];
                            M.push(w.time),
                            g.push(w.morphTarget === S ? 1 : 0)
                        }
                        r.push(new nl(".morphTargetInfluence[" + S + "]",M,g))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[h].name + "]";
                    i(il, m + ".position", p, "pos", r),
                    i(no, m + ".quaternion", p, "rot", r),
                    i(il, m + ".scale", p, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,l,r,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function o7(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return nl;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return il;
    case "color":
        return aw;
    case "quaternion":
        return no;
    case "bool":
    case "boolean":
        return pl;
    case "string":
        return ml
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function a7(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = o7(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        sw(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const sl = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class lw {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const f = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(d) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(d, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(d) {
            o++,
            r.onProgress !== void 0 && r.onProgress(d, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(d) {
            r.onError !== void 0 && r.onError(d)
        }
        ,
        this.resolveURL = function(d) {
            return l ? l(d) : d
        }
        ,
        this.setURLModifier = function(d) {
            return l = d,
            this
        }
        ,
        this.addHandler = function(d, h) {
            return f.push(d, h),
            this
        }
        ,
        this.removeHandler = function(d) {
            const h = f.indexOf(d);
            return h !== -1 && f.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(d) {
            for (let h = 0, p = f.length; h < p; h += 2) {
                const m = f[h]
                  , y = f[h + 1];
                if (m.global && (m.lastIndex = 0),
                m.test(d))
                    return y
            }
            return null
        }
    }
}
const SI = new lw;
class Mi {
    constructor(e) {
        this.manager = e !== void 0 ? e : SI,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const Bs = {};
class l7 extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Er extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = sl.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Bs[e] !== void 0) {
            Bs[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Bs[e] = [],
        Bs[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(f=>{
            if (f.status === 200 || f.status === 0) {
                if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
                    return f;
                const d = Bs[e]
                  , h = f.body.getReader()
                  , p = f.headers.get("Content-Length") || f.headers.get("X-File-Size")
                  , m = p ? parseInt(p) : 0
                  , y = m !== 0;
                let S = 0;
                const M = new ReadableStream({
                    start(g) {
                        _();
                        function _() {
                            h.read().then(({done: w, value: T})=>{
                                if (w)
                                    g.close();
                                else {
                                    S += T.byteLength;
                                    const A = new ProgressEvent("progress",{
                                        lengthComputable: y,
                                        loaded: S,
                                        total: m
                                    });
                                    for (let C = 0, P = d.length; C < P; C++) {
                                        const N = d[C];
                                        N.onProgress && N.onProgress(A)
                                    }
                                    g.enqueue(T),
                                    _()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(M)
            } else
                throw new l7(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`,f)
        }
        ).then(f=>{
            switch (l) {
            case "arraybuffer":
                return f.arrayBuffer();
            case "blob":
                return f.blob();
            case "document":
                return f.text().then(d=>new DOMParser().parseFromString(d, a));
            case "json":
                return f.json();
            default:
                if (a === void 0)
                    return f.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , p = h && h[1] ? h[1].toLowerCase() : void 0
                      , m = new TextDecoder(p);
                    return f.arrayBuffer().then(y=>m.decode(y))
                }
            }
        }
        ).then(f=>{
            sl.add(e, f);
            const d = Bs[e];
            delete Bs[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onLoad && m.onLoad(f)
            }
        }
        ).catch(f=>{
            const d = Bs[e];
            if (d === void 0)
                throw this.manager.itemError(e),
                f;
            delete Bs[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onError && m.onError(f)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class c7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Er(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = rl.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class u7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , a = new K1
          , l = new Er(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(s.withCredentials);
        let f = 0;
        function d(h) {
            l.load(e[h], function(p) {
                const m = s.parse(p, !0);
                o[h] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                },
                f += 1,
                f === 6 && (m.mipmapCount === 1 && (a.minFilter = dn),
                a.image = o,
                a.format = m.format,
                a.needsUpdate = !0,
                t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, p = e.length; h < p; ++h)
                d(h);
        else
            l.load(e, function(h) {
                const p = s.parse(h, !0);
                if (p.isCubemap) {
                    const m = p.mipmaps.length / p.mipmapCount;
                    for (let y = 0; y < m; y++) {
                        o[y] = {
                            mipmaps: []
                        };
                        for (let S = 0; S < p.mipmapCount; S++)
                            o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + S]),
                            o[y].format = p.format,
                            o[y].width = p.width,
                            o[y].height = p.height
                    }
                    a.image = o
                } else
                    a.image.width = p.width,
                    a.image.height = p.height,
                    a.mipmaps = p.mipmaps;
                p.mipmapCount === 1 && (a.minFilter = dn),
                a.format = p.format,
                a.needsUpdate = !0,
                t && t(a)
            }, i, r);
        return a
    }
}
class cd extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = sl.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = rd("img");
        function l() {
            d(),
            sl.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function f(h) {
            d(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function d() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", f, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", f, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class f7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Cd
          , o = new cd(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(f) {
            o.load(e[f], function(d) {
                s.images[f] = d,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let f = 0; f < e.length; ++f)
            l(f);
        return s
    }
}
class d7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Ic
          , a = new Er(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            const f = s.parse(l);
            f && (f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width,
            o.image.height = f.height,
            o.image.data = f.data),
            o.wrapS = f.wrapS !== void 0 ? f.wrapS : On,
            o.wrapT = f.wrapT !== void 0 ? f.wrapT : On,
            o.magFilter = f.magFilter !== void 0 ? f.magFilter : dn,
            o.minFilter = f.minFilter !== void 0 ? f.minFilter : dn,
            o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1,
            f.colorSpace !== void 0 ? o.colorSpace = f.colorSpace : f.encoding !== void 0 && (o.encoding = f.encoding),
            f.flipY !== void 0 && (o.flipY = f.flipY),
            f.format !== void 0 && (o.format = f.format),
            f.type !== void 0 && (o.type = f.type),
            f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps,
            o.minFilter = ws),
            f.mipmapCount === 1 && (o.minFilter = dn),
            f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, f))
        }, i, r),
        o
    }
}
class gl extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new en
          , o = new cd(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
let aa = class extends Lt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Oe(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
;
class wI extends aa {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(Lt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Oe(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const Vy = new $e
  , YA = new z
  , qA = new z;
class cw {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new be(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new $e,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new p0,
        this._frameExtents = new be(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ut(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        YA.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(YA),
        qA.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(qA),
        t.updateMatrixWorld(),
        Vy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Vy),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(Vy)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class h7 extends cw {
    constructor() {
        super(new Pn(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = Qc * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class M0 extends aa {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Lt,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new h7
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const KA = new $e
  , sf = new z
  , Hy = new z;
class p7 extends cw {
    constructor() {
        super(new Pn(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new be(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ut(2,1,1,1), new Ut(0,1,1,1), new Ut(3,1,1,1), new Ut(1,1,1,1), new Ut(3,0,1,1), new Ut(1,0,1,1)],
        this._cubeDirections = [new z(1,0,0), new z(-1,0,0), new z(0,0,1), new z(0,0,-1), new z(0,1,0), new z(0,-1,0)],
        this._cubeUps = [new z(0,1,0), new z(0,1,0), new z(0,1,0), new z(0,1,0), new z(0,0,1), new z(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        sf.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(sf),
        Hy.copy(i.position),
        Hy.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(Hy),
        i.updateMatrixWorld(),
        r.makeTranslation(-sf.x, -sf.y, -sf.z),
        KA.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(KA)
    }
}
class ud extends aa {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new p7
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class m7 extends cw {
    constructor() {
        super(new dl(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class E0 extends aa {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Lt,
        this.shadow = new m7
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class uw extends aa {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class MI extends aa {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class EI {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new z)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class T0 extends aa {
    constructor(e=new EI, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class A0 extends Mi {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new Er(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = A0.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Oe().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== 1 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Oe().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new be().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new z().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new Ut().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new Rt().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new $e().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (r.lights = e.lights),
        e.clipping !== void 0 && (r.clipping = e.clipping),
        e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new be().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new be().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: fI,
            SpriteMaterial: $1,
            RawShaderMaterial: dI,
            ShaderMaterial: Ms,
            PointsMaterial: _0,
            MeshPhysicalMaterial: ao,
            MeshStandardMaterial: Hd,
            MeshPhongMaterial: Df,
            MeshToonMaterial: hI,
            MeshNormalMaterial: pI,
            MeshLambertMaterial: iw,
            MeshDepthMaterial: G1,
            MeshDistanceMaterial: W1,
            MeshBasicMaterial: Ki,
            MeshMatcapMaterial: mI,
            LineDashedMaterial: gI,
            LineBasicMaterial: ni,
            Material: Nn
        };
        return new t[e]
    }
}
class ol {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class TI extends ft {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class AI extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Er(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(m, y) {
            if (t[y] !== void 0)
                return t[y];
            const M = m.interleavedBuffers[y]
              , g = s(m, M.buffer)
              , _ = yc(M.type, g)
              , w = new bd(_,M.stride);
            return w.uuid = M.uuid,
            t[y] = w,
            w
        }
        function s(m, y) {
            if (i[y] !== void 0)
                return i[y];
            const M = m.arrayBuffers[y]
              , g = new Uint32Array(M).buffer;
            return i[y] = g,
            g
        }
        const o = e.isInstancedBufferGeometry ? new TI : new ft
          , a = e.data.index;
        if (a !== void 0) {
            const m = yc(a.type, a.array);
            o.setIndex(new Ht(m,1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const y = l[m];
            let S;
            if (y.isInterleavedBufferAttribute) {
                const M = r(e.data, y.data);
                S = new Jo(M,y.itemSize,y.offset,y.normalized)
            } else {
                const M = yc(y.type, y.array)
                  , g = y.isInstancedBufferAttribute ? tu : Ht;
                S = new g(M,y.itemSize,y.normalized)
            }
            y.name !== void 0 && (S.name = y.name),
            y.usage !== void 0 && S.setUsage(y.usage),
            y.updateRange !== void 0 && (S.updateRange.offset = y.updateRange.offset,
            S.updateRange.count = y.updateRange.count),
            o.setAttribute(m, S)
        }
        const f = e.data.morphAttributes;
        if (f)
            for (const m in f) {
                const y = f[m]
                  , S = [];
                for (let M = 0, g = y.length; M < g; M++) {
                    const _ = y[M];
                    let w;
                    if (_.isInterleavedBufferAttribute) {
                        const T = r(e.data, _.data);
                        w = new Jo(T,_.itemSize,_.offset,_.normalized)
                    } else {
                        const T = yc(_.type, _.array);
                        w = new Ht(T,_.itemSize,_.normalized)
                    }
                    _.name !== void 0 && (w.name = _.name),
                    S.push(w)
                }
                o.morphAttributes[m] = S
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let m = 0, y = h.length; m !== y; ++m) {
                const S = h[m];
                o.addGroup(S.start, S.count, S.materialIndex)
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const m = new z;
            p.center !== void 0 && m.fromArray(p.center),
            o.boundingSphere = new ns(m,p.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class g7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? ol.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Er(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(l) {
            let f = null;
            try {
                f = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const d = f.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(f, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? ol.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new Er(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(f)
        })
          , a = this.parseTextures(e.textures, o)
          , l = this.parseMaterials(e.materials, a)
          , f = this.parseObject(e.object, s, l, a, i)
          , d = this.parseSkeletons(e.skeletons, f);
        if (this.bindSkeletons(f, d),
        t !== void 0) {
            let h = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                }
            h === !1 && t(f)
        }
        return f
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , l = this.parseObject(e.object, r, a, o, t)
          , f = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, f),
        l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new Xa().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new fu().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new AI;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(l);
                    break;
                default:
                    l.type in jA ? a = jA[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid,
                l.name !== void 0 && (a.name = l.name),
                l.userData !== void 0 && (a.userData = l.userData),
                i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new A0;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
                r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = rl.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(l) {
            return i.manager.itemStart(l),
            s.load(l, function() {
                i.manager.itemEnd(l)
            }, void 0, function() {
                i.manager.itemError(l),
                i.manager.itemEnd(l)
            })
        }
        function a(l) {
            if (typeof l == "string") {
                const f = l
                  , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
                return o(d)
            } else
                return l.data ? {
                    data: yc(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new lw(t);
            s = new cd(l),
            s.setCrossOrigin(this.crossOrigin);
            for (let f = 0, d = e.length; f < d; f++) {
                const h = e[f]
                  , p = h.url;
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, S = p.length; y < S; y++) {
                        const M = p[y]
                          , g = a(M);
                        g !== null && (g instanceof HTMLImageElement ? m.push(g) : m.push(new Ic(g.data,g.width,g.height)))
                    }
                    r[h.uuid] = new Oa(m)
                } else {
                    const m = a(h.url);
                    r[h.uuid] = new Oa(m)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else
                return o.data ? {
                    data: yc(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new cd(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o]
                  , f = l.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let h = 0, p = f.length; h < p; h++) {
                        const m = f[h]
                          , y = await s(m);
                        y !== null && (y instanceof HTMLImageElement ? d.push(y) : d.push(new Ic(y.data,y.width,y.height)))
                    }
                    i[l.uuid] = new Oa(d)
                } else {
                    const d = await s(l.url);
                    i[l.uuid] = new Oa(d)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image]
                  , f = l.data;
                let d;
                Array.isArray(f) ? (d = new Cd,
                f.length === 6 && (d.needsUpdate = !0)) : (f && f.data ? d = new Ic : d = new en,
                f && (d.needsUpdate = !0)),
                d.source = l,
                d.uuid = a.uuid,
                a.name !== void 0 && (d.name = a.name),
                a.mapping !== void 0 && (d.mapping = i(a.mapping, v7)),
                a.channel !== void 0 && (d.channel = a.channel),
                a.offset !== void 0 && d.offset.fromArray(a.offset),
                a.repeat !== void 0 && d.repeat.fromArray(a.repeat),
                a.center !== void 0 && d.center.fromArray(a.center),
                a.rotation !== void 0 && (d.rotation = a.rotation),
                a.wrap !== void 0 && (d.wrapS = i(a.wrap[0], ZA),
                d.wrapT = i(a.wrap[1], ZA)),
                a.format !== void 0 && (d.format = a.format),
                a.internalFormat !== void 0 && (d.internalFormat = a.internalFormat),
                a.type !== void 0 && (d.type = a.type),
                a.colorSpace !== void 0 && (d.colorSpace = a.colorSpace),
                a.encoding !== void 0 && (d.encoding = a.encoding),
                a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, QA)),
                a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, QA)),
                a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (d.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment),
                a.userData !== void 0 && (d.userData = a.userData),
                r[a.uuid] = d
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(p) {
            return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p),
            t[p]
        }
        function l(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const m = [];
                    for (let y = 0, S = p.length; y < S; y++) {
                        const M = p[y];
                        i[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M),
                        m.push(i[M])
                    }
                    return m
                }
                return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p),
                i[p]
            }
        }
        function f(p) {
            return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p),
            r[p]
        }
        let d, h;
        switch (e.type) {
        case "Scene":
            o = new tg,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Oe(e.background) : o.background = f(e.background)),
            e.environment !== void 0 && (o.environment = f(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new v0(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new g0(e.fog.color,e.fog.density))),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
            break;
        case "PerspectiveCamera":
            o = new Pn(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new dl(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new uw(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new E0(e.color,e.intensity);
            break;
        case "PointLight":
            o = new ud(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new MI(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new M0(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
            break;
        case "HemisphereLight":
            o = new wI(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new T0().fromJSON(e);
            break;
        case "SkinnedMesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new y0(d,h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            d = a(e.geometry),
            h = l(e.material),
            o = new zn(d,h);
            break;
        case "InstancedMesh":
            d = a(e.geometry),
            h = l(e.material);
            const p = e.count
              , m = e.instanceMatrix
              , y = e.instanceColor;
            o = new j1(d,h,p),
            o.instanceMatrix = new tu(new Float32Array(m.array),16),
            y !== void 0 && (o.instanceColor = new tu(new Float32Array(y.array),y.itemSize));
            break;
        case "LOD":
            o = new eI;
            break;
        case "Line":
            o = new Es(a(e.geometry),l(e.material));
            break;
        case "LineLoop":
            o = new Y1(a(e.geometry),l(e.material));
            break;
        case "LineSegments":
            o = new is(a(e.geometry),l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new q1(a(e.geometry),l(e.material));
            break;
        case "Sprite":
            o = new JL(l(e.material));
            break;
        case "Group":
            o = new xr;
            break;
        case "Bone":
            o = new eu;
            break;
        default:
            o = new Lt
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.up !== void 0 && o.up.fromArray(e.up),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++)
                o.add(this.parseObject(p[m], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
                const y = p[m];
                o.animations.push(s[y])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
                const y = p[m]
                  , S = o.getObjectByProperty("uuid", y.object);
                S !== void 0 && o.addLevel(S, y.distance, y.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const v7 = {
    UVMapping: c0,
    CubeReflectionMapping: Zo,
    CubeRefractionMapping: Qo,
    EquirectangularReflectionMapping: Yc,
    EquirectangularRefractionMapping: ed,
    CubeUVReflectionMapping: lu
}
  , ZA = {
    RepeatWrapping: Yn,
    ClampToEdgeWrapping: On,
    MirroredRepeatWrapping: qc
}
  , QA = {
    NearestFilter: _n,
    NearestMipmapNearestFilter: td,
    NearestMipmapLinearFilter: Pc,
    LinearFilter: dn,
    LinearMipmapNearestFilter: u0,
    LinearMipmapLinearFilter: ws
};
class RI extends Mi {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = sl.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            sl.add(e, l),
            t && t(l),
            s.manager.itemEnd(e)
        }).catch(function(l) {
            r && r(l),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }),
        s.manager.itemStart(e)
    }
}
let Gp;
class fw {
    static getContext() {
        return Gp === void 0 && (Gp = new (window.AudioContext || window.webkitAudioContext)),
        Gp
    }
    static setContext(e) {
        Gp = e
    }
}
class y7 extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new Er(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(l) {
            try {
                const f = l.slice(0);
                fw.getContext().decodeAudioData(f, function(h) {
                    t(h)
                }, a)
            } catch (f) {
                a(f)
            }
        }, i, r);
        function a(l) {
            r ? r(l) : console.error(l),
            s.manager.itemError(e)
        }
    }
}
class _7 extends T0 {
    constructor(e, t, i=1) {
        super(void 0, i),
        this.isHemisphereLightProbe = !0;
        const r = new Oe().set(e)
          , s = new Oe().set(t)
          , o = new z(r.r,r.g,r.b)
          , a = new z(s.r,s.g,s.b)
          , l = Math.sqrt(Math.PI)
          , f = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
        this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(f)
    }
}
class x7 extends T0 {
    constructor(e, t=1) {
        super(void 0, t),
        this.isAmbientLightProbe = !0;
        const i = new Oe().set(e);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const JA = new $e
  , eR = new $e
  , Sa = new $e;
class S7 {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Pn,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Pn,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            Sa.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(Ga * t.fov * .5) / t.zoom;
            let a, l;
            eR.elements[12] = -r,
            JA.elements[12] = r,
            a = -o * t.aspect + s,
            l = o * t.aspect + s,
            Sa.elements[0] = 2 * t.near / (l - a),
            Sa.elements[8] = (l + a) / (l - a),
            this.cameraL.projectionMatrix.copy(Sa),
            a = -o * t.aspect - s,
            l = o * t.aspect - s,
            Sa.elements[0] = 2 * t.near / (l - a),
            Sa.elements[8] = (l + a) / (l - a),
            this.cameraR.projectionMatrix.copy(Sa)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(eR),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(JA)
    }
}
class dw {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = tR(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = tR();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function tR() {
    return (typeof performance > "u" ? Date : performance).now()
}
const wa = new z
  , nR = new In
  , w7 = new z
  , Ma = new z;
class M7 extends Lt {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = fw.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new dw
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(wa, nR, w7),
        Ma.set(0, 0, -1).applyQuaternion(nR),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(wa.x, r),
            t.positionY.linearRampToValueAtTime(wa.y, r),
            t.positionZ.linearRampToValueAtTime(wa.z, r),
            t.forwardX.linearRampToValueAtTime(Ma.x, r),
            t.forwardY.linearRampToValueAtTime(Ma.y, r),
            t.forwardZ.linearRampToValueAtTime(Ma.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(wa.x, wa.y, wa.z),
            t.setOrientation(Ma.x, Ma.y, Ma.z, i.x, i.y, i.z)
    }
}
class CI extends Lt {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const Ea = new z
  , iR = new In
  , E7 = new z
  , Ta = new z;
class T7 extends CI {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose(Ea, iR, E7),
        Ta.set(0, 0, 1).applyQuaternion(iR);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(Ea.x, i),
            t.positionY.linearRampToValueAtTime(Ea.y, i),
            t.positionZ.linearRampToValueAtTime(Ea.z, i),
            t.orientationX.linearRampToValueAtTime(Ta.x, i),
            t.orientationY.linearRampToValueAtTime(Ta.y, i),
            t.orientationZ.linearRampToValueAtTime(Ta.z, i)
        } else
            t.setPosition(Ea.x, Ea.y, Ea.z),
            t.setOrientation(Ta.x, Ta.y, Ta.z)
    }
}
class A7 {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class bI {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a)
                i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, r, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, f = t + t; l !== f; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        In.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        In.multiplyQuaternionsFlat(e, o, e, t, e, i),
        In.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const hw = "\\[\\]\\.:\\/"
  , R7 = new RegExp("[" + hw + "]","g")
  , pw = "[^" + hw + "]"
  , C7 = "[^" + hw.replace("\\.", "") + "]"
  , b7 = /((?:WC+[\/:])*)/.source.replace("WC", pw)
  , P7 = /(WCOD+)?/.source.replace("WCOD", C7)
  , L7 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pw)
  , I7 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pw)
  , N7 = new RegExp("^" + b7 + P7 + L7 + I7 + "$")
  , D7 = ["material", "materials", "bones", "map"];
class U7 {
    constructor(e, t, i) {
        const r = i || Ct.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class Ct {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || Ct.parseTrackName(t),
        this.node = Ct.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Ct.Composite(e,t,i) : new Ct(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(R7, "")
    }
    static parseTrackName(e) {
        const t = N7.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            D7.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = i(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = Ct.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (i) {
            let f = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let d = 0; d < e.length; d++)
                    if (e[d].name === f) {
                        f = d;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (f !== void 0) {
                if (e[f] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[f]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const f = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Ct.Composite = U7;
Ct.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Ct.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Ct.prototype.GetterByBindingType = [Ct.prototype._getValue_direct, Ct.prototype._getValue_array, Ct.prototype._getValue_arrayElement, Ct.prototype._getValue_toArray];
Ct.prototype.SetterByBindingTypeAndVersioning = [[Ct.prototype._setValue_direct, Ct.prototype._setValue_direct_setNeedsUpdate, Ct.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_array, Ct.prototype._setValue_array_setNeedsUpdate, Ct.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_arrayElement, Ct.prototype._setValue_arrayElement_setNeedsUpdate, Ct.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_fromArray, Ct.prototype._setValue_fromArray_setNeedsUpdate, Ct.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class k7 {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Qi(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, l = e.length, f = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const p = arguments[d]
              , m = p.uuid;
            let y = t[m];
            if (y === void 0) {
                y = l++,
                t[m] = y,
                e.push(p);
                for (let S = 0, M = o; S !== M; ++S)
                    s[S].push(new Ct(p,i[S],r[S]))
            } else if (y < f) {
                a = e[y];
                const S = --f
                  , M = e[S];
                t[M.uuid] = y,
                e[y] = M,
                t[m] = S,
                e[S] = p;
                for (let g = 0, _ = o; g !== _; ++g) {
                    const w = s[g]
                      , T = w[S];
                    let A = w[y];
                    w[y] = T,
                    A === void 0 && (A = new Ct(p,i[g],r[g])),
                    w[S] = A
                }
            } else
                e[y] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = f
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o]
              , f = l.uuid
              , d = t[f];
            if (d !== void 0 && d >= s) {
                const h = s++
                  , p = e[h];
                t[p.uuid] = d,
                e[d] = p,
                t[f] = h,
                e[h] = l;
                for (let m = 0, y = r; m !== y; ++m) {
                    const S = i[m]
                      , M = S[h]
                      , g = S[d];
                    S[d] = M,
                    S[h] = g
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const f = arguments[a]
              , d = f.uuid
              , h = t[d];
            if (h !== void 0)
                if (delete t[d],
                h < s) {
                    const p = --s
                      , m = e[p]
                      , y = --o
                      , S = e[y];
                    t[m.uuid] = h,
                    e[h] = m,
                    t[S.uuid] = p,
                    e[p] = S,
                    e.pop();
                    for (let M = 0, g = r; M !== g; ++M) {
                        const _ = i[M]
                          , w = _[p]
                          , T = _[y];
                        _[h] = w,
                        _[p] = T,
                        _.pop()
                    }
                } else {
                    const p = --o
                      , m = e[p];
                    p > 0 && (t[m.uuid] = h),
                    e[h] = m,
                    e.pop();
                    for (let y = 0, S = r; y !== S; ++y) {
                        const M = i[y];
                        M[h] = M[p],
                        M.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , a = this._parsedPaths
          , l = this._objects
          , f = l.length
          , d = this.nCachedObjects_
          , h = new Array(f);
        r = s.length,
        i[e] = r,
        o.push(e),
        a.push(t),
        s.push(h);
        for (let p = d, m = l.length; p !== m; ++p) {
            const y = l[p];
            h[p] = new Ct(y,e,t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , l = o[a]
              , f = e[a];
            t[f] = i,
            o[i] = l,
            o.pop(),
            s[i] = s[a],
            s.pop(),
            r[i] = r[a],
            r.pop()
        }
    }
}
class PI {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: Ua,
            endingEnd: Ua
        };
        for (let f = 0; f !== o; ++f) {
            const d = s[f].createInterpolant(null);
            a[f] = d,
            d.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = CL,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , a = r / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , f = a.sampleValues;
        return l[0] = s,
        l[1] = s + i,
        f[0] = e / o,
        f[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , f = this._propertyBindings;
            switch (this.blendMode) {
            case D1:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    f[d].accumulateAdditive(a);
                break;
            case f0:
            default:
                for (let d = 0, h = l.length; d !== h; ++d)
                    l[d].evaluate(o),
                    f[d].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === bL;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === RL) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const f = e < 0;
                        this._setEndings(f, !f, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = ka,
        r.endingEnd = ka) : (e ? r.endingStart = this.zeroSlopeAtStart ? ka : Ua : r.endingStart = nd,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? ka : Ua : r.endingEnd = nd)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = i,
        this
    }
}
const O7 = new Float32Array(1);
class F7 extends so {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = i.uuid
          , f = this._bindingsByRootAndName;
        let d = f[l];
        d === void 0 && (d = {},
        f[l] = d);
        for (let h = 0; h !== s; ++h) {
            const p = r[h]
              , m = p.name;
            let y = d[m];
            if (y !== void 0)
                ++y.referenceCount,
                o[h] = y;
            else {
                if (y = o[h],
                y !== void 0) {
                    y._cacheIndex === null && (++y.referenceCount,
                    this._addInactiveBinding(y, l, m));
                    continue
                }
                const S = t && t._propertyBindings[h].binding.parsedPath;
                y = new bI(Ct.create(i, m, S),p.ValueTypeName,p.getValueSize()),
                ++y.referenceCount,
                this._addInactiveBinding(y, l, m),
                o[h] = y
            }
            a[h].resultBuffer = y.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , f = l[l.length - 1]
          , d = e._byClipCacheIndex;
        f._byClipCacheIndex = d,
        l[d] = f,
        l.pop(),
        e._byClipCacheIndex = null;
        const h = a.actionByRoot
          , p = (e._localRoot || this._root).uuid;
        delete h[p],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , a = o[r]
          , l = t[t.length - 1]
          , f = e._cacheIndex;
        l._cacheIndex = f,
        t[f] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new ow(new Float32Array(2),new Float32Array(2),1,O7),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? rl.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let f = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = f0),
        l !== void 0) {
            const h = l.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i)
                return h;
            f = l.knownActions[0],
            o === null && (o = f._clip)
        }
        if (o === null)
            return null;
        const d = new PI(this,o,t,i);
        return this._bindAction(d, f),
        this._addInactiveAction(d, a, s),
        d
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? rl.findByName(i, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let f = 0; f !== i; ++f)
            t[f]._update(r, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let f = 0; f !== l; ++f)
            a[f].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const f = o[a];
                this._deactivateAction(f);
                const d = f._cacheIndex
                  , h = t[t.length - 1];
                f._cacheIndex = null,
                f._byClipCacheIndex = null,
                h._cacheIndex = d,
                t[d] = h,
                t.pop(),
                this._removeInactiveBindingsForAction(f)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class mw {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new mw(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let z7 = 0;
class B7 extends so {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: z7++
        }),
        this.name = "",
        this.usage = id,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++)
            this.uniforms.push(t[i].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class V7 extends bd {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class H7 {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
class LI {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new Ad(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new Wa,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, i=[]) {
        return eS(e, this, i, t),
        i.sort(rR),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            eS(e[r], this, i, t);
        return i.sort(rR),
        i
    }
}
function rR(n, e) {
    return n.distance - e.distance
}
function eS(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++)
            eS(r[s], e, t, !0)
    }
}
class G7 {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(xn(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class W7 {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const sR = new be;
class X7 {
    constructor(e=new be(1 / 0,1 / 0), t=new be(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = sR.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, sR).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const oR = new z
  , Wp = new z;
class $7 {
    constructor(e=new z, t=new z) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        oR.subVectors(e, this.start),
        Wp.subVectors(this.end, this.start);
        const i = Wp.dot(Wp);
        let s = Wp.dot(oR) / i;
        return t && (s = xn(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const aR = new z;
class j7 extends Lt {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new ft
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++,
        a++) {
            const f = o / l * Math.PI * 2
              , d = a / l * Math.PI * 2;
            r.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1)
        }
        i.setAttribute("position", new je(r,3));
        const s = new ni({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new is(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        aR.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(aR),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const Mo = new z
  , Xp = new $e
  , Gy = new $e;
class Y7 extends is {
    constructor(e) {
        const t = II(e)
          , i = new ft
          , r = []
          , s = []
          , o = new Oe(0,0,1)
          , a = new Oe(0,1,0);
        for (let f = 0; f < t.length; f++) {
            const d = t[f];
            d.parent && d.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new je(r,3)),
        i.setAttribute("color", new je(s,3));
        const l = new ni({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, l),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        Gy.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (Xp.multiplyMatrices(Gy, a.matrixWorld),
            Mo.setFromMatrixPosition(Xp),
            r.setXYZ(o, Mo.x, Mo.y, Mo.z),
            Xp.multiplyMatrices(Gy, a.parent.matrixWorld),
            Mo.setFromMatrixPosition(Xp),
            r.setXYZ(o + 1, Mo.x, Mo.y, Mo.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function II(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, II(n.children[t]));
    return e
}
class q7 extends zn {
    constructor(e, t, i) {
        const r = new pu(t,4,2)
          , s = new Ki({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const K7 = new z
  , lR = new Oe
  , cR = new Oe;
class Z7 extends Lt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new hu(t);
        r.rotateY(Math.PI * .5),
        this.material = new Ki({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Ht(o,3)),
        this.add(new zn(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            lR.copy(this.light.color),
            cR.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? lR : cR;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(K7.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class Q7 extends is {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Oe(i),
        r = new Oe(r);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , l = []
          , f = [];
        for (let p = 0, m = 0, y = -a; p <= t; p++,
        y += o) {
            l.push(-a, 0, y, a, 0, y),
            l.push(y, 0, -a, y, 0, a);
            const S = p === s ? i : r;
            S.toArray(f, m),
            m += 3,
            S.toArray(f, m),
            m += 3,
            S.toArray(f, m),
            m += 3,
            S.toArray(f, m),
            m += 3
        }
        const d = new ft;
        d.setAttribute("position", new je(l,3)),
        d.setAttribute("color", new je(f,3));
        const h = new ni({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, h),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class J7 extends is {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Oe(s),
        o = new Oe(o);
        const a = []
          , l = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const p = h / t * (Math.PI * 2)
                  , m = Math.sin(p) * e
                  , y = Math.cos(p) * e;
                a.push(0, 0, 0),
                a.push(m, 0, y);
                const S = h & 1 ? s : o;
                l.push(S.r, S.g, S.b),
                l.push(S.r, S.g, S.b)
            }
        for (let h = 0; h < i; h++) {
            const p = h & 1 ? s : o
              , m = e - e / i * h;
            for (let y = 0; y < r; y++) {
                let S = y / r * (Math.PI * 2)
                  , M = Math.sin(S) * m
                  , g = Math.cos(S) * m;
                a.push(M, 0, g),
                l.push(p.r, p.g, p.b),
                S = (y + 1) / r * (Math.PI * 2),
                M = Math.sin(S) * m,
                g = Math.cos(S) * m,
                a.push(M, 0, g),
                l.push(p.r, p.g, p.b)
            }
        }
        const f = new ft;
        f.setAttribute("position", new je(a,3)),
        f.setAttribute("color", new je(l,3));
        const d = new ni({
            vertexColors: !0,
            toneMapped: !1
        });
        super(f, d),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const uR = new z
  , $p = new z
  , fR = new z;
class eX extends Lt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new ft;
        r.setAttribute("position", new je([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new ni({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Es(r,s),
        this.add(this.lightPlane),
        r = new ft,
        r.setAttribute("position", new je([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Es(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        uR.setFromMatrixPosition(this.light.matrixWorld),
        $p.setFromMatrixPosition(this.light.target.matrixWorld),
        fR.subVectors($p, uR),
        this.lightPlane.lookAt($p),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt($p),
        this.targetLine.scale.z = fR.length()
    }
}
const jp = new z
  , vn = new Rd;
class tX extends is {
    constructor(e) {
        const t = new ft
          , i = new ni({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(y, S) {
            l(y),
            l(S)
        }
        function l(y) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[y] === void 0 && (o[y] = []),
            o[y].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new je(r,3)),
        t.setAttribute("color", new je(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const f = new Oe(16755200)
          , d = new Oe(16711680)
          , h = new Oe(43775)
          , p = new Oe(16777215)
          , m = new Oe(3355443);
        this.setColors(f, d, h, p, m)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        vn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        wn("c", t, e, vn, 0, 0, -1),
        wn("t", t, e, vn, 0, 0, 1),
        wn("n1", t, e, vn, -i, -r, -1),
        wn("n2", t, e, vn, i, -r, -1),
        wn("n3", t, e, vn, -i, r, -1),
        wn("n4", t, e, vn, i, r, -1),
        wn("f1", t, e, vn, -i, -r, 1),
        wn("f2", t, e, vn, i, -r, 1),
        wn("f3", t, e, vn, -i, r, 1),
        wn("f4", t, e, vn, i, r, 1),
        wn("u1", t, e, vn, i * .7, r * 1.1, -1),
        wn("u2", t, e, vn, -i * .7, r * 1.1, -1),
        wn("u3", t, e, vn, 0, r * 2, -1),
        wn("cf1", t, e, vn, -i, 0, 1),
        wn("cf2", t, e, vn, i, 0, 1),
        wn("cf3", t, e, vn, 0, -r, 1),
        wn("cf4", t, e, vn, 0, r, 1),
        wn("cn1", t, e, vn, -i, 0, -1),
        wn("cn2", t, e, vn, i, 0, -1),
        wn("cn3", t, e, vn, 0, -r, -1),
        wn("cn4", t, e, vn, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function wn(n, e, t, i, r, s, o) {
    jp.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let f = 0, d = a.length; f < d; f++)
            l.setXYZ(a[f], jp.x, jp.y, jp.z)
    }
}
const Yp = new ts;
class nX extends is {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new ft;
        s.setIndex(new Ht(i,1)),
        s.setAttribute("position", new Ht(r,3)),
        super(s, new ni({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && Yp.setFromObject(this.object),
        Yp.isEmpty())
            return;
        const t = Yp.min
          , i = Yp.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class iX extends is {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new ft;
        s.setIndex(new Ht(i,1)),
        s.setAttribute("position", new je(r,3)),
        super(s, new ni({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class rX extends Es {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new ft;
        o.setAttribute("position", new je(s,3)),
        o.computeBoundingSphere(),
        super(o, new ni({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , l = new ft;
        l.setAttribute("position", new je(a,3)),
        l.computeBoundingSphere(),
        this.add(new zn(l,new Ki({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const dR = new z;
let qp, Wy;
class sX extends Lt {
    constructor(e=new z(0,0,1), t=new z(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        qp === void 0 && (qp = new ft,
        qp.setAttribute("position", new je([0, 0, 0, 0, 1, 0],3)),
        Wy = new hl(0,.5,1,5,1),
        Wy.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Es(qp,new ni({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new zn(Wy,new Ki({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            dR.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(dR, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class oX extends is {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new ft;
        r.setAttribute("position", new je(t,3)),
        r.setAttribute("color", new je(i,3));
        const s = new ni({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Oe
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class aX {
    constructor() {
        this.type = "ShapePath",
        this.color = new Oe,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new sd,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(g) {
            const _ = [];
            for (let w = 0, T = g.length; w < T; w++) {
                const A = g[w]
                  , C = new Xa;
                C.curves = A.curves,
                _.push(C)
            }
            return _
        }
        function i(g, _) {
            const w = _.length;
            let T = !1;
            for (let A = w - 1, C = 0; C < w; A = C++) {
                let P = _[A]
                  , N = _[C]
                  , b = N.x - P.x
                  , L = N.y - P.y;
                if (Math.abs(L) > Number.EPSILON) {
                    if (L < 0 && (P = _[C],
                    b = -b,
                    N = _[A],
                    L = -L),
                    g.y < P.y || g.y > N.y)
                        continue;
                    if (g.y === P.y) {
                        if (g.x === P.x)
                            return !0
                    } else {
                        const Y = L * (g.x - P.x) - b * (g.y - P.y);
                        if (Y === 0)
                            return !0;
                        if (Y < 0)
                            continue;
                        T = !T
                    }
                } else {
                    if (g.y !== P.y)
                        continue;
                    if (N.x <= g.x && g.x <= P.x || P.x <= g.x && g.x <= N.x)
                        return !0
                }
            }
            return T
        }
        const r = Ss.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const f = [];
        if (s.length === 1)
            return a = s[0],
            l = new Xa,
            l.curves = a.curves,
            f.push(l),
            f;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = []
          , p = [];
        let m = [], y = 0, S;
        p[y] = void 0,
        m[y] = [];
        for (let g = 0, _ = s.length; g < _; g++)
            a = s[g],
            S = a.getPoints(),
            o = r(S),
            o = e ? !o : o,
            o ? (!d && p[y] && y++,
            p[y] = {
                s: new Xa,
                p: S
            },
            p[y].s.curves = a.curves,
            d && y++,
            m[y] = []) : m[y].push({
                h: a,
                p: S[0]
            });
        if (!p[0])
            return t(s);
        if (p.length > 1) {
            let g = !1
              , _ = 0;
            for (let w = 0, T = p.length; w < T; w++)
                h[w] = [];
            for (let w = 0, T = p.length; w < T; w++) {
                const A = m[w];
                for (let C = 0; C < A.length; C++) {
                    const P = A[C];
                    let N = !0;
                    for (let b = 0; b < p.length; b++)
                        i(P.p, p[b].p) && (w !== b && _++,
                        N ? (N = !1,
                        h[b].push(P)) : g = !0);
                    N && h[w].push(P)
                }
            }
            _ > 0 && g === !1 && (m = h)
        }
        let M;
        for (let g = 0, _ = p.length; g < _; g++) {
            l = p[g].s,
            f.push(l),
            M = m[g];
            for (let w = 0, T = M.length; w < T; w++)
                l.holes.push(M[w].h)
        }
        return f
    }
}
class lX extends oa {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
        super(e, t, i, r, s, o)
    }
}
class cX extends Pd {
    constructor(e, t, i, r) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
        super(e, t, i, r)
    }
}
class uX extends Ld {
    constructor(e, t, i, r) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
        super(e, t, i, r)
    }
}
class fX extends Id {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class dX extends hl {
    constructor(e, t, i, r, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
        super(e, t, i, r, s, o, a, l)
    }
}
class hX extends Nd {
    constructor(e, t) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
        super(e, t)
    }
}
class pX extends Dd {
    constructor(e, t) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
        super(e, t)
    }
}
class mX extends Ud {
    constructor(e, t) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
        super(e, t)
    }
}
class gX extends du {
    constructor(e, t, i, r) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
        super(e, t, i, r)
    }
}
class vX extends hu {
    constructor(e, t) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
        super(e, t)
    }
}
class yX extends cu {
    constructor(e, t, i, r) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
        super(e, t, i, r)
    }
}
class _X extends oo {
    constructor(e, t, i, r) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
        super(e, t, i, r)
    }
}
class xX extends kd {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
        super(e, t, i, r, s, o)
    }
}
class SX extends Od {
    constructor(e, t) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
        super(e, t)
    }
}
class wX extends pu {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
        super(e, t, i, r, s, o, a)
    }
}
class MX extends Fd {
    constructor(e, t) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
        super(e, t)
    }
}
class EX extends zd {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
        super(e, t, i, r, s)
    }
}
class TX extends Bd {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
        super(e, t, i, r, s, o)
    }
}
class AX extends Vd {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
        super(e, t, i, r, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: a0
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = a0);
const RX = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: I1,
    AddEquation: Pa,
    AddOperation: aL,
    AdditiveAnimationBlendMode: D1,
    AdditiveBlending: yx,
    AlphaFormat: vL,
    AlwaysDepth: eL,
    AlwaysStencilFunc: DL,
    AmbientLight: uw,
    AmbientLightProbe: x7,
    AnimationAction: PI,
    AnimationClip: rl,
    AnimationLoader: c7,
    AnimationMixer: F7,
    AnimationObjectGroup: k7,
    AnimationUtils: s7,
    ArcCurve: tI,
    ArrayCamera: qL,
    ArrowHelper: sX,
    Audio: CI,
    AudioAnalyser: A7,
    AudioContext: fw,
    AudioListener: M7,
    AudioLoader: y7,
    AxesHelper: oX,
    BackSide: hi,
    BasicDepthPacking: LL,
    BasicShadowMap: BP,
    Bone: eu,
    BooleanKeyframeTrack: pl,
    Box2: X7,
    Box3: ts,
    Box3Helper: iX,
    BoxBufferGeometry: lX,
    BoxGeometry: oa,
    BoxHelper: nX,
    BufferAttribute: Ht,
    BufferGeometry: ft,
    BufferGeometryLoader: AI,
    ByteType: dL,
    Cache: sl,
    Camera: Rd,
    CameraHelper: tX,
    CanvasTexture: b9,
    CapsuleBufferGeometry: cX,
    CapsuleGeometry: Pd,
    CatmullRomCurve3: nI,
    CineonToneMapping: uL,
    CircleBufferGeometry: uX,
    CircleGeometry: Ld,
    ClampToEdgeWrapping: On,
    Clock: dw,
    Color: Oe,
    ColorKeyframeTrack: aw,
    ColorManagement: dr,
    CompressedArrayTexture: C9,
    CompressedTexture: K1,
    CompressedTextureLoader: u7,
    ConeBufferGeometry: fX,
    ConeGeometry: Id,
    CubeCamera: VL,
    CubeReflectionMapping: Zo,
    CubeRefractionMapping: Qo,
    CubeTexture: Cd,
    CubeTextureLoader: f7,
    CubeUVReflectionMapping: lu,
    CubicBezierCurve: Q1,
    CubicBezierCurve3: iI,
    CubicInterpolant: yI,
    CullFaceBack: vx,
    CullFaceFront: zP,
    CullFaceFrontBack: PH,
    CullFaceNone: FP,
    Curve: Ar,
    CurvePath: sI,
    CustomBlending: VP,
    CustomToneMapping: fL,
    CylinderBufferGeometry: dX,
    CylinderGeometry: hl,
    Cylindrical: W7,
    Data3DTexture: B1,
    DataArrayTexture: d0,
    DataTexture: Ic,
    DataTextureLoader: d7,
    DataUtils: F5,
    DecrementStencilOp: zH,
    DecrementWrapStencilOp: VH,
    DefaultLoadingManager: SI,
    DepthFormat: $o,
    DepthStencilFormat: Ja,
    DepthTexture: KL,
    DirectionalLight: E0,
    DirectionalLightHelper: eX,
    DiscreteInterpolant: _I,
    DisplayP3ColorSpace: O1,
    DodecahedronBufferGeometry: hX,
    DodecahedronGeometry: Nd,
    DoubleSide: $r,
    DstAlphaFactor: YP,
    DstColorFactor: KP,
    DynamicCopyUsage: n5,
    DynamicDrawUsage: KH,
    DynamicReadUsage: JH,
    EdgesGeometry: oI,
    EllipseCurve: x0,
    EqualDepth: nL,
    EqualStencilFunc: XH,
    EquirectangularReflectionMapping: Yc,
    EquirectangularRefractionMapping: ed,
    Euler: qi,
    EventDispatcher: so,
    ExtrudeBufferGeometry: pX,
    ExtrudeGeometry: Dd,
    FileLoader: Er,
    Float16BufferAttribute: W5,
    Float32BufferAttribute: je,
    Float64BufferAttribute: X5,
    FloatType: Ys,
    Fog: v0,
    FogExp2: g0,
    FramebufferTexture: R9,
    FrontSide: Zr,
    Frustum: p0,
    GLBufferAttribute: H7,
    GLSL1: r5,
    GLSL3: $x,
    GreaterDepth: rL,
    GreaterEqualDepth: iL,
    GreaterEqualStencilFunc: qH,
    GreaterStencilFunc: jH,
    GridHelper: Q7,
    Group: xr,
    HalfFloatType: Kc,
    HemisphereLight: wI,
    HemisphereLightHelper: Z7,
    HemisphereLightProbe: _7,
    IcosahedronBufferGeometry: mX,
    IcosahedronGeometry: Ud,
    ImageBitmapLoader: RI,
    ImageLoader: cd,
    ImageUtils: z1,
    IncrementStencilOp: FH,
    IncrementWrapStencilOp: BH,
    InstancedBufferAttribute: tu,
    InstancedBufferGeometry: TI,
    InstancedInterleavedBuffer: V7,
    InstancedMesh: j1,
    Int16BufferAttribute: H5,
    Int32BufferAttribute: G5,
    Int8BufferAttribute: z5,
    IntType: pL,
    InterleavedBuffer: bd,
    InterleavedBufferAttribute: Jo,
    Interpolant: mu,
    InterpolateDiscrete: Zc,
    InterpolateLinear: el,
    InterpolateSmooth: _m,
    InvertStencilOp: HH,
    KeepStencilOp: xm,
    KeyframeTrack: rs,
    LOD: eI,
    LatheBufferGeometry: gX,
    LatheGeometry: du,
    Layers: Wa,
    LessDepth: tL,
    LessEqualDepth: Qm,
    LessEqualStencilFunc: $H,
    LessStencilFunc: WH,
    Light: aa,
    LightProbe: T0,
    Line: Es,
    Line3: $7,
    LineBasicMaterial: ni,
    LineCurve: S0,
    LineCurve3: rI,
    LineDashedMaterial: gI,
    LineLoop: Y1,
    LineSegments: is,
    LinearEncoding: k1,
    LinearFilter: dn,
    LinearInterpolant: ow,
    LinearMipMapLinearFilter: UH,
    LinearMipMapNearestFilter: DH,
    LinearMipmapLinearFilter: ws,
    LinearMipmapNearestFilter: u0,
    LinearSRGBColorSpace: Qr,
    LinearToneMapping: lL,
    Loader: Mi,
    LoaderUtils: ol,
    LoadingManager: lw,
    LoopOnce: RL,
    LoopPingPong: bL,
    LoopRepeat: CL,
    LuminanceAlphaFormat: _L,
    LuminanceFormat: yL,
    MOUSE: CH,
    Material: Nn,
    MaterialLoader: A0,
    MathUtils: vr,
    Matrix3: Rt,
    Matrix4: $e,
    MaxEquation: wx,
    Mesh: zn,
    MeshBasicMaterial: Ki,
    MeshDepthMaterial: G1,
    MeshDistanceMaterial: W1,
    MeshLambertMaterial: iw,
    MeshMatcapMaterial: mI,
    MeshNormalMaterial: pI,
    MeshPhongMaterial: Df,
    MeshPhysicalMaterial: ao,
    MeshStandardMaterial: Hd,
    MeshToonMaterial: hI,
    MinEquation: Sx,
    MirroredRepeatWrapping: qc,
    MixOperation: oL,
    MultiplyBlending: xx,
    MultiplyOperation: Td,
    NearestFilter: _n,
    NearestMipMapLinearFilter: NH,
    NearestMipMapNearestFilter: IH,
    NearestMipmapLinearFilter: Pc,
    NearestMipmapNearestFilter: td,
    NeverDepth: JP,
    NeverStencilFunc: GH,
    NoBlending: Ks,
    NoColorSpace: Yo,
    NoToneMapping: qr,
    NormalAnimationBlendMode: f0,
    NormalBlending: Va,
    NotEqualDepth: sL,
    NotEqualStencilFunc: YH,
    NumberKeyframeTrack: nl,
    Object3D: Lt,
    ObjectLoader: g7,
    ObjectSpaceNormalMap: NL,
    OctahedronBufferGeometry: vX,
    OctahedronGeometry: hu,
    OneFactor: XP,
    OneMinusDstAlphaFactor: qP,
    OneMinusDstColorFactor: ZP,
    OneMinusSrcAlphaFactor: L1,
    OneMinusSrcColorFactor: jP,
    OrthographicCamera: dl,
    PCFShadowMap: l0,
    PCFSoftShadowMap: bc,
    PMREMGenerator: Yx,
    Path: sd,
    PerspectiveCamera: Pn,
    Plane: bo,
    PlaneBufferGeometry: yX,
    PlaneGeometry: cu,
    PlaneHelper: rX,
    PointLight: ud,
    PointLightHelper: q7,
    Points: q1,
    PointsMaterial: _0,
    PolarGridHelper: J7,
    PolyhedronBufferGeometry: _X,
    PolyhedronGeometry: oo,
    PositionalAudio: T7,
    PropertyBinding: Ct,
    PropertyMixer: bI,
    QuadraticBezierCurve: J1,
    QuadraticBezierCurve3: ew,
    Quaternion: In,
    QuaternionKeyframeTrack: no,
    QuaternionLinearInterpolant: xI,
    RED_GREEN_RGTC2_Format: Wx,
    RED_RGTC1_Format: AL,
    REVISION: a0,
    RGBADepthPacking: IL,
    RGBAFormat: Ii,
    RGBAIntegerFormat: EL,
    RGBA_ASTC_10x10_Format: Bx,
    RGBA_ASTC_10x5_Format: Ox,
    RGBA_ASTC_10x6_Format: Fx,
    RGBA_ASTC_10x8_Format: zx,
    RGBA_ASTC_12x10_Format: Vx,
    RGBA_ASTC_12x12_Format: Hx,
    RGBA_ASTC_4x4_Format: bx,
    RGBA_ASTC_5x4_Format: Px,
    RGBA_ASTC_5x5_Format: Lx,
    RGBA_ASTC_6x5_Format: Ix,
    RGBA_ASTC_6x6_Format: Nx,
    RGBA_ASTC_8x5_Format: Dx,
    RGBA_ASTC_8x6_Format: Ux,
    RGBA_ASTC_8x8_Format: kx,
    RGBA_BPTC_Format: ym,
    RGBA_ETC2_EAC_Format: Cx,
    RGBA_PVRTC_2BPPV1_Format: Ax,
    RGBA_PVRTC_4BPPV1_Format: Tx,
    RGBA_S3TC_DXT1_Format: mm,
    RGBA_S3TC_DXT3_Format: gm,
    RGBA_S3TC_DXT5_Format: vm,
    RGB_ETC1_Format: TL,
    RGB_ETC2_Format: Rx,
    RGB_PVRTC_2BPPV1_Format: Ex,
    RGB_PVRTC_4BPPV1_Format: Mx,
    RGB_S3TC_DXT1_Format: pm,
    RGFormat: wL,
    RGIntegerFormat: ML,
    RawShaderMaterial: dI,
    Ray: Ad,
    Raycaster: LI,
    RectAreaLight: MI,
    RedFormat: xL,
    RedIntegerFormat: SL,
    ReinhardToneMapping: cL,
    RepeatWrapping: Yn,
    ReplaceStencilOp: OH,
    ReverseSubtractEquation: GP,
    RingBufferGeometry: xX,
    RingGeometry: kd,
    SIGNED_RED_GREEN_RGTC2_Format: Xx,
    SIGNED_RED_RGTC1_Format: Gx,
    SRGBColorSpace: lt,
    Scene: tg,
    ShaderChunk: _t,
    ShaderLib: Xr,
    ShaderMaterial: Ms,
    ShadowMaterial: fI,
    Shape: Xa,
    ShapeBufferGeometry: SX,
    ShapeGeometry: Od,
    ShapePath: aX,
    ShapeUtils: Ss,
    ShortType: hL,
    Skeleton: fu,
    SkeletonHelper: Y7,
    SkinnedMesh: y0,
    Source: Oa,
    Sphere: ns,
    SphereBufferGeometry: wX,
    SphereGeometry: pu,
    Spherical: G7,
    SphericalHarmonics3: EI,
    SplineCurve: tw,
    SpotLight: M0,
    SpotLightHelper: j7,
    Sprite: JL,
    SpriteMaterial: $1,
    SrcAlphaFactor: P1,
    SrcAlphaSaturateFactor: QP,
    SrcColorFactor: $P,
    StaticCopyUsage: t5,
    StaticDrawUsage: id,
    StaticReadUsage: QH,
    StereoCamera: S7,
    StreamCopyUsage: i5,
    StreamDrawUsage: ZH,
    StreamReadUsage: e5,
    StringKeyframeTrack: ml,
    SubtractEquation: HP,
    SubtractiveBlending: _x,
    TOUCH: bH,
    TangentSpaceNormalMap: sa,
    TetrahedronBufferGeometry: MX,
    TetrahedronGeometry: Fd,
    Texture: en,
    TextureLoader: gl,
    TorusBufferGeometry: EX,
    TorusGeometry: zd,
    TorusKnotBufferGeometry: TX,
    TorusKnotGeometry: Bd,
    Triangle: Li,
    TriangleFanDrawMode: Jm,
    TriangleStripDrawMode: U1,
    TrianglesDrawMode: PL,
    TubeBufferGeometry: AX,
    TubeGeometry: Vd,
    TwoPassDoubleSide: LH,
    UVMapping: c0,
    Uint16BufferAttribute: h0,
    Uint32BufferAttribute: V1,
    Uint8BufferAttribute: B5,
    Uint8ClampedBufferAttribute: V5,
    Uniform: mw,
    UniformsGroup: B7,
    UniformsLib: ze,
    UniformsUtils: BL,
    UnsignedByteType: to,
    UnsignedInt248Type: Ha,
    UnsignedIntType: Uo,
    UnsignedShort4444Type: mL,
    UnsignedShort5551Type: gL,
    UnsignedShortType: N1,
    VSMShadowMap: Hr,
    Vector2: be,
    Vector3: z,
    Vector4: Ut,
    VectorKeyframeTrack: il,
    VideoTexture: A9,
    WebGL1Renderer: ZL,
    WebGL3DRenderTarget: R5,
    WebGLArrayRenderTarget: A5,
    WebGLCubeRenderTarget: HL,
    WebGLMultipleRenderTargets: C5,
    WebGLRenderTarget: Jr,
    WebGLRenderer: X1,
    WebGLUtils: YL,
    WireframeGeometry: uI,
    WrapAroundEnding: nd,
    ZeroCurvatureEnding: Ua,
    ZeroFactor: WP,
    ZeroSlopeEnding: ka,
    ZeroStencilOp: kH,
    _SRGBAFormat: eg,
    sRGBEncoding: jo
}, Symbol.toStringTag, {
    value: "Module"
}));
var NI = {
    exports: {}
}
  , vl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
vl.ConcurrentRoot = 1;
vl.ContinuousEventPriority = 4;
vl.DefaultEventPriority = 16;
vl.DiscreteEventPriority = 1;
vl.IdleEventPriority = 536870912;
vl.LegacyRoot = 0;
NI.exports = vl;
var Sc = NI.exports;
function CX(n) {
    let e;
    const t = new Set
      , i = (f,d)=>{
        const h = typeof f == "function" ? f(e) : f;
        if (h !== e) {
            const p = e;
            e = d ? h : Object.assign({}, e, h),
            t.forEach(m=>m(e, p))
        }
    }
      , r = ()=>e
      , s = (f,d=r,h=Object.is)=>{
        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
        let p = d(e);
        function m() {
            const y = d(e);
            if (!h(p, y)) {
                const S = p;
                f(p = y, S)
            }
        }
        return t.add(m),
        ()=>t.delete(m)
    }
      , l = {
        setState: i,
        getState: r,
        subscribe: (f,d,h)=>d || h ? s(f, d, h) : (t.add(f),
        ()=>t.delete(f)),
        destroy: ()=>t.clear()
    };
    return e = n(i, r, l),
    l
}
const bX = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent)
  , hR = bX ? ke.useEffect : ke.useLayoutEffect;
function PX(n) {
    const e = typeof n == "function" ? CX(n) : n
      , t = (i=e.getState,r=Object.is)=>{
        const [,s] = ke.useReducer(M=>M + 1, 0)
          , o = e.getState()
          , a = ke.useRef(o)
          , l = ke.useRef(i)
          , f = ke.useRef(r)
          , d = ke.useRef(!1)
          , h = ke.useRef();
        h.current === void 0 && (h.current = i(o));
        let p, m = !1;
        (a.current !== o || l.current !== i || f.current !== r || d.current) && (p = i(o),
        m = !r(h.current, p)),
        hR(()=>{
            m && (h.current = p),
            a.current = o,
            l.current = i,
            f.current = r,
            d.current = !1
        }
        );
        const y = ke.useRef(o);
        hR(()=>{
            const M = ()=>{
                try {
                    const _ = e.getState()
                      , w = l.current(_);
                    f.current(h.current, w) || (a.current = _,
                    h.current = w,
                    s())
                } catch {
                    d.current = !0,
                    s()
                }
            }
              , g = e.subscribe(M);
            return e.getState() !== y.current && M(),
            g
        }
        , []);
        const S = m ? p : h.current;
        return ke.useDebugValue(S),
        S
    }
    ;
    return Object.assign(t, e),
    t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }
    ,
    t
}
var DI = {
    exports: {}
}
  , Xy = {
    exports: {}
}
  , $y = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pR;
function LX() {
    return pR || (pR = 1,
    function(n) {
        function e(D, j) {
            var X = D.length;
            D.push(j);
            e: for (; 0 < X; ) {
                var ue = X - 1 >>> 1
                  , I = D[ue];
                if (0 < r(I, j))
                    D[ue] = j,
                    D[X] = I,
                    X = ue;
                else
                    break e
            }
        }
        function t(D) {
            return D.length === 0 ? null : D[0]
        }
        function i(D) {
            if (D.length === 0)
                return null;
            var j = D[0]
              , X = D.pop();
            if (X !== j) {
                D[0] = X;
                e: for (var ue = 0, I = D.length, U = I >>> 1; ue < U; ) {
                    var O = 2 * (ue + 1) - 1
                      , J = D[O]
                      , F = O + 1
                      , B = D[F];
                    if (0 > r(J, X))
                        F < I && 0 > r(B, J) ? (D[ue] = B,
                        D[F] = X,
                        ue = F) : (D[ue] = J,
                        D[O] = X,
                        ue = O);
                    else if (F < I && 0 > r(B, X))
                        D[ue] = B,
                        D[F] = X,
                        ue = F;
                    else
                        break e
                }
            }
            return j
        }
        function r(D, j) {
            var X = D.sortIndex - j.sortIndex;
            return X !== 0 ? X : D.id - j.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var s = performance;
            n.unstable_now = function() {
                return s.now()
            }
        } else {
            var o = Date
              , a = o.now();
            n.unstable_now = function() {
                return o.now() - a
            }
        }
        var l = []
          , f = []
          , d = 1
          , h = null
          , p = 3
          , m = !1
          , y = !1
          , S = !1
          , M = typeof setTimeout == "function" ? setTimeout : null
          , g = typeof clearTimeout == "function" ? clearTimeout : null
          , _ = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function w(D) {
            for (var j = t(f); j !== null; ) {
                if (j.callback === null)
                    i(f);
                else if (j.startTime <= D)
                    i(f),
                    j.sortIndex = j.expirationTime,
                    e(l, j);
                else
                    break;
                j = t(f)
            }
        }
        function T(D) {
            if (S = !1,
            w(D),
            !y)
                if (t(l) !== null)
                    y = !0,
                    fe(A);
                else {
                    var j = t(f);
                    j !== null && le(T, j.startTime - D)
                }
        }
        function A(D, j) {
            y = !1,
            S && (S = !1,
            g(N),
            N = -1),
            m = !0;
            var X = p;
            try {
                for (w(j),
                h = t(l); h !== null && (!(h.expirationTime > j) || D && !Y()); ) {
                    var ue = h.callback;
                    if (typeof ue == "function") {
                        h.callback = null,
                        p = h.priorityLevel;
                        var I = ue(h.expirationTime <= j);
                        j = n.unstable_now(),
                        typeof I == "function" ? h.callback = I : h === t(l) && i(l),
                        w(j)
                    } else
                        i(l);
                    h = t(l)
                }
                if (h !== null)
                    var U = !0;
                else {
                    var O = t(f);
                    O !== null && le(T, O.startTime - j),
                    U = !1
                }
                return U
            } finally {
                h = null,
                p = X,
                m = !1
            }
        }
        var C = !1
          , P = null
          , N = -1
          , b = 5
          , L = -1;
        function Y() {
            return !(n.unstable_now() - L < b)
        }
        function Z() {
            if (P !== null) {
                var D = n.unstable_now();
                L = D;
                var j = !0;
                try {
                    j = P(!0, D)
                } finally {
                    j ? $() : (C = !1,
                    P = null)
                }
            } else
                C = !1
        }
        var $;
        if (typeof _ == "function")
            $ = function() {
                _(Z)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var Q = new MessageChannel
              , ie = Q.port2;
            Q.port1.onmessage = Z,
            $ = function() {
                ie.postMessage(null)
            }
        } else
            $ = function() {
                M(Z, 0)
            }
            ;
        function fe(D) {
            P = D,
            C || (C = !0,
            $())
        }
        function le(D, j) {
            N = M(function() {
                D(n.unstable_now())
            }, j)
        }
        n.unstable_IdlePriority = 5,
        n.unstable_ImmediatePriority = 1,
        n.unstable_LowPriority = 4,
        n.unstable_NormalPriority = 3,
        n.unstable_Profiling = null,
        n.unstable_UserBlockingPriority = 2,
        n.unstable_cancelCallback = function(D) {
            D.callback = null
        }
        ,
        n.unstable_continueExecution = function() {
            y || m || (y = !0,
            fe(A))
        }
        ,
        n.unstable_forceFrameRate = function(D) {
            0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < D ? Math.floor(1e3 / D) : 5
        }
        ,
        n.unstable_getCurrentPriorityLevel = function() {
            return p
        }
        ,
        n.unstable_getFirstCallbackNode = function() {
            return t(l)
        }
        ,
        n.unstable_next = function(D) {
            switch (p) {
            case 1:
            case 2:
            case 3:
                var j = 3;
                break;
            default:
                j = p
            }
            var X = p;
            p = j;
            try {
                return D()
            } finally {
                p = X
            }
        }
        ,
        n.unstable_pauseExecution = function() {}
        ,
        n.unstable_requestPaint = function() {}
        ,
        n.unstable_runWithPriority = function(D, j) {
            switch (D) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                D = 3
            }
            var X = p;
            p = D;
            try {
                return j()
            } finally {
                p = X
            }
        }
        ,
        n.unstable_scheduleCallback = function(D, j, X) {
            var ue = n.unstable_now();
            switch (typeof X == "object" && X !== null ? (X = X.delay,
            X = typeof X == "number" && 0 < X ? ue + X : ue) : X = ue,
            D) {
            case 1:
                var I = -1;
                break;
            case 2:
                I = 250;
                break;
            case 5:
                I = 1073741823;
                break;
            case 4:
                I = 1e4;
                break;
            default:
                I = 5e3
            }
            return I = X + I,
            D = {
                id: d++,
                callback: j,
                priorityLevel: D,
                startTime: X,
                expirationTime: I,
                sortIndex: -1
            },
            X > ue ? (D.sortIndex = X,
            e(f, D),
            t(l) === null && D === t(f) && (S ? (g(N),
            N = -1) : S = !0,
            le(T, X - ue))) : (D.sortIndex = I,
            e(l, D),
            y || m || (y = !0,
            fe(A))),
            D
        }
        ,
        n.unstable_shouldYield = Y,
        n.unstable_wrapCallback = function(D) {
            var j = p;
            return function() {
                var X = p;
                p = j;
                try {
                    return D.apply(this, arguments)
                } finally {
                    p = X
                }
            }
        }
    }($y)),
    $y
}
var mR;
function IX() {
    return mR || (mR = 1,
    Xy.exports = LX()),
    Xy.exports
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NX = function(e) {
    var t = {}
      , i = ke
      , r = IX()
      , s = Object.assign;
    function o(c) {
        for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, v = 1; v < arguments.length; v++)
            u += "&args[]=" + encodeURIComponent(arguments[v]);
        return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , l = Symbol.for("react.element")
      , f = Symbol.for("react.portal")
      , d = Symbol.for("react.fragment")
      , h = Symbol.for("react.strict_mode")
      , p = Symbol.for("react.profiler")
      , m = Symbol.for("react.provider")
      , y = Symbol.for("react.context")
      , S = Symbol.for("react.forward_ref")
      , M = Symbol.for("react.suspense")
      , g = Symbol.for("react.suspense_list")
      , _ = Symbol.for("react.memo")
      , w = Symbol.for("react.lazy")
      , T = Symbol.for("react.offscreen")
      , A = Symbol.iterator;
    function C(c) {
        return c === null || typeof c != "object" ? null : (c = A && c[A] || c["@@iterator"],
        typeof c == "function" ? c : null)
    }
    function P(c) {
        if (c == null)
            return null;
        if (typeof c == "function")
            return c.displayName || c.name || null;
        if (typeof c == "string")
            return c;
        switch (c) {
        case d:
            return "Fragment";
        case f:
            return "Portal";
        case p:
            return "Profiler";
        case h:
            return "StrictMode";
        case M:
            return "Suspense";
        case g:
            return "SuspenseList"
        }
        if (typeof c == "object")
            switch (c.$$typeof) {
            case y:
                return (c.displayName || "Context") + ".Consumer";
            case m:
                return (c._context.displayName || "Context") + ".Provider";
            case S:
                var u = c.render;
                return c = c.displayName,
                c || (c = u.displayName || u.name || "",
                c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"),
                c;
            case _:
                return u = c.displayName || null,
                u !== null ? u : P(c.type) || "Memo";
            case w:
                u = c._payload,
                c = c._init;
                try {
                    return P(c(u))
                } catch {}
            }
        return null
    }
    function N(c) {
        var u = c.type;
        switch (c.tag) {
        case 24:
            return "Cache";
        case 9:
            return (u.displayName || "Context") + ".Consumer";
        case 10:
            return (u._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return c = u.render,
            c = c.displayName || c.name || "",
            u.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return u;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return P(u);
        case 8:
            return u === h ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof u == "function")
                return u.displayName || u.name || null;
            if (typeof u == "string")
                return u
        }
        return null
    }
    function b(c) {
        var u = c
          , v = c;
        if (c.alternate)
            for (; u.return; )
                u = u.return;
        else {
            c = u;
            do
                u = c,
                u.flags & 4098 && (v = u.return),
                c = u.return;
            while (c)
        }
        return u.tag === 3 ? v : null
    }
    function L(c) {
        if (b(c) !== c)
            throw Error(o(188))
    }
    function Y(c) {
        var u = c.alternate;
        if (!u) {
            if (u = b(c),
            u === null)
                throw Error(o(188));
            return u !== c ? null : c
        }
        for (var v = c, x = u; ; ) {
            var E = v.return;
            if (E === null)
                break;
            var R = E.alternate;
            if (R === null) {
                if (x = E.return,
                x !== null) {
                    v = x;
                    continue
                }
                break
            }
            if (E.child === R.child) {
                for (R = E.child; R; ) {
                    if (R === v)
                        return L(E),
                        c;
                    if (R === x)
                        return L(E),
                        u;
                    R = R.sibling
                }
                throw Error(o(188))
            }
            if (v.return !== x.return)
                v = E,
                x = R;
            else {
                for (var W = !1, ne = E.child; ne; ) {
                    if (ne === v) {
                        W = !0,
                        v = E,
                        x = R;
                        break
                    }
                    if (ne === x) {
                        W = !0,
                        x = E,
                        v = R;
                        break
                    }
                    ne = ne.sibling
                }
                if (!W) {
                    for (ne = R.child; ne; ) {
                        if (ne === v) {
                            W = !0,
                            v = R,
                            x = E;
                            break
                        }
                        if (ne === x) {
                            W = !0,
                            x = R,
                            v = E;
                            break
                        }
                        ne = ne.sibling
                    }
                    if (!W)
                        throw Error(o(189))
                }
            }
            if (v.alternate !== x)
                throw Error(o(190))
        }
        if (v.tag !== 3)
            throw Error(o(188));
        return v.stateNode.current === v ? c : u
    }
    function Z(c) {
        return c = Y(c),
        c !== null ? $(c) : null
    }
    function $(c) {
        if (c.tag === 5 || c.tag === 6)
            return c;
        for (c = c.child; c !== null; ) {
            var u = $(c);
            if (u !== null)
                return u;
            c = c.sibling
        }
        return null
    }
    function Q(c) {
        if (c.tag === 5 || c.tag === 6)
            return c;
        for (c = c.child; c !== null; ) {
            if (c.tag !== 4) {
                var u = Q(c);
                if (u !== null)
                    return u
            }
            c = c.sibling
        }
        return null
    }
    var ie = Array.isArray, fe = e.getPublicInstance, le = e.getRootHostContext, D = e.getChildHostContext, j = e.prepareForCommit, X = e.resetAfterCommit, ue = e.createInstance, I = e.appendInitialChild, U = e.finalizeInitialChildren, O = e.prepareUpdate, J = e.shouldSetTextContent, F = e.createTextInstance, B = e.scheduleTimeout, ae = e.cancelTimeout, _e = e.noTimeout, pe = e.isPrimaryRenderer, Ee = e.supportsMutation, se = e.supportsPersistence, oe = e.supportsHydration, ve = e.getInstanceFromNode, Ce = e.preparePortalMount, Re = e.getCurrentEventPriority, Le = e.detachDeletedInstance, Be = e.supportsMicrotasks, Ze = e.scheduleMicrotask, Ye = e.supportsTestSelectors, pt = e.findFiberRoot, G = e.getBoundingRect, k = e.getTextContent, ee = e.isHiddenSubtree, we = e.matchAccessibilityRole, Ie = e.setFocusIfFocusable, Fe = e.setupIntersectionObserver, Je = e.appendChild, We = e.appendChildToContainer, Me = e.commitTextUpdate, Qe = e.commitMount, tt = e.commitUpdate, st = e.insertBefore, Xe = e.insertInContainerBefore, K = e.removeChild, q = e.removeChildFromContainer, xe = e.resetTextContent, Ne = e.hideInstance, H = e.hideTextInstance, te = e.unhideInstance, me = e.unhideTextInstance, Te = e.clearContainer, Pe = e.cloneInstance, Ge = e.createContainerChildSet, it = e.appendChildToContainerChildSet, Dt = e.finalizeContainerChildren, Bt = e.replaceContainerChildren, bt = e.cloneHiddenInstance, qt = e.cloneHiddenTextInstance, Dn = e.canHydrateInstance, Cr = e.canHydrateTextInstance, ss = e.canHydrateSuspenseInstance, os = e.isSuspenseInstancePending, gu = e.isSuspenseInstanceFallback, R0 = e.registerSuspenseInstanceRetry, V = e.getNextHydratableSibling, he = e.getFirstHydratableChild, Se = e.getFirstHydratableChildWithinContainer, ce = e.getFirstHydratableChildWithinSuspenseInstance, Ae = e.hydrateInstance, rt = e.hydrateTextInstance, at = e.hydrateSuspenseInstance, ut = e.getNextHydratableInstanceAfterSuspenseInstance, mt = e.commitHydratedContainer, wt = e.commitHydratedSuspenseInstance, Mt = e.clearSuspenseBoundary, Tt = e.clearSuspenseBoundaryFromContainer, Vt = e.shouldDeleteUnhydratedTailInstances, Kn = e.didNotMatchHydratedContainerTextInstance, zi = e.didNotMatchHydratedTextInstance, br;
    function Qt(c) {
        if (br === void 0)
            try {
                throw Error()
            } catch (v) {
                var u = v.stack.trim().match(/\n( *(at )?)/);
                br = u && u[1] || ""
            }
        return `
` + br + c
    }
    var At = !1;
    function la(c, u) {
        if (!c || At)
            return "";
        At = !0;
        var v = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (u)
                if (u = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(u.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(u, [])
                    } catch (Ue) {
                        var x = Ue
                    }
                    Reflect.construct(c, [], u)
                } else {
                    try {
                        u.call()
                    } catch (Ue) {
                        x = Ue
                    }
                    c.call(u.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Ue) {
                    x = Ue
                }
                c()
            }
        } catch (Ue) {
            if (Ue && x && typeof Ue.stack == "string") {
                for (var E = Ue.stack.split(`
`), R = x.stack.split(`
`), W = E.length - 1, ne = R.length - 1; 1 <= W && 0 <= ne && E[W] !== R[ne]; )
                    ne--;
                for (; 1 <= W && 0 <= ne; W--,
                ne--)
                    if (E[W] !== R[ne]) {
                        if (W !== 1 || ne !== 1)
                            do
                                if (W--,
                                ne--,
                                0 > ne || E[W] !== R[ne]) {
                                    var ye = `
` + E[W].replace(" at new ", " at ");
                                    return c.displayName && ye.includes("<anonymous>") && (ye = ye.replace("<anonymous>", c.displayName)),
                                    ye
                                }
                            while (1 <= W && 0 <= ne);
                        break
                    }
            }
        } finally {
            At = !1,
            Error.prepareStackTrace = v
        }
        return (c = c ? c.displayName || c.name : "") ? Qt(c) : ""
    }
    var Tn = Object.prototype.hasOwnProperty
      , Pr = []
      , Rs = -1;
    function Ei(c) {
        return {
            current: c
        }
    }
    function Gt(c) {
        0 > Rs || (c.current = Pr[Rs],
        Pr[Rs] = null,
        Rs--)
    }
    function gt(c, u) {
        Rs++,
        Pr[Rs] = c.current,
        c.current = u
    }
    var ii = {}
      , An = Ei(ii)
      , Yt = Ei(!1)
      , Lr = ii;
    function lo(c, u) {
        var v = c.type.contextTypes;
        if (!v)
            return ii;
        var x = c.stateNode;
        if (x && x.__reactInternalMemoizedUnmaskedChildContext === u)
            return x.__reactInternalMemoizedMaskedChildContext;
        var E = {}, R;
        for (R in v)
            E[R] = u[R];
        return x && (c = c.stateNode,
        c.__reactInternalMemoizedUnmaskedChildContext = u,
        c.__reactInternalMemoizedMaskedChildContext = E),
        E
    }
    function Zn(c) {
        return c = c.childContextTypes,
        c != null
    }
    function Xd() {
        Gt(Yt),
        Gt(An)
    }
    function xw(c, u, v) {
        if (An.current !== ii)
            throw Error(o(168));
        gt(An, u),
        gt(Yt, v)
    }
    function Sw(c, u, v) {
        var x = c.stateNode;
        if (u = u.childContextTypes,
        typeof x.getChildContext != "function")
            return v;
        x = x.getChildContext();
        for (var E in x)
            if (!(E in u))
                throw Error(o(108, N(c) || "Unknown", E));
        return s({}, v, x)
    }
    function $d(c) {
        return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || ii,
        Lr = An.current,
        gt(An, c),
        gt(Yt, Yt.current),
        !0
    }
    function ww(c, u, v) {
        var x = c.stateNode;
        if (!x)
            throw Error(o(169));
        v ? (c = Sw(c, u, Lr),
        x.__reactInternalMemoizedMergedChildContext = c,
        Gt(Yt),
        Gt(An),
        gt(An, c)) : Gt(Yt),
        gt(Yt, v)
    }
    var Ir = Math.clz32 ? Math.clz32 : x3
      , y3 = Math.log
      , _3 = Math.LN2;
    function x3(c) {
        return c >>>= 0,
        c === 0 ? 32 : 31 - (y3(c) / _3 | 0) | 0
    }
    var jd = 64
      , Yd = 4194304;
    function vu(c) {
        switch (c & -c) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return c & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return c
        }
    }
    function qd(c, u) {
        var v = c.pendingLanes;
        if (v === 0)
            return 0;
        var x = 0
          , E = c.suspendedLanes
          , R = c.pingedLanes
          , W = v & 268435455;
        if (W !== 0) {
            var ne = W & ~E;
            ne !== 0 ? x = vu(ne) : (R &= W,
            R !== 0 && (x = vu(R)))
        } else
            W = v & ~E,
            W !== 0 ? x = vu(W) : R !== 0 && (x = vu(R));
        if (x === 0)
            return 0;
        if (u !== 0 && u !== x && !(u & E) && (E = x & -x,
        R = u & -u,
        E >= R || E === 16 && (R & 4194240) !== 0))
            return u;
        if (x & 4 && (x |= v & 16),
        u = c.entangledLanes,
        u !== 0)
            for (c = c.entanglements,
            u &= x; 0 < u; )
                v = 31 - Ir(u),
                E = 1 << v,
                x |= c[v],
                u &= ~E;
        return x
    }
    function S3(c, u) {
        switch (c) {
        case 1:
        case 2:
        case 4:
            return u + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function w3(c, u) {
        for (var v = c.suspendedLanes, x = c.pingedLanes, E = c.expirationTimes, R = c.pendingLanes; 0 < R; ) {
            var W = 31 - Ir(R)
              , ne = 1 << W
              , ye = E[W];
            ye === -1 ? (!(ne & v) || ne & x) && (E[W] = S3(ne, u)) : ye <= u && (c.expiredLanes |= ne),
            R &= ~ne
        }
    }
    function C0(c) {
        return c = c.pendingLanes & -1073741825,
        c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
    }
    function b0(c) {
        for (var u = [], v = 0; 31 > v; v++)
            u.push(c);
        return u
    }
    function yu(c, u, v) {
        c.pendingLanes |= u,
        u !== 536870912 && (c.suspendedLanes = 0,
        c.pingedLanes = 0),
        c = c.eventTimes,
        u = 31 - Ir(u),
        c[u] = v
    }
    function M3(c, u) {
        var v = c.pendingLanes & ~u;
        c.pendingLanes = u,
        c.suspendedLanes = 0,
        c.pingedLanes = 0,
        c.expiredLanes &= u,
        c.mutableReadLanes &= u,
        c.entangledLanes &= u,
        u = c.entanglements;
        var x = c.eventTimes;
        for (c = c.expirationTimes; 0 < v; ) {
            var E = 31 - Ir(v)
              , R = 1 << E;
            u[E] = 0,
            x[E] = -1,
            c[E] = -1,
            v &= ~R
        }
    }
    function P0(c, u) {
        var v = c.entangledLanes |= u;
        for (c = c.entanglements; v; ) {
            var x = 31 - Ir(v)
              , E = 1 << x;
            E & u | c[x] & u && (c[x] |= u),
            v &= ~E
        }
    }
    var Ot = 0;
    function Mw(c) {
        return c &= -c,
        1 < c ? 4 < c ? c & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var L0 = r.unstable_scheduleCallback
      , Ew = r.unstable_cancelCallback
      , E3 = r.unstable_shouldYield
      , T3 = r.unstable_requestPaint
      , Hn = r.unstable_now
      , I0 = r.unstable_ImmediatePriority
      , A3 = r.unstable_UserBlockingPriority
      , N0 = r.unstable_NormalPriority
      , R3 = r.unstable_IdlePriority
      , Kd = null
      , as = null;
    function C3(c) {
        if (as && typeof as.onCommitFiberRoot == "function")
            try {
                as.onCommitFiberRoot(Kd, c, void 0, (c.current.flags & 128) === 128)
            } catch {}
    }
    function b3(c, u) {
        return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
    }
    var ls = typeof Object.is == "function" ? Object.is : b3
      , Cs = null
      , Zd = !1
      , D0 = !1;
    function Tw(c) {
        Cs === null ? Cs = [c] : Cs.push(c)
    }
    function P3(c) {
        Zd = !0,
        Tw(c)
    }
    function cs() {
        if (!D0 && Cs !== null) {
            D0 = !0;
            var c = 0
              , u = Ot;
            try {
                var v = Cs;
                for (Ot = 1; c < v.length; c++) {
                    var x = v[c];
                    do
                        x = x(!0);
                    while (x !== null)
                }
                Cs = null,
                Zd = !1
            } catch (E) {
                throw Cs !== null && (Cs = Cs.slice(c + 1)),
                L0(I0, cs),
                E
            } finally {
                Ot = u,
                D0 = !1
            }
        }
        return null
    }
    var L3 = a.ReactCurrentBatchConfig;
    function Qd(c, u) {
        if (ls(c, u))
            return !0;
        if (typeof c != "object" || c === null || typeof u != "object" || u === null)
            return !1;
        var v = Object.keys(c)
          , x = Object.keys(u);
        if (v.length !== x.length)
            return !1;
        for (x = 0; x < v.length; x++) {
            var E = v[x];
            if (!Tn.call(u, E) || !ls(c[E], u[E]))
                return !1
        }
        return !0
    }
    function I3(c) {
        switch (c.tag) {
        case 5:
            return Qt(c.type);
        case 16:
            return Qt("Lazy");
        case 13:
            return Qt("Suspense");
        case 19:
            return Qt("SuspenseList");
        case 0:
        case 2:
        case 15:
            return c = la(c.type, !1),
            c;
        case 11:
            return c = la(c.type.render, !1),
            c;
        case 1:
            return c = la(c.type, !0),
            c;
        default:
            return ""
        }
    }
    function Nr(c, u) {
        if (c && c.defaultProps) {
            u = s({}, u),
            c = c.defaultProps;
            for (var v in c)
                u[v] === void 0 && (u[v] = c[v]);
            return u
        }
        return u
    }
    var Jd = Ei(null)
      , eh = null
      , yl = null
      , U0 = null;
    function k0() {
        U0 = yl = eh = null
    }
    function Aw(c, u, v) {
        pe ? (gt(Jd, u._currentValue),
        u._currentValue = v) : (gt(Jd, u._currentValue2),
        u._currentValue2 = v)
    }
    function O0(c) {
        var u = Jd.current;
        Gt(Jd),
        pe ? c._currentValue = u : c._currentValue2 = u
    }
    function F0(c, u, v) {
        for (; c !== null; ) {
            var x = c.alternate;
            if ((c.childLanes & u) !== u ? (c.childLanes |= u,
            x !== null && (x.childLanes |= u)) : x !== null && (x.childLanes & u) !== u && (x.childLanes |= u),
            c === v)
                break;
            c = c.return
        }
    }
    function _l(c, u) {
        eh = c,
        U0 = yl = null,
        c = c.dependencies,
        c !== null && c.firstContext !== null && (c.lanes & u && (Hi = !0),
        c.firstContext = null)
    }
    function ir(c) {
        var u = pe ? c._currentValue : c._currentValue2;
        if (U0 !== c)
            if (c = {
                context: c,
                memoizedValue: u,
                next: null
            },
            yl === null) {
                if (eh === null)
                    throw Error(o(308));
                yl = c,
                eh.dependencies = {
                    lanes: 0,
                    firstContext: c
                }
            } else
                yl = yl.next = c;
        return u
    }
    var us = null
      , co = !1;
    function z0(c) {
        c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Rw(c, u) {
        c = c.updateQueue,
        u.updateQueue === c && (u.updateQueue = {
            baseState: c.baseState,
            firstBaseUpdate: c.firstBaseUpdate,
            lastBaseUpdate: c.lastBaseUpdate,
            shared: c.shared,
            effects: c.effects
        })
    }
    function bs(c, u) {
        return {
            eventTime: c,
            lane: u,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function uo(c, u) {
        var v = c.updateQueue;
        v !== null && (v = v.shared,
        Rn !== null && c.mode & 1 && !(Et & 2) ? (c = v.interleaved,
        c === null ? (u.next = u,
        us === null ? us = [v] : us.push(v)) : (u.next = c.next,
        c.next = u),
        v.interleaved = u) : (c = v.pending,
        c === null ? u.next = u : (u.next = c.next,
        c.next = u),
        v.pending = u))
    }
    function th(c, u, v) {
        if (u = u.updateQueue,
        u !== null && (u = u.shared,
        (v & 4194240) !== 0)) {
            var x = u.lanes;
            x &= c.pendingLanes,
            v |= x,
            u.lanes = v,
            P0(c, v)
        }
    }
    function Cw(c, u) {
        var v = c.updateQueue
          , x = c.alternate;
        if (x !== null && (x = x.updateQueue,
        v === x)) {
            var E = null
              , R = null;
            if (v = v.firstBaseUpdate,
            v !== null) {
                do {
                    var W = {
                        eventTime: v.eventTime,
                        lane: v.lane,
                        tag: v.tag,
                        payload: v.payload,
                        callback: v.callback,
                        next: null
                    };
                    R === null ? E = R = W : R = R.next = W,
                    v = v.next
                } while (v !== null);
                R === null ? E = R = u : R = R.next = u
            } else
                E = R = u;
            v = {
                baseState: x.baseState,
                firstBaseUpdate: E,
                lastBaseUpdate: R,
                shared: x.shared,
                effects: x.effects
            },
            c.updateQueue = v;
            return
        }
        c = v.lastBaseUpdate,
        c === null ? v.firstBaseUpdate = u : c.next = u,
        v.lastBaseUpdate = u
    }
    function nh(c, u, v, x) {
        var E = c.updateQueue;
        co = !1;
        var R = E.firstBaseUpdate
          , W = E.lastBaseUpdate
          , ne = E.shared.pending;
        if (ne !== null) {
            E.shared.pending = null;
            var ye = ne
              , Ue = ye.next;
            ye.next = null,
            W === null ? R = Ue : W.next = Ue,
            W = ye;
            var Ke = c.alternate;
            Ke !== null && (Ke = Ke.updateQueue,
            ne = Ke.lastBaseUpdate,
            ne !== W && (ne === null ? Ke.firstBaseUpdate = Ue : ne.next = Ue,
            Ke.lastBaseUpdate = ye))
        }
        if (R !== null) {
            var dt = E.baseState;
            W = 0,
            Ke = Ue = ye = null,
            ne = R;
            do {
                var ot = ne.lane
                  , Kt = ne.eventTime;
                if ((x & ot) === ot) {
                    Ke !== null && (Ke = Ke.next = {
                        eventTime: Kt,
                        lane: 0,
                        tag: ne.tag,
                        payload: ne.payload,
                        callback: ne.callback,
                        next: null
                    });
                    e: {
                        var nt = c
                          , ai = ne;
                        switch (ot = u,
                        Kt = v,
                        ai.tag) {
                        case 1:
                            if (nt = ai.payload,
                            typeof nt == "function") {
                                dt = nt.call(Kt, dt, ot);
                                break e
                            }
                            dt = nt;
                            break e;
                        case 3:
                            nt.flags = nt.flags & -65537 | 128;
                        case 0:
                            if (nt = ai.payload,
                            ot = typeof nt == "function" ? nt.call(Kt, dt, ot) : nt,
                            ot == null)
                                break e;
                            dt = s({}, dt, ot);
                            break e;
                        case 2:
                            co = !0
                        }
                    }
                    ne.callback !== null && ne.lane !== 0 && (c.flags |= 64,
                    ot = E.effects,
                    ot === null ? E.effects = [ne] : ot.push(ne))
                } else
                    Kt = {
                        eventTime: Kt,
                        lane: ot,
                        tag: ne.tag,
                        payload: ne.payload,
                        callback: ne.callback,
                        next: null
                    },
                    Ke === null ? (Ue = Ke = Kt,
                    ye = dt) : Ke = Ke.next = Kt,
                    W |= ot;
                if (ne = ne.next,
                ne === null) {
                    if (ne = E.shared.pending,
                    ne === null)
                        break;
                    ot = ne,
                    ne = ot.next,
                    ot.next = null,
                    E.lastBaseUpdate = ot,
                    E.shared.pending = null
                }
            } while (1);
            if (Ke === null && (ye = dt),
            E.baseState = ye,
            E.firstBaseUpdate = Ue,
            E.lastBaseUpdate = Ke,
            u = E.shared.interleaved,
            u !== null) {
                E = u;
                do
                    W |= E.lane,
                    E = E.next;
                while (E !== u)
            } else
                R === null && (E.shared.lanes = 0);
            Cl |= W,
            c.lanes = W,
            c.memoizedState = dt
        }
    }
    function bw(c, u, v) {
        if (c = u.effects,
        u.effects = null,
        c !== null)
            for (u = 0; u < c.length; u++) {
                var x = c[u]
                  , E = x.callback;
                if (E !== null) {
                    if (x.callback = null,
                    x = v,
                    typeof E != "function")
                        throw Error(o(191, E));
                    E.call(x)
                }
            }
    }
    var Pw = new i.Component().refs;
    function B0(c, u, v, x) {
        u = c.memoizedState,
        v = v(x, u),
        v = v == null ? u : s({}, u, v),
        c.memoizedState = v,
        c.lanes === 0 && (c.updateQueue.baseState = v)
    }
    var ih = {
        isMounted: function(c) {
            return (c = c._reactInternals) ? b(c) === c : !1
        },
        enqueueSetState: function(c, u, v) {
            c = c._reactInternals;
            var x = gi()
              , E = po(c)
              , R = bs(x, E);
            R.payload = u,
            v != null && (R.callback = v),
            uo(c, R),
            u = lr(c, E, x),
            u !== null && th(u, c, E)
        },
        enqueueReplaceState: function(c, u, v) {
            c = c._reactInternals;
            var x = gi()
              , E = po(c)
              , R = bs(x, E);
            R.tag = 1,
            R.payload = u,
            v != null && (R.callback = v),
            uo(c, R),
            u = lr(c, E, x),
            u !== null && th(u, c, E)
        },
        enqueueForceUpdate: function(c, u) {
            c = c._reactInternals;
            var v = gi()
              , x = po(c)
              , E = bs(v, x);
            E.tag = 2,
            u != null && (E.callback = u),
            uo(c, E),
            u = lr(c, x, v),
            u !== null && th(u, c, x)
        }
    };
    function Lw(c, u, v, x, E, R, W) {
        return c = c.stateNode,
        typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(x, R, W) : u.prototype && u.prototype.isPureReactComponent ? !Qd(v, x) || !Qd(E, R) : !0
    }
    function Iw(c, u, v) {
        var x = !1
          , E = ii
          , R = u.contextType;
        return typeof R == "object" && R !== null ? R = ir(R) : (E = Zn(u) ? Lr : An.current,
        x = u.contextTypes,
        R = (x = x != null) ? lo(c, E) : ii),
        u = new u(v,R),
        c.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null,
        u.updater = ih,
        c.stateNode = u,
        u._reactInternals = c,
        x && (c = c.stateNode,
        c.__reactInternalMemoizedUnmaskedChildContext = E,
        c.__reactInternalMemoizedMaskedChildContext = R),
        u
    }
    function Nw(c, u, v, x) {
        c = u.state,
        typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(v, x),
        typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(v, x),
        u.state !== c && ih.enqueueReplaceState(u, u.state, null)
    }
    function V0(c, u, v, x) {
        var E = c.stateNode;
        E.props = v,
        E.state = c.memoizedState,
        E.refs = Pw,
        z0(c);
        var R = u.contextType;
        typeof R == "object" && R !== null ? E.context = ir(R) : (R = Zn(u) ? Lr : An.current,
        E.context = lo(c, R)),
        E.state = c.memoizedState,
        R = u.getDerivedStateFromProps,
        typeof R == "function" && (B0(c, u, R, v),
        E.state = c.memoizedState),
        typeof u.getDerivedStateFromProps == "function" || typeof E.getSnapshotBeforeUpdate == "function" || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (u = E.state,
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(),
        u !== E.state && ih.enqueueReplaceState(E, E.state, null),
        nh(c, v, E, x),
        E.state = c.memoizedState),
        typeof E.componentDidMount == "function" && (c.flags |= 4194308)
    }
    var xl = []
      , Sl = 0
      , rh = null
      , sh = 0
      , rr = []
      , sr = 0
      , ca = null
      , Ps = 1
      , Ls = "";
    function ua(c, u) {
        xl[Sl++] = sh,
        xl[Sl++] = rh,
        rh = c,
        sh = u
    }
    function Dw(c, u, v) {
        rr[sr++] = Ps,
        rr[sr++] = Ls,
        rr[sr++] = ca,
        ca = c;
        var x = Ps;
        c = Ls;
        var E = 32 - Ir(x) - 1;
        x &= ~(1 << E),
        v += 1;
        var R = 32 - Ir(u) + E;
        if (30 < R) {
            var W = E - E % 5;
            R = (x & (1 << W) - 1).toString(32),
            x >>= W,
            E -= W,
            Ps = 1 << 32 - Ir(u) + E | v << E | x,
            Ls = R + c
        } else
            Ps = 1 << R | v << E | x,
            Ls = c
    }
    function H0(c) {
        c.return !== null && (ua(c, 1),
        Dw(c, 1, 0))
    }
    function G0(c) {
        for (; c === rh; )
            rh = xl[--Sl],
            xl[Sl] = null,
            sh = xl[--Sl],
            xl[Sl] = null;
        for (; c === ca; )
            ca = rr[--sr],
            rr[sr] = null,
            Ls = rr[--sr],
            rr[sr] = null,
            Ps = rr[--sr],
            rr[sr] = null
    }
    var Bi = null
      , Vi = null
      , an = !1
      , _u = !1
      , Dr = null;
    function Uw(c, u) {
        var v = cr(5, null, null, 0);
        v.elementType = "DELETED",
        v.stateNode = u,
        v.return = c,
        u = c.deletions,
        u === null ? (c.deletions = [v],
        c.flags |= 16) : u.push(v)
    }
    function kw(c, u) {
        switch (c.tag) {
        case 5:
            return u = Dn(u, c.type, c.pendingProps),
            u !== null ? (c.stateNode = u,
            Bi = c,
            Vi = he(u),
            !0) : !1;
        case 6:
            return u = Cr(u, c.pendingProps),
            u !== null ? (c.stateNode = u,
            Bi = c,
            Vi = null,
            !0) : !1;
        case 13:
            if (u = ss(u),
            u !== null) {
                var v = ca !== null ? {
                    id: Ps,
                    overflow: Ls
                } : null;
                return c.memoizedState = {
                    dehydrated: u,
                    treeContext: v,
                    retryLane: 1073741824
                },
                v = cr(18, null, null, 0),
                v.stateNode = u,
                v.return = c,
                c.child = v,
                Bi = c,
                Vi = null,
                !0
            }
            return !1;
        default:
            return !1
        }
    }
    function W0(c) {
        return (c.mode & 1) !== 0 && (c.flags & 128) === 0
    }
    function X0(c) {
        if (an) {
            var u = Vi;
            if (u) {
                var v = u;
                if (!kw(c, u)) {
                    if (W0(c))
                        throw Error(o(418));
                    u = V(v);
                    var x = Bi;
                    u && kw(c, u) ? Uw(x, v) : (c.flags = c.flags & -4097 | 2,
                    an = !1,
                    Bi = c)
                }
            } else {
                if (W0(c))
                    throw Error(o(418));
                c.flags = c.flags & -4097 | 2,
                an = !1,
                Bi = c
            }
        }
    }
    function Ow(c) {
        for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; )
            c = c.return;
        Bi = c
    }
    function xu(c) {
        if (!oe || c !== Bi)
            return !1;
        if (!an)
            return Ow(c),
            an = !0,
            !1;
        if (c.tag !== 3 && (c.tag !== 5 || Vt(c.type) && !J(c.type, c.memoizedProps))) {
            var u = Vi;
            if (u) {
                if (W0(c)) {
                    for (c = Vi; c; )
                        c = V(c);
                    throw Error(o(418))
                }
                for (; u; )
                    Uw(c, u),
                    u = V(u)
            }
        }
        if (Ow(c),
        c.tag === 13) {
            if (!oe)
                throw Error(o(316));
            if (c = c.memoizedState,
            c = c !== null ? c.dehydrated : null,
            !c)
                throw Error(o(317));
            Vi = ut(c)
        } else
            Vi = Bi ? V(c.stateNode) : null;
        return !0
    }
    function wl() {
        oe && (Vi = Bi = null,
        _u = an = !1)
    }
    function $0(c) {
        Dr === null ? Dr = [c] : Dr.push(c)
    }
    function Su(c, u, v) {
        if (c = v.ref,
        c !== null && typeof c != "function" && typeof c != "object") {
            if (v._owner) {
                if (v = v._owner,
                v) {
                    if (v.tag !== 1)
                        throw Error(o(309));
                    var x = v.stateNode
                }
                if (!x)
                    throw Error(o(147, c));
                var E = x
                  , R = "" + c;
                return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === R ? u.ref : (u = function(W) {
                    var ne = E.refs;
                    ne === Pw && (ne = E.refs = {}),
                    W === null ? delete ne[R] : ne[R] = W
                }
                ,
                u._stringRef = R,
                u)
            }
            if (typeof c != "string")
                throw Error(o(284));
            if (!v._owner)
                throw Error(o(290, c))
        }
        return c
    }
    function oh(c, u) {
        throw c = Object.prototype.toString.call(u),
        Error(o(31, c === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : c))
    }
    function Fw(c) {
        var u = c._init;
        return u(c._payload)
    }
    function zw(c) {
        function u(de, re) {
            if (c) {
                var ge = de.deletions;
                ge === null ? (de.deletions = [re],
                de.flags |= 16) : ge.push(re)
            }
        }
        function v(de, re) {
            if (!c)
                return null;
            for (; re !== null; )
                u(de, re),
                re = re.sibling;
            return null
        }
        function x(de, re) {
            for (de = new Map; re !== null; )
                re.key !== null ? de.set(re.key, re) : de.set(re.index, re),
                re = re.sibling;
            return de
        }
        function E(de, re) {
            return de = go(de, re),
            de.index = 0,
            de.sibling = null,
            de
        }
        function R(de, re, ge) {
            return de.index = ge,
            c ? (ge = de.alternate,
            ge !== null ? (ge = ge.index,
            ge < re ? (de.flags |= 2,
            re) : ge) : (de.flags |= 2,
            re)) : (de.flags |= 1048576,
            re)
        }
        function W(de) {
            return c && de.alternate === null && (de.flags |= 2),
            de
        }
        function ne(de, re, ge, He) {
            return re === null || re.tag !== 6 ? (re = bv(ge, de.mode, He),
            re.return = de,
            re) : (re = E(re, ge),
            re.return = de,
            re)
        }
        function ye(de, re, ge, He) {
            var et = ge.type;
            return et === d ? Ke(de, re, ge.props.children, He, ge.key) : re !== null && (re.elementType === et || typeof et == "object" && et !== null && et.$$typeof === w && Fw(et) === re.type) ? (He = E(re, ge.props),
            He.ref = Su(de, re, ge),
            He.return = de,
            He) : (He = Oh(ge.type, ge.key, ge.props, null, de.mode, He),
            He.ref = Su(de, re, ge),
            He.return = de,
            He)
        }
        function Ue(de, re, ge, He) {
            return re === null || re.tag !== 4 || re.stateNode.containerInfo !== ge.containerInfo || re.stateNode.implementation !== ge.implementation ? (re = Pv(ge, de.mode, He),
            re.return = de,
            re) : (re = E(re, ge.children || []),
            re.return = de,
            re)
        }
        function Ke(de, re, ge, He, et) {
            return re === null || re.tag !== 7 ? (re = va(ge, de.mode, He, et),
            re.return = de,
            re) : (re = E(re, ge),
            re.return = de,
            re)
        }
        function dt(de, re, ge) {
            if (typeof re == "string" && re !== "" || typeof re == "number")
                return re = bv("" + re, de.mode, ge),
                re.return = de,
                re;
            if (typeof re == "object" && re !== null) {
                switch (re.$$typeof) {
                case l:
                    return ge = Oh(re.type, re.key, re.props, null, de.mode, ge),
                    ge.ref = Su(de, null, re),
                    ge.return = de,
                    ge;
                case f:
                    return re = Pv(re, de.mode, ge),
                    re.return = de,
                    re;
                case w:
                    var He = re._init;
                    return dt(de, He(re._payload), ge)
                }
                if (ie(re) || C(re))
                    return re = va(re, de.mode, ge, null),
                    re.return = de,
                    re;
                oh(de, re)
            }
            return null
        }
        function ot(de, re, ge, He) {
            var et = re !== null ? re.key : null;
            if (typeof ge == "string" && ge !== "" || typeof ge == "number")
                return et !== null ? null : ne(de, re, "" + ge, He);
            if (typeof ge == "object" && ge !== null) {
                switch (ge.$$typeof) {
                case l:
                    return ge.key === et ? ye(de, re, ge, He) : null;
                case f:
                    return ge.key === et ? Ue(de, re, ge, He) : null;
                case w:
                    return et = ge._init,
                    ot(de, re, et(ge._payload), He)
                }
                if (ie(ge) || C(ge))
                    return et !== null ? null : Ke(de, re, ge, He, null);
                oh(de, ge)
            }
            return null
        }
        function Kt(de, re, ge, He, et) {
            if (typeof He == "string" && He !== "" || typeof He == "number")
                return de = de.get(ge) || null,
                ne(re, de, "" + He, et);
            if (typeof He == "object" && He !== null) {
                switch (He.$$typeof) {
                case l:
                    return de = de.get(He.key === null ? ge : He.key) || null,
                    ye(re, de, He, et);
                case f:
                    return de = de.get(He.key === null ? ge : He.key) || null,
                    Ue(re, de, He, et);
                case w:
                    var yt = He._init;
                    return Kt(de, re, ge, yt(He._payload), et)
                }
                if (ie(He) || C(He))
                    return de = de.get(ge) || null,
                    Ke(re, de, He, et, null);
                oh(re, He)
            }
            return null
        }
        function nt(de, re, ge, He) {
            for (var et = null, yt = null, ht = re, Ft = re = 0, Wn = null; ht !== null && Ft < ge.length; Ft++) {
                ht.index > Ft ? (Wn = ht,
                ht = null) : Wn = ht.sibling;
                var zt = ot(de, ht, ge[Ft], He);
                if (zt === null) {
                    ht === null && (ht = Wn);
                    break
                }
                c && ht && zt.alternate === null && u(de, ht),
                re = R(zt, re, Ft),
                yt === null ? et = zt : yt.sibling = zt,
                yt = zt,
                ht = Wn
            }
            if (Ft === ge.length)
                return v(de, ht),
                an && ua(de, Ft),
                et;
            if (ht === null) {
                for (; Ft < ge.length; Ft++)
                    ht = dt(de, ge[Ft], He),
                    ht !== null && (re = R(ht, re, Ft),
                    yt === null ? et = ht : yt.sibling = ht,
                    yt = ht);
                return an && ua(de, Ft),
                et
            }
            for (ht = x(de, ht); Ft < ge.length; Ft++)
                Wn = Kt(ht, de, Ft, ge[Ft], He),
                Wn !== null && (c && Wn.alternate !== null && ht.delete(Wn.key === null ? Ft : Wn.key),
                re = R(Wn, re, Ft),
                yt === null ? et = Wn : yt.sibling = Wn,
                yt = Wn);
            return c && ht.forEach(function(vo) {
                return u(de, vo)
            }),
            an && ua(de, Ft),
            et
        }
        function ai(de, re, ge, He) {
            var et = C(ge);
            if (typeof et != "function")
                throw Error(o(150));
            if (ge = et.call(ge),
            ge == null)
                throw Error(o(151));
            for (var yt = et = null, ht = re, Ft = re = 0, Wn = null, zt = ge.next(); ht !== null && !zt.done; Ft++,
            zt = ge.next()) {
                ht.index > Ft ? (Wn = ht,
                ht = null) : Wn = ht.sibling;
                var vo = ot(de, ht, zt.value, He);
                if (vo === null) {
                    ht === null && (ht = Wn);
                    break
                }
                c && ht && vo.alternate === null && u(de, ht),
                re = R(vo, re, Ft),
                yt === null ? et = vo : yt.sibling = vo,
                yt = vo,
                ht = Wn
            }
            if (zt.done)
                return v(de, ht),
                an && ua(de, Ft),
                et;
            if (ht === null) {
                for (; !zt.done; Ft++,
                zt = ge.next())
                    zt = dt(de, zt.value, He),
                    zt !== null && (re = R(zt, re, Ft),
                    yt === null ? et = zt : yt.sibling = zt,
                    yt = zt);
                return an && ua(de, Ft),
                et
            }
            for (ht = x(de, ht); !zt.done; Ft++,
            zt = ge.next())
                zt = Kt(ht, de, Ft, zt.value, He),
                zt !== null && (c && zt.alternate !== null && ht.delete(zt.key === null ? Ft : zt.key),
                re = R(zt, re, Ft),
                yt === null ? et = zt : yt.sibling = zt,
                yt = zt);
            return c && ht.forEach(function(lN) {
                return u(de, lN)
            }),
            an && ua(de, Ft),
            et
        }
        function ur(de, re, ge, He) {
            if (typeof ge == "object" && ge !== null && ge.type === d && ge.key === null && (ge = ge.props.children),
            typeof ge == "object" && ge !== null) {
                switch (ge.$$typeof) {
                case l:
                    e: {
                        for (var et = ge.key, yt = re; yt !== null; ) {
                            if (yt.key === et) {
                                if (et = ge.type,
                                et === d) {
                                    if (yt.tag === 7) {
                                        v(de, yt.sibling),
                                        re = E(yt, ge.props.children),
                                        re.return = de,
                                        de = re;
                                        break e
                                    }
                                } else if (yt.elementType === et || typeof et == "object" && et !== null && et.$$typeof === w && Fw(et) === yt.type) {
                                    v(de, yt.sibling),
                                    re = E(yt, ge.props),
                                    re.ref = Su(de, yt, ge),
                                    re.return = de,
                                    de = re;
                                    break e
                                }
                                v(de, yt);
                                break
                            } else
                                u(de, yt);
                            yt = yt.sibling
                        }
                        ge.type === d ? (re = va(ge.props.children, de.mode, He, ge.key),
                        re.return = de,
                        de = re) : (He = Oh(ge.type, ge.key, ge.props, null, de.mode, He),
                        He.ref = Su(de, re, ge),
                        He.return = de,
                        de = He)
                    }
                    return W(de);
                case f:
                    e: {
                        for (yt = ge.key; re !== null; ) {
                            if (re.key === yt)
                                if (re.tag === 4 && re.stateNode.containerInfo === ge.containerInfo && re.stateNode.implementation === ge.implementation) {
                                    v(de, re.sibling),
                                    re = E(re, ge.children || []),
                                    re.return = de,
                                    de = re;
                                    break e
                                } else {
                                    v(de, re);
                                    break
                                }
                            else
                                u(de, re);
                            re = re.sibling
                        }
                        re = Pv(ge, de.mode, He),
                        re.return = de,
                        de = re
                    }
                    return W(de);
                case w:
                    return yt = ge._init,
                    ur(de, re, yt(ge._payload), He)
                }
                if (ie(ge))
                    return nt(de, re, ge, He);
                if (C(ge))
                    return ai(de, re, ge, He);
                oh(de, ge)
            }
            return typeof ge == "string" && ge !== "" || typeof ge == "number" ? (ge = "" + ge,
            re !== null && re.tag === 6 ? (v(de, re.sibling),
            re = E(re, ge),
            re.return = de,
            de = re) : (v(de, re),
            re = bv(ge, de.mode, He),
            re.return = de,
            de = re),
            W(de)) : v(de, re)
        }
        return ur
    }
    var Ml = zw(!0)
      , Bw = zw(!1)
      , wu = {}
      , or = Ei(wu)
      , Mu = Ei(wu)
      , El = Ei(wu);
    function fs(c) {
        if (c === wu)
            throw Error(o(174));
        return c
    }
    function j0(c, u) {
        gt(El, u),
        gt(Mu, c),
        gt(or, wu),
        c = le(u),
        Gt(or),
        gt(or, c)
    }
    function Tl() {
        Gt(or),
        Gt(Mu),
        Gt(El)
    }
    function Vw(c) {
        var u = fs(El.current)
          , v = fs(or.current);
        u = D(v, c.type, u),
        v !== u && (gt(Mu, c),
        gt(or, u))
    }
    function Y0(c) {
        Mu.current === c && (Gt(or),
        Gt(Mu))
    }
    var un = Ei(0);
    function ah(c) {
        for (var u = c; u !== null; ) {
            if (u.tag === 13) {
                var v = u.memoizedState;
                if (v !== null && (v = v.dehydrated,
                v === null || os(v) || gu(v)))
                    return u
            } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                if (u.flags & 128)
                    return u
            } else if (u.child !== null) {
                u.child.return = u,
                u = u.child;
                continue
            }
            if (u === c)
                break;
            for (; u.sibling === null; ) {
                if (u.return === null || u.return === c)
                    return null;
                u = u.return
            }
            u.sibling.return = u.return,
            u = u.sibling
        }
        return null
    }
    var q0 = [];
    function K0() {
        for (var c = 0; c < q0.length; c++) {
            var u = q0[c];
            pe ? u._workInProgressVersionPrimary = null : u._workInProgressVersionSecondary = null
        }
        q0.length = 0
    }
    var lh = a.ReactCurrentDispatcher
      , ar = a.ReactCurrentBatchConfig
      , Al = 0
      , gn = null
      , ri = null
      , Gn = null
      , ch = !1
      , Eu = !1
      , Tu = 0
      , N3 = 0;
    function si() {
        throw Error(o(321))
    }
    function Z0(c, u) {
        if (u === null)
            return !1;
        for (var v = 0; v < u.length && v < c.length; v++)
            if (!ls(c[v], u[v]))
                return !1;
        return !0
    }
    function Q0(c, u, v, x, E, R) {
        if (Al = R,
        gn = u,
        u.memoizedState = null,
        u.updateQueue = null,
        u.lanes = 0,
        lh.current = c === null || c.memoizedState === null ? O3 : F3,
        c = v(x, E),
        Eu) {
            R = 0;
            do {
                if (Eu = !1,
                Tu = 0,
                25 <= R)
                    throw Error(o(301));
                R += 1,
                Gn = ri = null,
                u.updateQueue = null,
                lh.current = z3,
                c = v(x, E)
            } while (Eu)
        }
        if (lh.current = ph,
        u = ri !== null && ri.next !== null,
        Al = 0,
        Gn = ri = gn = null,
        ch = !1,
        u)
            throw Error(o(300));
        return c
    }
    function J0() {
        var c = Tu !== 0;
        return Tu = 0,
        c
    }
    function Is() {
        var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Gn === null ? gn.memoizedState = Gn = c : Gn = Gn.next = c,
        Gn
    }
    function ds() {
        if (ri === null) {
            var c = gn.alternate;
            c = c !== null ? c.memoizedState : null
        } else
            c = ri.next;
        var u = Gn === null ? gn.memoizedState : Gn.next;
        if (u !== null)
            Gn = u,
            ri = c;
        else {
            if (c === null)
                throw Error(o(310));
            ri = c,
            c = {
                memoizedState: ri.memoizedState,
                baseState: ri.baseState,
                baseQueue: ri.baseQueue,
                queue: ri.queue,
                next: null
            },
            Gn === null ? gn.memoizedState = Gn = c : Gn = Gn.next = c
        }
        return Gn
    }
    function fa(c, u) {
        return typeof u == "function" ? u(c) : u
    }
    function uh(c) {
        var u = ds()
          , v = u.queue;
        if (v === null)
            throw Error(o(311));
        v.lastRenderedReducer = c;
        var x = ri
          , E = x.baseQueue
          , R = v.pending;
        if (R !== null) {
            if (E !== null) {
                var W = E.next;
                E.next = R.next,
                R.next = W
            }
            x.baseQueue = E = R,
            v.pending = null
        }
        if (E !== null) {
            R = E.next,
            x = x.baseState;
            var ne = W = null
              , ye = null
              , Ue = R;
            do {
                var Ke = Ue.lane;
                if ((Al & Ke) === Ke)
                    ye !== null && (ye = ye.next = {
                        lane: 0,
                        action: Ue.action,
                        hasEagerState: Ue.hasEagerState,
                        eagerState: Ue.eagerState,
                        next: null
                    }),
                    x = Ue.hasEagerState ? Ue.eagerState : c(x, Ue.action);
                else {
                    var dt = {
                        lane: Ke,
                        action: Ue.action,
                        hasEagerState: Ue.hasEagerState,
                        eagerState: Ue.eagerState,
                        next: null
                    };
                    ye === null ? (ne = ye = dt,
                    W = x) : ye = ye.next = dt,
                    gn.lanes |= Ke,
                    Cl |= Ke
                }
                Ue = Ue.next
            } while (Ue !== null && Ue !== R);
            ye === null ? W = x : ye.next = ne,
            ls(x, u.memoizedState) || (Hi = !0),
            u.memoizedState = x,
            u.baseState = W,
            u.baseQueue = ye,
            v.lastRenderedState = x
        }
        if (c = v.interleaved,
        c !== null) {
            E = c;
            do
                R = E.lane,
                gn.lanes |= R,
                Cl |= R,
                E = E.next;
            while (E !== c)
        } else
            E === null && (v.lanes = 0);
        return [u.memoizedState, v.dispatch]
    }
    function fh(c) {
        var u = ds()
          , v = u.queue;
        if (v === null)
            throw Error(o(311));
        v.lastRenderedReducer = c;
        var x = v.dispatch
          , E = v.pending
          , R = u.memoizedState;
        if (E !== null) {
            v.pending = null;
            var W = E = E.next;
            do
                R = c(R, W.action),
                W = W.next;
            while (W !== E);
            ls(R, u.memoizedState) || (Hi = !0),
            u.memoizedState = R,
            u.baseQueue === null && (u.baseState = R),
            v.lastRenderedState = R
        }
        return [R, x]
    }
    function Hw() {}
    function Gw(c, u) {
        var v = gn
          , x = ds()
          , E = u()
          , R = !ls(x.memoizedState, E);
        if (R && (x.memoizedState = E,
        Hi = !0),
        x = x.queue,
        Ru($w.bind(null, v, x, c), [c]),
        x.getSnapshot !== u || R || Gn !== null && Gn.memoizedState.tag & 1) {
            if (v.flags |= 2048,
            Au(9, Xw.bind(null, v, x, E, u), void 0, null),
            Rn === null)
                throw Error(o(349));
            Al & 30 || Ww(v, u, E)
        }
        return E
    }
    function Ww(c, u, v) {
        c.flags |= 16384,
        c = {
            getSnapshot: u,
            value: v
        },
        u = gn.updateQueue,
        u === null ? (u = {
            lastEffect: null,
            stores: null
        },
        gn.updateQueue = u,
        u.stores = [c]) : (v = u.stores,
        v === null ? u.stores = [c] : v.push(c))
    }
    function Xw(c, u, v, x) {
        u.value = v,
        u.getSnapshot = x,
        jw(u) && lr(c, 1, -1)
    }
    function $w(c, u, v) {
        return v(function() {
            jw(u) && lr(c, 1, -1)
        })
    }
    function jw(c) {
        var u = c.getSnapshot;
        c = c.value;
        try {
            var v = u();
            return !ls(c, v)
        } catch {
            return !0
        }
    }
    function ev(c) {
        var u = Is();
        return typeof c == "function" && (c = c()),
        u.memoizedState = u.baseState = c,
        c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: fa,
            lastRenderedState: c
        },
        u.queue = c,
        c = c.dispatch = k3.bind(null, gn, c),
        [u.memoizedState, c]
    }
    function Au(c, u, v, x) {
        return c = {
            tag: c,
            create: u,
            destroy: v,
            deps: x,
            next: null
        },
        u = gn.updateQueue,
        u === null ? (u = {
            lastEffect: null,
            stores: null
        },
        gn.updateQueue = u,
        u.lastEffect = c.next = c) : (v = u.lastEffect,
        v === null ? u.lastEffect = c.next = c : (x = v.next,
        v.next = c,
        c.next = x,
        u.lastEffect = c)),
        c
    }
    function Yw() {
        return ds().memoizedState
    }
    function dh(c, u, v, x) {
        var E = Is();
        gn.flags |= c,
        E.memoizedState = Au(1 | u, v, void 0, x === void 0 ? null : x)
    }
    function hh(c, u, v, x) {
        var E = ds();
        x = x === void 0 ? null : x;
        var R = void 0;
        if (ri !== null) {
            var W = ri.memoizedState;
            if (R = W.destroy,
            x !== null && Z0(x, W.deps)) {
                E.memoizedState = Au(u, v, R, x);
                return
            }
        }
        gn.flags |= c,
        E.memoizedState = Au(1 | u, v, R, x)
    }
    function tv(c, u) {
        return dh(8390656, 8, c, u)
    }
    function Ru(c, u) {
        return hh(2048, 8, c, u)
    }
    function qw(c, u) {
        return hh(4, 2, c, u)
    }
    function Kw(c, u) {
        return hh(4, 4, c, u)
    }
    function Zw(c, u) {
        if (typeof u == "function")
            return c = c(),
            u(c),
            function() {
                u(null)
            }
            ;
        if (u != null)
            return c = c(),
            u.current = c,
            function() {
                u.current = null
            }
    }
    function Qw(c, u, v) {
        return v = v != null ? v.concat([c]) : null,
        hh(4, 4, Zw.bind(null, u, c), v)
    }
    function nv() {}
    function Jw(c, u) {
        var v = ds();
        u = u === void 0 ? null : u;
        var x = v.memoizedState;
        return x !== null && u !== null && Z0(u, x[1]) ? x[0] : (v.memoizedState = [c, u],
        c)
    }
    function eM(c, u) {
        var v = ds();
        u = u === void 0 ? null : u;
        var x = v.memoizedState;
        return x !== null && u !== null && Z0(u, x[1]) ? x[0] : (c = c(),
        v.memoizedState = [c, u],
        c)
    }
    function D3(c, u) {
        var v = Ot;
        Ot = v !== 0 && 4 > v ? v : 4,
        c(!0);
        var x = ar.transition;
        ar.transition = {};
        try {
            c(!1),
            u()
        } finally {
            Ot = v,
            ar.transition = x
        }
    }
    function tM() {
        return ds().memoizedState
    }
    function U3(c, u, v) {
        var x = po(c);
        v = {
            lane: x,
            action: v,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        nM(c) ? iM(u, v) : (rM(c, u, v),
        v = gi(),
        c = lr(c, x, v),
        c !== null && sM(c, u, x))
    }
    function k3(c, u, v) {
        var x = po(c)
          , E = {
            lane: x,
            action: v,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (nM(c))
            iM(u, E);
        else {
            rM(c, u, E);
            var R = c.alternate;
            if (c.lanes === 0 && (R === null || R.lanes === 0) && (R = u.lastRenderedReducer,
            R !== null))
                try {
                    var W = u.lastRenderedState
                      , ne = R(W, v);
                    if (E.hasEagerState = !0,
                    E.eagerState = ne,
                    ls(ne, W))
                        return
                } catch {} finally {}
            v = gi(),
            c = lr(c, x, v),
            c !== null && sM(c, u, x)
        }
    }
    function nM(c) {
        var u = c.alternate;
        return c === gn || u !== null && u === gn
    }
    function iM(c, u) {
        Eu = ch = !0;
        var v = c.pending;
        v === null ? u.next = u : (u.next = v.next,
        v.next = u),
        c.pending = u
    }
    function rM(c, u, v) {
        Rn !== null && c.mode & 1 && !(Et & 2) ? (c = u.interleaved,
        c === null ? (v.next = v,
        us === null ? us = [u] : us.push(u)) : (v.next = c.next,
        c.next = v),
        u.interleaved = v) : (c = u.pending,
        c === null ? v.next = v : (v.next = c.next,
        c.next = v),
        u.pending = v)
    }
    function sM(c, u, v) {
        if (v & 4194240) {
            var x = u.lanes;
            x &= c.pendingLanes,
            v |= x,
            u.lanes = v,
            P0(c, v)
        }
    }
    var ph = {
        readContext: ir,
        useCallback: si,
        useContext: si,
        useEffect: si,
        useImperativeHandle: si,
        useInsertionEffect: si,
        useLayoutEffect: si,
        useMemo: si,
        useReducer: si,
        useRef: si,
        useState: si,
        useDebugValue: si,
        useDeferredValue: si,
        useTransition: si,
        useMutableSource: si,
        useSyncExternalStore: si,
        useId: si,
        unstable_isNewReconciler: !1
    }
      , O3 = {
        readContext: ir,
        useCallback: function(c, u) {
            return Is().memoizedState = [c, u === void 0 ? null : u],
            c
        },
        useContext: ir,
        useEffect: tv,
        useImperativeHandle: function(c, u, v) {
            return v = v != null ? v.concat([c]) : null,
            dh(4194308, 4, Zw.bind(null, u, c), v)
        },
        useLayoutEffect: function(c, u) {
            return dh(4194308, 4, c, u)
        },
        useInsertionEffect: function(c, u) {
            return dh(4, 2, c, u)
        },
        useMemo: function(c, u) {
            var v = Is();
            return u = u === void 0 ? null : u,
            c = c(),
            v.memoizedState = [c, u],
            c
        },
        useReducer: function(c, u, v) {
            var x = Is();
            return u = v !== void 0 ? v(u) : u,
            x.memoizedState = x.baseState = u,
            c = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: c,
                lastRenderedState: u
            },
            x.queue = c,
            c = c.dispatch = U3.bind(null, gn, c),
            [x.memoizedState, c]
        },
        useRef: function(c) {
            var u = Is();
            return c = {
                current: c
            },
            u.memoizedState = c
        },
        useState: ev,
        useDebugValue: nv,
        useDeferredValue: function(c) {
            var u = ev(c)
              , v = u[0]
              , x = u[1];
            return tv(function() {
                var E = ar.transition;
                ar.transition = {};
                try {
                    x(c)
                } finally {
                    ar.transition = E
                }
            }, [c]),
            v
        },
        useTransition: function() {
            var c = ev(!1)
              , u = c[0];
            return c = D3.bind(null, c[1]),
            Is().memoizedState = c,
            [u, c]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(c, u, v) {
            var x = gn
              , E = Is();
            if (an) {
                if (v === void 0)
                    throw Error(o(407));
                v = v()
            } else {
                if (v = u(),
                Rn === null)
                    throw Error(o(349));
                Al & 30 || Ww(x, u, v)
            }
            E.memoizedState = v;
            var R = {
                value: v,
                getSnapshot: u
            };
            return E.queue = R,
            tv($w.bind(null, x, R, c), [c]),
            x.flags |= 2048,
            Au(9, Xw.bind(null, x, R, v, u), void 0, null),
            v
        },
        useId: function() {
            var c = Is()
              , u = Rn.identifierPrefix;
            if (an) {
                var v = Ls
                  , x = Ps;
                v = (x & ~(1 << 32 - Ir(x) - 1)).toString(32) + v,
                u = ":" + u + "R" + v,
                v = Tu++,
                0 < v && (u += "H" + v.toString(32)),
                u += ":"
            } else
                v = N3++,
                u = ":" + u + "r" + v.toString(32) + ":";
            return c.memoizedState = u
        },
        unstable_isNewReconciler: !1
    }
      , F3 = {
        readContext: ir,
        useCallback: Jw,
        useContext: ir,
        useEffect: Ru,
        useImperativeHandle: Qw,
        useInsertionEffect: qw,
        useLayoutEffect: Kw,
        useMemo: eM,
        useReducer: uh,
        useRef: Yw,
        useState: function() {
            return uh(fa)
        },
        useDebugValue: nv,
        useDeferredValue: function(c) {
            var u = uh(fa)
              , v = u[0]
              , x = u[1];
            return Ru(function() {
                var E = ar.transition;
                ar.transition = {};
                try {
                    x(c)
                } finally {
                    ar.transition = E
                }
            }, [c]),
            v
        },
        useTransition: function() {
            var c = uh(fa)[0]
              , u = ds().memoizedState;
            return [c, u]
        },
        useMutableSource: Hw,
        useSyncExternalStore: Gw,
        useId: tM,
        unstable_isNewReconciler: !1
    }
      , z3 = {
        readContext: ir,
        useCallback: Jw,
        useContext: ir,
        useEffect: Ru,
        useImperativeHandle: Qw,
        useInsertionEffect: qw,
        useLayoutEffect: Kw,
        useMemo: eM,
        useReducer: fh,
        useRef: Yw,
        useState: function() {
            return fh(fa)
        },
        useDebugValue: nv,
        useDeferredValue: function(c) {
            var u = fh(fa)
              , v = u[0]
              , x = u[1];
            return Ru(function() {
                var E = ar.transition;
                ar.transition = {};
                try {
                    x(c)
                } finally {
                    ar.transition = E
                }
            }, [c]),
            v
        },
        useTransition: function() {
            var c = fh(fa)[0]
              , u = ds().memoizedState;
            return [c, u]
        },
        useMutableSource: Hw,
        useSyncExternalStore: Gw,
        useId: tM,
        unstable_isNewReconciler: !1
    };
    function iv(c, u) {
        try {
            var v = ""
              , x = u;
            do
                v += I3(x),
                x = x.return;
            while (x);
            var E = v
        } catch (R) {
            E = `
Error generating stack: ` + R.message + `
` + R.stack
        }
        return {
            value: c,
            source: u,
            stack: E
        }
    }
    function rv(c, u) {
        try {
            console.error(u.value)
        } catch (v) {
            setTimeout(function() {
                throw v
            })
        }
    }
    var B3 = typeof WeakMap == "function" ? WeakMap : Map;
    function oM(c, u, v) {
        v = bs(-1, v),
        v.tag = 3,
        v.payload = {
            element: null
        };
        var x = u.value;
        return v.callback = function() {
            Ph || (Ph = !0,
            wv = x),
            rv(c, u)
        }
        ,
        v
    }
    function aM(c, u, v) {
        v = bs(-1, v),
        v.tag = 3;
        var x = c.type.getDerivedStateFromError;
        if (typeof x == "function") {
            var E = u.value;
            v.payload = function() {
                return x(E)
            }
            ,
            v.callback = function() {
                rv(c, u)
            }
        }
        var R = c.stateNode;
        return R !== null && typeof R.componentDidCatch == "function" && (v.callback = function() {
            rv(c, u),
            typeof x != "function" && (fo === null ? fo = new Set([this]) : fo.add(this));
            var W = u.stack;
            this.componentDidCatch(u.value, {
                componentStack: W !== null ? W : ""
            })
        }
        ),
        v
    }
    function lM(c, u, v) {
        var x = c.pingCache;
        if (x === null) {
            x = c.pingCache = new B3;
            var E = new Set;
            x.set(u, E)
        } else
            E = x.get(u),
            E === void 0 && (E = new Set,
            x.set(u, E));
        E.has(v) || (E.add(v),
        c = eN.bind(null, c, u, v),
        u.then(c, c))
    }
    function cM(c) {
        do {
            var u;
            if ((u = c.tag === 13) && (u = c.memoizedState,
            u = u !== null ? u.dehydrated !== null : !0),
            u)
                return c;
            c = c.return
        } while (c !== null);
        return null
    }
    function uM(c, u, v, x, E) {
        return c.mode & 1 ? (c.flags |= 65536,
        c.lanes = E,
        c) : (c === u ? c.flags |= 65536 : (c.flags |= 128,
        v.flags |= 131072,
        v.flags &= -52805,
        v.tag === 1 && (v.alternate === null ? v.tag = 17 : (u = bs(-1, 1),
        u.tag = 2,
        uo(v, u))),
        v.lanes |= 1),
        c)
    }
    function hs(c) {
        c.flags |= 4
    }
    function fM(c, u) {
        if (c !== null && c.child === u.child)
            return !0;
        if (u.flags & 16)
            return !1;
        for (c = u.child; c !== null; ) {
            if (c.flags & 12854 || c.subtreeFlags & 12854)
                return !1;
            c = c.sibling
        }
        return !0
    }
    var Cu, bu, mh, gh;
    if (Ee)
        Cu = function(c, u) {
            for (var v = u.child; v !== null; ) {
                if (v.tag === 5 || v.tag === 6)
                    I(c, v.stateNode);
                else if (v.tag !== 4 && v.child !== null) {
                    v.child.return = v,
                    v = v.child;
                    continue
                }
                if (v === u)
                    break;
                for (; v.sibling === null; ) {
                    if (v.return === null || v.return === u)
                        return;
                    v = v.return
                }
                v.sibling.return = v.return,
                v = v.sibling
            }
        }
        ,
        bu = function() {}
        ,
        mh = function(c, u, v, x, E) {
            if (c = c.memoizedProps,
            c !== x) {
                var R = u.stateNode
                  , W = fs(or.current);
                v = O(R, v, c, x, E, W),
                (u.updateQueue = v) && hs(u)
            }
        }
        ,
        gh = function(c, u, v, x) {
            v !== x && hs(u)
        }
        ;
    else if (se) {
        Cu = function(c, u, v, x) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var R = E.stateNode;
                    v && x && (R = bt(R, E.type, E.memoizedProps, E)),
                    I(c, R)
                } else if (E.tag === 6)
                    R = E.stateNode,
                    v && x && (R = qt(R, E.memoizedProps, E)),
                    I(c, R);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        R = E.child,
                        R !== null && (R.return = E),
                        Cu(c, E, !0, !0);
                    else if (E.child !== null) {
                        E.child.return = E,
                        E = E.child;
                        continue
                    }
                }
                if (E === u)
                    break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u)
                        return;
                    E = E.return
                }
                E.sibling.return = E.return,
                E = E.sibling
            }
        }
        ;
        var dM = function(c, u, v, x) {
            for (var E = u.child; E !== null; ) {
                if (E.tag === 5) {
                    var R = E.stateNode;
                    v && x && (R = bt(R, E.type, E.memoizedProps, E)),
                    it(c, R)
                } else if (E.tag === 6)
                    R = E.stateNode,
                    v && x && (R = qt(R, E.memoizedProps, E)),
                    it(c, R);
                else if (E.tag !== 4) {
                    if (E.tag === 22 && E.memoizedState !== null)
                        R = E.child,
                        R !== null && (R.return = E),
                        dM(c, E, !0, !0);
                    else if (E.child !== null) {
                        E.child.return = E,
                        E = E.child;
                        continue
                    }
                }
                if (E === u)
                    break;
                for (; E.sibling === null; ) {
                    if (E.return === null || E.return === u)
                        return;
                    E = E.return
                }
                E.sibling.return = E.return,
                E = E.sibling
            }
        };
        bu = function(c, u) {
            var v = u.stateNode;
            if (!fM(c, u)) {
                c = v.containerInfo;
                var x = Ge(c);
                dM(x, u, !1, !1),
                v.pendingChildren = x,
                hs(u),
                Dt(c, x)
            }
        }
        ,
        mh = function(c, u, v, x, E) {
            var R = c.stateNode
              , W = c.memoizedProps;
            if ((c = fM(c, u)) && W === x)
                u.stateNode = R;
            else {
                var ne = u.stateNode
                  , ye = fs(or.current)
                  , Ue = null;
                W !== x && (Ue = O(ne, v, W, x, E, ye)),
                c && Ue === null ? u.stateNode = R : (R = Pe(R, Ue, v, W, x, u, c, ne),
                U(R, v, x, E, ye) && hs(u),
                u.stateNode = R,
                c ? hs(u) : Cu(R, u, !1, !1))
            }
        }
        ,
        gh = function(c, u, v, x) {
            v !== x ? (c = fs(El.current),
            v = fs(or.current),
            u.stateNode = F(x, c, v, u),
            hs(u)) : u.stateNode = c.stateNode
        }
    } else
        bu = function() {}
        ,
        mh = function() {}
        ,
        gh = function() {}
        ;
    function Pu(c, u) {
        if (!an)
            switch (c.tailMode) {
            case "hidden":
                u = c.tail;
                for (var v = null; u !== null; )
                    u.alternate !== null && (v = u),
                    u = u.sibling;
                v === null ? c.tail = null : v.sibling = null;
                break;
            case "collapsed":
                v = c.tail;
                for (var x = null; v !== null; )
                    v.alternate !== null && (x = v),
                    v = v.sibling;
                x === null ? u || c.tail === null ? c.tail = null : c.tail.sibling = null : x.sibling = null
            }
    }
    function oi(c) {
        var u = c.alternate !== null && c.alternate.child === c.child
          , v = 0
          , x = 0;
        if (u)
            for (var E = c.child; E !== null; )
                v |= E.lanes | E.childLanes,
                x |= E.subtreeFlags & 14680064,
                x |= E.flags & 14680064,
                E.return = c,
                E = E.sibling;
        else
            for (E = c.child; E !== null; )
                v |= E.lanes | E.childLanes,
                x |= E.subtreeFlags,
                x |= E.flags,
                E.return = c,
                E = E.sibling;
        return c.subtreeFlags |= x,
        c.childLanes = v,
        u
    }
    function V3(c, u, v) {
        var x = u.pendingProps;
        switch (G0(u),
        u.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return oi(u),
            null;
        case 1:
            return Zn(u.type) && Xd(),
            oi(u),
            null;
        case 3:
            return x = u.stateNode,
            Tl(),
            Gt(Yt),
            Gt(An),
            K0(),
            x.pendingContext && (x.context = x.pendingContext,
            x.pendingContext = null),
            (c === null || c.child === null) && (xu(u) ? hs(u) : c === null || c.memoizedState.isDehydrated && !(u.flags & 256) || (u.flags |= 1024,
            Dr !== null && (Tv(Dr),
            Dr = null))),
            bu(c, u),
            oi(u),
            null;
        case 5:
            Y0(u),
            v = fs(El.current);
            var E = u.type;
            if (c !== null && u.stateNode != null)
                mh(c, u, E, x, v),
                c.ref !== u.ref && (u.flags |= 512,
                u.flags |= 2097152);
            else {
                if (!x) {
                    if (u.stateNode === null)
                        throw Error(o(166));
                    return oi(u),
                    null
                }
                if (c = fs(or.current),
                xu(u)) {
                    if (!oe)
                        throw Error(o(175));
                    c = Ae(u.stateNode, u.type, u.memoizedProps, v, c, u, !_u),
                    u.updateQueue = c,
                    c !== null && hs(u)
                } else {
                    var R = ue(E, x, v, c, u);
                    Cu(R, u, !1, !1),
                    u.stateNode = R,
                    U(R, E, x, v, c) && hs(u)
                }
                u.ref !== null && (u.flags |= 512,
                u.flags |= 2097152)
            }
            return oi(u),
            null;
        case 6:
            if (c && u.stateNode != null)
                gh(c, u, c.memoizedProps, x);
            else {
                if (typeof x != "string" && u.stateNode === null)
                    throw Error(o(166));
                if (c = fs(El.current),
                v = fs(or.current),
                xu(u)) {
                    if (!oe)
                        throw Error(o(176));
                    if (c = u.stateNode,
                    x = u.memoizedProps,
                    (v = rt(c, x, u, !_u)) && (E = Bi,
                    E !== null))
                        switch (R = (E.mode & 1) !== 0,
                        E.tag) {
                        case 3:
                            Kn(E.stateNode.containerInfo, c, x, R);
                            break;
                        case 5:
                            zi(E.type, E.memoizedProps, E.stateNode, c, x, R)
                        }
                    v && hs(u)
                } else
                    u.stateNode = F(x, c, v, u)
            }
            return oi(u),
            null;
        case 13:
            if (Gt(un),
            x = u.memoizedState,
            an && Vi !== null && u.mode & 1 && !(u.flags & 128)) {
                for (c = Vi; c; )
                    c = V(c);
                return wl(),
                u.flags |= 98560,
                u
            }
            if (x !== null && x.dehydrated !== null) {
                if (x = xu(u),
                c === null) {
                    if (!x)
                        throw Error(o(318));
                    if (!oe)
                        throw Error(o(344));
                    if (c = u.memoizedState,
                    c = c !== null ? c.dehydrated : null,
                    !c)
                        throw Error(o(317));
                    at(c, u)
                } else
                    wl(),
                    !(u.flags & 128) && (u.memoizedState = null),
                    u.flags |= 4;
                return oi(u),
                null
            }
            return Dr !== null && (Tv(Dr),
            Dr = null),
            u.flags & 128 ? (u.lanes = v,
            u) : (x = x !== null,
            v = !1,
            c === null ? xu(u) : v = c.memoizedState !== null,
            x && !v && (u.child.flags |= 8192,
            u.mode & 1 && (c === null || un.current & 1 ? Un === 0 && (Un = 3) : Rv())),
            u.updateQueue !== null && (u.flags |= 4),
            oi(u),
            null);
        case 4:
            return Tl(),
            bu(c, u),
            c === null && Ce(u.stateNode.containerInfo),
            oi(u),
            null;
        case 10:
            return O0(u.type._context),
            oi(u),
            null;
        case 17:
            return Zn(u.type) && Xd(),
            oi(u),
            null;
        case 19:
            if (Gt(un),
            E = u.memoizedState,
            E === null)
                return oi(u),
                null;
            if (x = (u.flags & 128) !== 0,
            R = E.rendering,
            R === null)
                if (x)
                    Pu(E, !1);
                else {
                    if (Un !== 0 || c !== null && c.flags & 128)
                        for (c = u.child; c !== null; ) {
                            if (R = ah(c),
                            R !== null) {
                                for (u.flags |= 128,
                                Pu(E, !1),
                                c = R.updateQueue,
                                c !== null && (u.updateQueue = c,
                                u.flags |= 4),
                                u.subtreeFlags = 0,
                                c = v,
                                x = u.child; x !== null; )
                                    v = x,
                                    E = c,
                                    v.flags &= 14680066,
                                    R = v.alternate,
                                    R === null ? (v.childLanes = 0,
                                    v.lanes = E,
                                    v.child = null,
                                    v.subtreeFlags = 0,
                                    v.memoizedProps = null,
                                    v.memoizedState = null,
                                    v.updateQueue = null,
                                    v.dependencies = null,
                                    v.stateNode = null) : (v.childLanes = R.childLanes,
                                    v.lanes = R.lanes,
                                    v.child = R.child,
                                    v.subtreeFlags = 0,
                                    v.deletions = null,
                                    v.memoizedProps = R.memoizedProps,
                                    v.memoizedState = R.memoizedState,
                                    v.updateQueue = R.updateQueue,
                                    v.type = R.type,
                                    E = R.dependencies,
                                    v.dependencies = E === null ? null : {
                                        lanes: E.lanes,
                                        firstContext: E.firstContext
                                    }),
                                    x = x.sibling;
                                return gt(un, un.current & 1 | 2),
                                u.child
                            }
                            c = c.sibling
                        }
                    E.tail !== null && Hn() > Sv && (u.flags |= 128,
                    x = !0,
                    Pu(E, !1),
                    u.lanes = 4194304)
                }
            else {
                if (!x)
                    if (c = ah(R),
                    c !== null) {
                        if (u.flags |= 128,
                        x = !0,
                        c = c.updateQueue,
                        c !== null && (u.updateQueue = c,
                        u.flags |= 4),
                        Pu(E, !0),
                        E.tail === null && E.tailMode === "hidden" && !R.alternate && !an)
                            return oi(u),
                            null
                    } else
                        2 * Hn() - E.renderingStartTime > Sv && v !== 1073741824 && (u.flags |= 128,
                        x = !0,
                        Pu(E, !1),
                        u.lanes = 4194304);
                E.isBackwards ? (R.sibling = u.child,
                u.child = R) : (c = E.last,
                c !== null ? c.sibling = R : u.child = R,
                E.last = R)
            }
            return E.tail !== null ? (u = E.tail,
            E.rendering = u,
            E.tail = u.sibling,
            E.renderingStartTime = Hn(),
            u.sibling = null,
            c = un.current,
            gt(un, x ? c & 1 | 2 : c & 1),
            u) : (oi(u),
            null);
        case 22:
        case 23:
            return Av(),
            x = u.memoizedState !== null,
            c !== null && c.memoizedState !== null !== x && (u.flags |= 8192),
            x && u.mode & 1 ? Gi & 1073741824 && (oi(u),
            Ee && u.subtreeFlags & 6 && (u.flags |= 8192)) : oi(u),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(o(156, u.tag))
    }
    var H3 = a.ReactCurrentOwner
      , Hi = !1;
    function mi(c, u, v, x) {
        u.child = c === null ? Bw(u, null, v, x) : Ml(u, c.child, v, x)
    }
    function hM(c, u, v, x, E) {
        v = v.render;
        var R = u.ref;
        return _l(u, E),
        x = Q0(c, u, v, x, R, E),
        v = J0(),
        c !== null && !Hi ? (u.updateQueue = c.updateQueue,
        u.flags &= -2053,
        c.lanes &= ~E,
        Ns(c, u, E)) : (an && v && H0(u),
        u.flags |= 1,
        mi(c, u, x, E),
        u.child)
    }
    function pM(c, u, v, x, E) {
        if (c === null) {
            var R = v.type;
            return typeof R == "function" && !Cv(R) && R.defaultProps === void 0 && v.compare === null && v.defaultProps === void 0 ? (u.tag = 15,
            u.type = R,
            mM(c, u, R, x, E)) : (c = Oh(v.type, null, x, u, u.mode, E),
            c.ref = u.ref,
            c.return = u,
            u.child = c)
        }
        if (R = c.child,
        !(c.lanes & E)) {
            var W = R.memoizedProps;
            if (v = v.compare,
            v = v !== null ? v : Qd,
            v(W, x) && c.ref === u.ref)
                return Ns(c, u, E)
        }
        return u.flags |= 1,
        c = go(R, x),
        c.ref = u.ref,
        c.return = u,
        u.child = c
    }
    function mM(c, u, v, x, E) {
        if (c !== null && Qd(c.memoizedProps, x) && c.ref === u.ref)
            if (Hi = !1,
            (c.lanes & E) !== 0)
                c.flags & 131072 && (Hi = !0);
            else
                return u.lanes = c.lanes,
                Ns(c, u, E);
        return sv(c, u, v, x, E)
    }
    function gM(c, u, v) {
        var x = u.pendingProps
          , E = x.children
          , R = c !== null ? c.memoizedState : null;
        if (x.mode === "hidden")
            if (!(u.mode & 1))
                u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                gt(Rl, Gi),
                Gi |= v;
            else if (v & 1073741824)
                u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                x = R !== null ? R.baseLanes : v,
                gt(Rl, Gi),
                Gi |= x;
            else
                return c = R !== null ? R.baseLanes | v : v,
                u.lanes = u.childLanes = 1073741824,
                u.memoizedState = {
                    baseLanes: c,
                    cachePool: null
                },
                u.updateQueue = null,
                gt(Rl, Gi),
                Gi |= c,
                null;
        else
            R !== null ? (x = R.baseLanes | v,
            u.memoizedState = null) : x = v,
            gt(Rl, Gi),
            Gi |= x;
        return mi(c, u, E, v),
        u.child
    }
    function vM(c, u) {
        var v = u.ref;
        (c === null && v !== null || c !== null && c.ref !== v) && (u.flags |= 512,
        u.flags |= 2097152)
    }
    function sv(c, u, v, x, E) {
        var R = Zn(v) ? Lr : An.current;
        return R = lo(u, R),
        _l(u, E),
        v = Q0(c, u, v, x, R, E),
        x = J0(),
        c !== null && !Hi ? (u.updateQueue = c.updateQueue,
        u.flags &= -2053,
        c.lanes &= ~E,
        Ns(c, u, E)) : (an && x && H0(u),
        u.flags |= 1,
        mi(c, u, v, E),
        u.child)
    }
    function yM(c, u, v, x, E) {
        if (Zn(v)) {
            var R = !0;
            $d(u)
        } else
            R = !1;
        if (_l(u, E),
        u.stateNode === null)
            c !== null && (c.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            Iw(u, v, x),
            V0(u, v, x, E),
            x = !0;
        else if (c === null) {
            var W = u.stateNode
              , ne = u.memoizedProps;
            W.props = ne;
            var ye = W.context
              , Ue = v.contextType;
            typeof Ue == "object" && Ue !== null ? Ue = ir(Ue) : (Ue = Zn(v) ? Lr : An.current,
            Ue = lo(u, Ue));
            var Ke = v.getDerivedStateFromProps
              , dt = typeof Ke == "function" || typeof W.getSnapshotBeforeUpdate == "function";
            dt || typeof W.UNSAFE_componentWillReceiveProps != "function" && typeof W.componentWillReceiveProps != "function" || (ne !== x || ye !== Ue) && Nw(u, W, x, Ue),
            co = !1;
            var ot = u.memoizedState;
            W.state = ot,
            nh(u, x, W, E),
            ye = u.memoizedState,
            ne !== x || ot !== ye || Yt.current || co ? (typeof Ke == "function" && (B0(u, v, Ke, x),
            ye = u.memoizedState),
            (ne = co || Lw(u, v, ne, x, ot, ye, Ue)) ? (dt || typeof W.UNSAFE_componentWillMount != "function" && typeof W.componentWillMount != "function" || (typeof W.componentWillMount == "function" && W.componentWillMount(),
            typeof W.UNSAFE_componentWillMount == "function" && W.UNSAFE_componentWillMount()),
            typeof W.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof W.componentDidMount == "function" && (u.flags |= 4194308),
            u.memoizedProps = x,
            u.memoizedState = ye),
            W.props = x,
            W.state = ye,
            W.context = Ue,
            x = ne) : (typeof W.componentDidMount == "function" && (u.flags |= 4194308),
            x = !1)
        } else {
            W = u.stateNode,
            Rw(c, u),
            ne = u.memoizedProps,
            Ue = u.type === u.elementType ? ne : Nr(u.type, ne),
            W.props = Ue,
            dt = u.pendingProps,
            ot = W.context,
            ye = v.contextType,
            typeof ye == "object" && ye !== null ? ye = ir(ye) : (ye = Zn(v) ? Lr : An.current,
            ye = lo(u, ye));
            var Kt = v.getDerivedStateFromProps;
            (Ke = typeof Kt == "function" || typeof W.getSnapshotBeforeUpdate == "function") || typeof W.UNSAFE_componentWillReceiveProps != "function" && typeof W.componentWillReceiveProps != "function" || (ne !== dt || ot !== ye) && Nw(u, W, x, ye),
            co = !1,
            ot = u.memoizedState,
            W.state = ot,
            nh(u, x, W, E);
            var nt = u.memoizedState;
            ne !== dt || ot !== nt || Yt.current || co ? (typeof Kt == "function" && (B0(u, v, Kt, x),
            nt = u.memoizedState),
            (Ue = co || Lw(u, v, Ue, x, ot, nt, ye) || !1) ? (Ke || typeof W.UNSAFE_componentWillUpdate != "function" && typeof W.componentWillUpdate != "function" || (typeof W.componentWillUpdate == "function" && W.componentWillUpdate(x, nt, ye),
            typeof W.UNSAFE_componentWillUpdate == "function" && W.UNSAFE_componentWillUpdate(x, nt, ye)),
            typeof W.componentDidUpdate == "function" && (u.flags |= 4),
            typeof W.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof W.componentDidUpdate != "function" || ne === c.memoizedProps && ot === c.memoizedState || (u.flags |= 4),
            typeof W.getSnapshotBeforeUpdate != "function" || ne === c.memoizedProps && ot === c.memoizedState || (u.flags |= 1024),
            u.memoizedProps = x,
            u.memoizedState = nt),
            W.props = x,
            W.state = nt,
            W.context = ye,
            x = Ue) : (typeof W.componentDidUpdate != "function" || ne === c.memoizedProps && ot === c.memoizedState || (u.flags |= 4),
            typeof W.getSnapshotBeforeUpdate != "function" || ne === c.memoizedProps && ot === c.memoizedState || (u.flags |= 1024),
            x = !1)
        }
        return ov(c, u, v, x, R, E)
    }
    function ov(c, u, v, x, E, R) {
        vM(c, u);
        var W = (u.flags & 128) !== 0;
        if (!x && !W)
            return E && ww(u, v, !1),
            Ns(c, u, R);
        x = u.stateNode,
        H3.current = u;
        var ne = W && typeof v.getDerivedStateFromError != "function" ? null : x.render();
        return u.flags |= 1,
        c !== null && W ? (u.child = Ml(u, c.child, null, R),
        u.child = Ml(u, null, ne, R)) : mi(c, u, ne, R),
        u.memoizedState = x.state,
        E && ww(u, v, !0),
        u.child
    }
    function _M(c) {
        var u = c.stateNode;
        u.pendingContext ? xw(c, u.pendingContext, u.pendingContext !== u.context) : u.context && xw(c, u.context, !1),
        j0(c, u.containerInfo)
    }
    function xM(c, u, v, x, E) {
        return wl(),
        $0(E),
        u.flags |= 256,
        mi(c, u, v, x),
        u.child
    }
    var vh = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function yh(c) {
        return {
            baseLanes: c,
            cachePool: null
        }
    }
    function SM(c, u, v) {
        var x = u.pendingProps, E = un.current, R = !1, W = (u.flags & 128) !== 0, ne;
        if ((ne = W) || (ne = c !== null && c.memoizedState === null ? !1 : (E & 2) !== 0),
        ne ? (R = !0,
        u.flags &= -129) : (c === null || c.memoizedState !== null) && (E |= 1),
        gt(un, E & 1),
        c === null)
            return X0(u),
            c = u.memoizedState,
            c !== null && (c = c.dehydrated,
            c !== null) ? (u.mode & 1 ? gu(c) ? u.lanes = 8 : u.lanes = 1073741824 : u.lanes = 1,
            null) : (E = x.children,
            c = x.fallback,
            R ? (x = u.mode,
            R = u.child,
            E = {
                mode: "hidden",
                children: E
            },
            !(x & 1) && R !== null ? (R.childLanes = 0,
            R.pendingProps = E) : R = Fh(E, x, 0, null),
            c = va(c, x, v, null),
            R.return = u,
            c.return = u,
            R.sibling = c,
            u.child = R,
            u.child.memoizedState = yh(v),
            u.memoizedState = vh,
            c) : av(u, E));
        if (E = c.memoizedState,
        E !== null) {
            if (ne = E.dehydrated,
            ne !== null) {
                if (W)
                    return u.flags & 256 ? (u.flags &= -257,
                    _h(c, u, v, Error(o(422)))) : u.memoizedState !== null ? (u.child = c.child,
                    u.flags |= 128,
                    null) : (R = x.fallback,
                    E = u.mode,
                    x = Fh({
                        mode: "visible",
                        children: x.children
                    }, E, 0, null),
                    R = va(R, E, v, null),
                    R.flags |= 2,
                    x.return = u,
                    R.return = u,
                    x.sibling = R,
                    u.child = x,
                    u.mode & 1 && Ml(u, c.child, null, v),
                    u.child.memoizedState = yh(v),
                    u.memoizedState = vh,
                    R);
                if (!(u.mode & 1))
                    u = _h(c, u, v, null);
                else if (gu(ne))
                    u = _h(c, u, v, Error(o(419)));
                else if (x = (v & c.childLanes) !== 0,
                Hi || x) {
                    if (x = Rn,
                    x !== null) {
                        switch (v & -v) {
                        case 4:
                            R = 2;
                            break;
                        case 16:
                            R = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            R = 32;
                            break;
                        case 536870912:
                            R = 268435456;
                            break;
                        default:
                            R = 0
                        }
                        x = R & (x.suspendedLanes | v) ? 0 : R,
                        x !== 0 && x !== E.retryLane && (E.retryLane = x,
                        lr(c, x, -1))
                    }
                    Rv(),
                    u = _h(c, u, v, Error(o(421)))
                } else
                    os(ne) ? (u.flags |= 128,
                    u.child = c.child,
                    u = tN.bind(null, c),
                    R0(ne, u),
                    u = null) : (v = E.treeContext,
                    oe && (Vi = ce(ne),
                    Bi = u,
                    an = !0,
                    Dr = null,
                    _u = !1,
                    v !== null && (rr[sr++] = Ps,
                    rr[sr++] = Ls,
                    rr[sr++] = ca,
                    Ps = v.id,
                    Ls = v.overflow,
                    ca = u)),
                    u = av(u, u.pendingProps.children),
                    u.flags |= 4096);
                return u
            }
            return R ? (x = MM(c, u, x.children, x.fallback, v),
            R = u.child,
            E = c.child.memoizedState,
            R.memoizedState = E === null ? yh(v) : {
                baseLanes: E.baseLanes | v,
                cachePool: null
            },
            R.childLanes = c.childLanes & ~v,
            u.memoizedState = vh,
            x) : (v = wM(c, u, x.children, v),
            u.memoizedState = null,
            v)
        }
        return R ? (x = MM(c, u, x.children, x.fallback, v),
        R = u.child,
        E = c.child.memoizedState,
        R.memoizedState = E === null ? yh(v) : {
            baseLanes: E.baseLanes | v,
            cachePool: null
        },
        R.childLanes = c.childLanes & ~v,
        u.memoizedState = vh,
        x) : (v = wM(c, u, x.children, v),
        u.memoizedState = null,
        v)
    }
    function av(c, u) {
        return u = Fh({
            mode: "visible",
            children: u
        }, c.mode, 0, null),
        u.return = c,
        c.child = u
    }
    function wM(c, u, v, x) {
        var E = c.child;
        return c = E.sibling,
        v = go(E, {
            mode: "visible",
            children: v
        }),
        !(u.mode & 1) && (v.lanes = x),
        v.return = u,
        v.sibling = null,
        c !== null && (x = u.deletions,
        x === null ? (u.deletions = [c],
        u.flags |= 16) : x.push(c)),
        u.child = v
    }
    function MM(c, u, v, x, E) {
        var R = u.mode;
        c = c.child;
        var W = c.sibling
          , ne = {
            mode: "hidden",
            children: v
        };
        return !(R & 1) && u.child !== c ? (v = u.child,
        v.childLanes = 0,
        v.pendingProps = ne,
        u.deletions = null) : (v = go(c, ne),
        v.subtreeFlags = c.subtreeFlags & 14680064),
        W !== null ? x = go(W, x) : (x = va(x, R, E, null),
        x.flags |= 2),
        x.return = u,
        v.return = u,
        v.sibling = x,
        u.child = v,
        x
    }
    function _h(c, u, v, x) {
        return x !== null && $0(x),
        Ml(u, c.child, null, v),
        c = av(u, u.pendingProps.children),
        c.flags |= 2,
        u.memoizedState = null,
        c
    }
    function EM(c, u, v) {
        c.lanes |= u;
        var x = c.alternate;
        x !== null && (x.lanes |= u),
        F0(c.return, u, v)
    }
    function lv(c, u, v, x, E) {
        var R = c.memoizedState;
        R === null ? c.memoizedState = {
            isBackwards: u,
            rendering: null,
            renderingStartTime: 0,
            last: x,
            tail: v,
            tailMode: E
        } : (R.isBackwards = u,
        R.rendering = null,
        R.renderingStartTime = 0,
        R.last = x,
        R.tail = v,
        R.tailMode = E)
    }
    function TM(c, u, v) {
        var x = u.pendingProps
          , E = x.revealOrder
          , R = x.tail;
        if (mi(c, u, x.children, v),
        x = un.current,
        x & 2)
            x = x & 1 | 2,
            u.flags |= 128;
        else {
            if (c !== null && c.flags & 128)
                e: for (c = u.child; c !== null; ) {
                    if (c.tag === 13)
                        c.memoizedState !== null && EM(c, v, u);
                    else if (c.tag === 19)
                        EM(c, v, u);
                    else if (c.child !== null) {
                        c.child.return = c,
                        c = c.child;
                        continue
                    }
                    if (c === u)
                        break e;
                    for (; c.sibling === null; ) {
                        if (c.return === null || c.return === u)
                            break e;
                        c = c.return
                    }
                    c.sibling.return = c.return,
                    c = c.sibling
                }
            x &= 1
        }
        if (gt(un, x),
        !(u.mode & 1))
            u.memoizedState = null;
        else
            switch (E) {
            case "forwards":
                for (v = u.child,
                E = null; v !== null; )
                    c = v.alternate,
                    c !== null && ah(c) === null && (E = v),
                    v = v.sibling;
                v = E,
                v === null ? (E = u.child,
                u.child = null) : (E = v.sibling,
                v.sibling = null),
                lv(u, !1, E, v, R);
                break;
            case "backwards":
                for (v = null,
                E = u.child,
                u.child = null; E !== null; ) {
                    if (c = E.alternate,
                    c !== null && ah(c) === null) {
                        u.child = E;
                        break
                    }
                    c = E.sibling,
                    E.sibling = v,
                    v = E,
                    E = c
                }
                lv(u, !0, v, null, R);
                break;
            case "together":
                lv(u, !1, null, null, void 0);
                break;
            default:
                u.memoizedState = null
            }
        return u.child
    }
    function Ns(c, u, v) {
        if (c !== null && (u.dependencies = c.dependencies),
        Cl |= u.lanes,
        !(v & u.childLanes))
            return null;
        if (c !== null && u.child !== c.child)
            throw Error(o(153));
        if (u.child !== null) {
            for (c = u.child,
            v = go(c, c.pendingProps),
            u.child = v,
            v.return = u; c.sibling !== null; )
                c = c.sibling,
                v = v.sibling = go(c, c.pendingProps),
                v.return = u;
            v.sibling = null
        }
        return u.child
    }
    function G3(c, u, v) {
        switch (u.tag) {
        case 3:
            _M(u),
            wl();
            break;
        case 5:
            Vw(u);
            break;
        case 1:
            Zn(u.type) && $d(u);
            break;
        case 4:
            j0(u, u.stateNode.containerInfo);
            break;
        case 10:
            Aw(u, u.type._context, u.memoizedProps.value);
            break;
        case 13:
            var x = u.memoizedState;
            if (x !== null)
                return x.dehydrated !== null ? (gt(un, un.current & 1),
                u.flags |= 128,
                null) : v & u.child.childLanes ? SM(c, u, v) : (gt(un, un.current & 1),
                c = Ns(c, u, v),
                c !== null ? c.sibling : null);
            gt(un, un.current & 1);
            break;
        case 19:
            if (x = (v & u.childLanes) !== 0,
            c.flags & 128) {
                if (x)
                    return TM(c, u, v);
                u.flags |= 128
            }
            var E = u.memoizedState;
            if (E !== null && (E.rendering = null,
            E.tail = null,
            E.lastEffect = null),
            gt(un, un.current),
            x)
                break;
            return null;
        case 22:
        case 23:
            return u.lanes = 0,
            gM(c, u, v)
        }
        return Ns(c, u, v)
    }
    function W3(c, u) {
        switch (G0(u),
        u.tag) {
        case 1:
            return Zn(u.type) && Xd(),
            c = u.flags,
            c & 65536 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 3:
            return Tl(),
            Gt(Yt),
            Gt(An),
            K0(),
            c = u.flags,
            c & 65536 && !(c & 128) ? (u.flags = c & -65537 | 128,
            u) : null;
        case 5:
            return Y0(u),
            null;
        case 13:
            if (Gt(un),
            c = u.memoizedState,
            c !== null && c.dehydrated !== null) {
                if (u.alternate === null)
                    throw Error(o(340));
                wl()
            }
            return c = u.flags,
            c & 65536 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 19:
            return Gt(un),
            null;
        case 4:
            return Tl(),
            null;
        case 10:
            return O0(u.type._context),
            null;
        case 22:
        case 23:
            return Av(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var xh = !1
      , da = !1
      , X3 = typeof WeakSet == "function" ? WeakSet : Set
      , Ve = null;
    function Sh(c, u) {
        var v = c.ref;
        if (v !== null)
            if (typeof v == "function")
                try {
                    v(null)
                } catch (x) {
                    Ri(c, u, x)
                }
            else
                v.current = null
    }
    function cv(c, u, v) {
        try {
            v()
        } catch (x) {
            Ri(c, u, x)
        }
    }
    var AM = !1;
    function $3(c, u) {
        for (j(c.containerInfo),
        Ve = u; Ve !== null; )
            if (c = Ve,
            u = c.child,
            (c.subtreeFlags & 1028) !== 0 && u !== null)
                u.return = c,
                Ve = u;
            else
                for (; Ve !== null; ) {
                    c = Ve;
                    try {
                        var v = c.alternate;
                        if (c.flags & 1024)
                            switch (c.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (v !== null) {
                                    var x = v.memoizedProps
                                      , E = v.memoizedState
                                      , R = c.stateNode
                                      , W = R.getSnapshotBeforeUpdate(c.elementType === c.type ? x : Nr(c.type, x), E);
                                    R.__reactInternalSnapshotBeforeUpdate = W
                                }
                                break;
                            case 3:
                                Ee && Te(c.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                            }
                    } catch (ne) {
                        Ri(c, c.return, ne)
                    }
                    if (u = c.sibling,
                    u !== null) {
                        u.return = c.return,
                        Ve = u;
                        break
                    }
                    Ve = c.return
                }
        return v = AM,
        AM = !1,
        v
    }
    function ha(c, u, v) {
        var x = u.updateQueue;
        if (x = x !== null ? x.lastEffect : null,
        x !== null) {
            var E = x = x.next;
            do {
                if ((E.tag & c) === c) {
                    var R = E.destroy;
                    E.destroy = void 0,
                    R !== void 0 && cv(u, v, R)
                }
                E = E.next
            } while (E !== x)
        }
    }
    function Lu(c, u) {
        if (u = u.updateQueue,
        u = u !== null ? u.lastEffect : null,
        u !== null) {
            var v = u = u.next;
            do {
                if ((v.tag & c) === c) {
                    var x = v.create;
                    v.destroy = x()
                }
                v = v.next
            } while (v !== u)
        }
    }
    function uv(c) {
        var u = c.ref;
        if (u !== null) {
            var v = c.stateNode;
            switch (c.tag) {
            case 5:
                c = fe(v);
                break;
            default:
                c = v
            }
            typeof u == "function" ? u(c) : u.current = c
        }
    }
    function RM(c, u, v) {
        if (as && typeof as.onCommitFiberUnmount == "function")
            try {
                as.onCommitFiberUnmount(Kd, u)
            } catch {}
        switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (c = u.updateQueue,
            c !== null && (c = c.lastEffect,
            c !== null)) {
                var x = c = c.next;
                do {
                    var E = x
                      , R = E.destroy;
                    E = E.tag,
                    R !== void 0 && (E & 2 || E & 4) && cv(u, v, R),
                    x = x.next
                } while (x !== c)
            }
            break;
        case 1:
            if (Sh(u, v),
            c = u.stateNode,
            typeof c.componentWillUnmount == "function")
                try {
                    c.props = u.memoizedProps,
                    c.state = u.memoizedState,
                    c.componentWillUnmount()
                } catch (W) {
                    Ri(u, v, W)
                }
            break;
        case 5:
            Sh(u, v);
            break;
        case 4:
            Ee ? NM(c, u, v) : se && se && (u = u.stateNode.containerInfo,
            v = Ge(u),
            Bt(u, v))
        }
    }
    function CM(c, u, v) {
        for (var x = u; ; )
            if (RM(c, x, v),
            x.child === null || Ee && x.tag === 4) {
                if (x === u)
                    break;
                for (; x.sibling === null; ) {
                    if (x.return === null || x.return === u)
                        return;
                    x = x.return
                }
                x.sibling.return = x.return,
                x = x.sibling
            } else
                x.child.return = x,
                x = x.child
    }
    function bM(c) {
        var u = c.alternate;
        u !== null && (c.alternate = null,
        bM(u)),
        c.child = null,
        c.deletions = null,
        c.sibling = null,
        c.tag === 5 && (u = c.stateNode,
        u !== null && Le(u)),
        c.stateNode = null,
        c.return = null,
        c.dependencies = null,
        c.memoizedProps = null,
        c.memoizedState = null,
        c.pendingProps = null,
        c.stateNode = null,
        c.updateQueue = null
    }
    function PM(c) {
        return c.tag === 5 || c.tag === 3 || c.tag === 4
    }
    function LM(c) {
        e: for (; ; ) {
            for (; c.sibling === null; ) {
                if (c.return === null || PM(c.return))
                    return null;
                c = c.return
            }
            for (c.sibling.return = c.return,
            c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
                if (c.flags & 2 || c.child === null || c.tag === 4)
                    continue e;
                c.child.return = c,
                c = c.child
            }
            if (!(c.flags & 2))
                return c.stateNode
        }
    }
    function IM(c) {
        if (Ee) {
            e: {
                for (var u = c.return; u !== null; ) {
                    if (PM(u))
                        break e;
                    u = u.return
                }
                throw Error(o(160))
            }
            var v = u;
            switch (v.tag) {
            case 5:
                u = v.stateNode,
                v.flags & 32 && (xe(u),
                v.flags &= -33),
                v = LM(c),
                dv(c, v, u);
                break;
            case 3:
            case 4:
                u = v.stateNode.containerInfo,
                v = LM(c),
                fv(c, v, u);
                break;
            default:
                throw Error(o(161))
            }
        }
    }
    function fv(c, u, v) {
        var x = c.tag;
        if (x === 5 || x === 6)
            c = c.stateNode,
            u ? Xe(v, c, u) : We(v, c);
        else if (x !== 4 && (c = c.child,
        c !== null))
            for (fv(c, u, v),
            c = c.sibling; c !== null; )
                fv(c, u, v),
                c = c.sibling
    }
    function dv(c, u, v) {
        var x = c.tag;
        if (x === 5 || x === 6)
            c = c.stateNode,
            u ? st(v, c, u) : Je(v, c);
        else if (x !== 4 && (c = c.child,
        c !== null))
            for (dv(c, u, v),
            c = c.sibling; c !== null; )
                dv(c, u, v),
                c = c.sibling
    }
    function NM(c, u, v) {
        for (var x = u, E = !1, R, W; ; ) {
            if (!E) {
                E = x.return;
                e: for (; ; ) {
                    if (E === null)
                        throw Error(o(160));
                    switch (R = E.stateNode,
                    E.tag) {
                    case 5:
                        W = !1;
                        break e;
                    case 3:
                        R = R.containerInfo,
                        W = !0;
                        break e;
                    case 4:
                        R = R.containerInfo,
                        W = !0;
                        break e
                    }
                    E = E.return
                }
                E = !0
            }
            if (x.tag === 5 || x.tag === 6)
                CM(c, x, v),
                W ? q(R, x.stateNode) : K(R, x.stateNode);
            else if (x.tag === 18)
                W ? Tt(R, x.stateNode) : Mt(R, x.stateNode);
            else if (x.tag === 4) {
                if (x.child !== null) {
                    R = x.stateNode.containerInfo,
                    W = !0,
                    x.child.return = x,
                    x = x.child;
                    continue
                }
            } else if (RM(c, x, v),
            x.child !== null) {
                x.child.return = x,
                x = x.child;
                continue
            }
            if (x === u)
                break;
            for (; x.sibling === null; ) {
                if (x.return === null || x.return === u)
                    return;
                x = x.return,
                x.tag === 4 && (E = !1)
            }
            x.sibling.return = x.return,
            x = x.sibling
        }
    }
    function hv(c, u) {
        if (Ee) {
            switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                ha(3, u, u.return),
                Lu(3, u),
                ha(5, u, u.return);
                return;
            case 1:
                return;
            case 5:
                var v = u.stateNode;
                if (v != null) {
                    var x = u.memoizedProps;
                    c = c !== null ? c.memoizedProps : x;
                    var E = u.type
                      , R = u.updateQueue;
                    u.updateQueue = null,
                    R !== null && tt(v, R, E, c, x, u)
                }
                return;
            case 6:
                if (u.stateNode === null)
                    throw Error(o(162));
                v = u.memoizedProps,
                Me(u.stateNode, c !== null ? c.memoizedProps : v, v);
                return;
            case 3:
                oe && c !== null && c.memoizedState.isDehydrated && mt(u.stateNode.containerInfo);
                return;
            case 12:
                return;
            case 13:
                wh(u);
                return;
            case 19:
                wh(u);
                return;
            case 17:
                return
            }
            throw Error(o(163))
        }
        switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            ha(3, u, u.return),
            Lu(3, u),
            ha(5, u, u.return);
            return;
        case 12:
            return;
        case 13:
            wh(u);
            return;
        case 19:
            wh(u);
            return;
        case 3:
            oe && c !== null && c.memoizedState.isDehydrated && mt(u.stateNode.containerInfo);
            break;
        case 22:
        case 23:
            return
        }
        e: if (se) {
            switch (u.tag) {
            case 1:
            case 5:
            case 6:
                break e;
            case 3:
            case 4:
                u = u.stateNode,
                Bt(u.containerInfo, u.pendingChildren);
                break e
            }
            throw Error(o(163))
        }
    }
    function wh(c) {
        var u = c.updateQueue;
        if (u !== null) {
            c.updateQueue = null;
            var v = c.stateNode;
            v === null && (v = c.stateNode = new X3),
            u.forEach(function(x) {
                var E = nN.bind(null, c, x);
                v.has(x) || (v.add(x),
                x.then(E, E))
            })
        }
    }
    function j3(c, u) {
        for (Ve = u; Ve !== null; ) {
            u = Ve;
            var v = u.deletions;
            if (v !== null)
                for (var x = 0; x < v.length; x++) {
                    var E = v[x];
                    try {
                        var R = c;
                        Ee ? NM(R, E, u) : CM(R, E, u);
                        var W = E.alternate;
                        W !== null && (W.return = null),
                        E.return = null
                    } catch (et) {
                        Ri(E, u, et)
                    }
                }
            if (v = u.child,
            u.subtreeFlags & 12854 && v !== null)
                v.return = u,
                Ve = v;
            else
                for (; Ve !== null; ) {
                    u = Ve;
                    try {
                        var ne = u.flags;
                        if (ne & 32 && Ee && xe(u.stateNode),
                        ne & 512) {
                            var ye = u.alternate;
                            if (ye !== null) {
                                var Ue = ye.ref;
                                Ue !== null && (typeof Ue == "function" ? Ue(null) : Ue.current = null)
                            }
                        }
                        if (ne & 8192)
                            switch (u.tag) {
                            case 13:
                                if (u.memoizedState !== null) {
                                    var Ke = u.alternate;
                                    (Ke === null || Ke.memoizedState === null) && (xv = Hn())
                                }
                                break;
                            case 22:
                                var dt = u.memoizedState !== null
                                  , ot = u.alternate
                                  , Kt = ot !== null && ot.memoizedState !== null;
                                if (v = u,
                                Ee) {
                                    e: if (x = v,
                                    E = dt,
                                    R = null,
                                    Ee)
                                        for (var nt = x; ; ) {
                                            if (nt.tag === 5) {
                                                if (R === null) {
                                                    R = nt;
                                                    var ai = nt.stateNode;
                                                    E ? Ne(ai) : te(nt.stateNode, nt.memoizedProps)
                                                }
                                            } else if (nt.tag === 6) {
                                                if (R === null) {
                                                    var ur = nt.stateNode;
                                                    E ? H(ur) : me(ur, nt.memoizedProps)
                                                }
                                            } else if ((nt.tag !== 22 && nt.tag !== 23 || nt.memoizedState === null || nt === x) && nt.child !== null) {
                                                nt.child.return = nt,
                                                nt = nt.child;
                                                continue
                                            }
                                            if (nt === x)
                                                break;
                                            for (; nt.sibling === null; ) {
                                                if (nt.return === null || nt.return === x)
                                                    break e;
                                                R === nt && (R = null),
                                                nt = nt.return
                                            }
                                            R === nt && (R = null),
                                            nt.sibling.return = nt.return,
                                            nt = nt.sibling
                                        }
                                }
                                if (dt && !Kt && v.mode & 1) {
                                    Ve = v;
                                    for (var de = v.child; de !== null; ) {
                                        for (v = Ve = de; Ve !== null; ) {
                                            x = Ve;
                                            var re = x.child;
                                            switch (x.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                ha(4, x, x.return);
                                                break;
                                            case 1:
                                                Sh(x, x.return);
                                                var ge = x.stateNode;
                                                if (typeof ge.componentWillUnmount == "function") {
                                                    var He = x.return;
                                                    try {
                                                        ge.props = x.memoizedProps,
                                                        ge.state = x.memoizedState,
                                                        ge.componentWillUnmount()
                                                    } catch (et) {
                                                        Ri(x, He, et)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                Sh(x, x.return);
                                                break;
                                            case 22:
                                                if (x.memoizedState !== null) {
                                                    kM(v);
                                                    continue
                                                }
                                            }
                                            re !== null ? (re.return = x,
                                            Ve = re) : kM(v)
                                        }
                                        de = de.sibling
                                    }
                                }
                            }
                        switch (ne & 4102) {
                        case 2:
                            IM(u),
                            u.flags &= -3;
                            break;
                        case 6:
                            IM(u),
                            u.flags &= -3,
                            hv(u.alternate, u);
                            break;
                        case 4096:
                            u.flags &= -4097;
                            break;
                        case 4100:
                            u.flags &= -4097,
                            hv(u.alternate, u);
                            break;
                        case 4:
                            hv(u.alternate, u)
                        }
                    } catch (et) {
                        Ri(u, u.return, et)
                    }
                    if (v = u.sibling,
                    v !== null) {
                        v.return = u.return,
                        Ve = v;
                        break
                    }
                    Ve = u.return
                }
        }
    }
    function Y3(c, u, v) {
        Ve = c,
        DM(c)
    }
    function DM(c, u, v) {
        for (var x = (c.mode & 1) !== 0; Ve !== null; ) {
            var E = Ve
              , R = E.child;
            if (E.tag === 22 && x) {
                var W = E.memoizedState !== null || xh;
                if (!W) {
                    var ne = E.alternate
                      , ye = ne !== null && ne.memoizedState !== null || da;
                    ne = xh;
                    var Ue = da;
                    if (xh = W,
                    (da = ye) && !Ue)
                        for (Ve = E; Ve !== null; )
                            W = Ve,
                            ye = W.child,
                            W.tag === 22 && W.memoizedState !== null ? OM(E) : ye !== null ? (ye.return = W,
                            Ve = ye) : OM(E);
                    for (; R !== null; )
                        Ve = R,
                        DM(R),
                        R = R.sibling;
                    Ve = E,
                    xh = ne,
                    da = Ue
                }
                UM(c)
            } else
                E.subtreeFlags & 8772 && R !== null ? (R.return = E,
                Ve = R) : UM(c)
        }
    }
    function UM(c) {
        for (; Ve !== null; ) {
            var u = Ve;
            if (u.flags & 8772) {
                var v = u.alternate;
                try {
                    if (u.flags & 8772)
                        switch (u.tag) {
                        case 0:
                        case 11:
                        case 15:
                            da || Lu(5, u);
                            break;
                        case 1:
                            var x = u.stateNode;
                            if (u.flags & 4 && !da)
                                if (v === null)
                                    x.componentDidMount();
                                else {
                                    var E = u.elementType === u.type ? v.memoizedProps : Nr(u.type, v.memoizedProps);
                                    x.componentDidUpdate(E, v.memoizedState, x.__reactInternalSnapshotBeforeUpdate)
                                }
                            var R = u.updateQueue;
                            R !== null && bw(u, R, x);
                            break;
                        case 3:
                            var W = u.updateQueue;
                            if (W !== null) {
                                if (v = null,
                                u.child !== null)
                                    switch (u.child.tag) {
                                    case 5:
                                        v = fe(u.child.stateNode);
                                        break;
                                    case 1:
                                        v = u.child.stateNode
                                    }
                                bw(u, W, v)
                            }
                            break;
                        case 5:
                            var ne = u.stateNode;
                            v === null && u.flags & 4 && Qe(ne, u.type, u.memoizedProps, u);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (oe && u.memoizedState === null) {
                                var ye = u.alternate;
                                if (ye !== null) {
                                    var Ue = ye.memoizedState;
                                    if (Ue !== null) {
                                        var Ke = Ue.dehydrated;
                                        Ke !== null && wt(Ke)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                        }
                    da || u.flags & 512 && uv(u)
                } catch (dt) {
                    Ri(u, u.return, dt)
                }
            }
            if (u === c) {
                Ve = null;
                break
            }
            if (v = u.sibling,
            v !== null) {
                v.return = u.return,
                Ve = v;
                break
            }
            Ve = u.return
        }
    }
    function kM(c) {
        for (; Ve !== null; ) {
            var u = Ve;
            if (u === c) {
                Ve = null;
                break
            }
            var v = u.sibling;
            if (v !== null) {
                v.return = u.return,
                Ve = v;
                break
            }
            Ve = u.return
        }
    }
    function OM(c) {
        for (; Ve !== null; ) {
            var u = Ve;
            try {
                switch (u.tag) {
                case 0:
                case 11:
                case 15:
                    var v = u.return;
                    try {
                        Lu(4, u)
                    } catch (ye) {
                        Ri(u, v, ye)
                    }
                    break;
                case 1:
                    var x = u.stateNode;
                    if (typeof x.componentDidMount == "function") {
                        var E = u.return;
                        try {
                            x.componentDidMount()
                        } catch (ye) {
                            Ri(u, E, ye)
                        }
                    }
                    var R = u.return;
                    try {
                        uv(u)
                    } catch (ye) {
                        Ri(u, R, ye)
                    }
                    break;
                case 5:
                    var W = u.return;
                    try {
                        uv(u)
                    } catch (ye) {
                        Ri(u, W, ye)
                    }
                }
            } catch (ye) {
                Ri(u, u.return, ye)
            }
            if (u === c) {
                Ve = null;
                break
            }
            var ne = u.sibling;
            if (ne !== null) {
                ne.return = u.return,
                Ve = ne;
                break
            }
            Ve = u.return
        }
    }
    var Mh = 0
      , Eh = 1
      , Th = 2
      , Ah = 3
      , Rh = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Iu = Symbol.for;
        Mh = Iu("selector.component"),
        Eh = Iu("selector.has_pseudo_class"),
        Th = Iu("selector.role"),
        Ah = Iu("selector.test_id"),
        Rh = Iu("selector.text")
    }
    function pv(c) {
        var u = ve(c);
        if (u != null) {
            if (typeof u.memoizedProps["data-testname"] != "string")
                throw Error(o(364));
            return u
        }
        if (c = pt(c),
        c === null)
            throw Error(o(362));
        return c.stateNode.current
    }
    function mv(c, u) {
        switch (u.$$typeof) {
        case Mh:
            if (c.type === u.value)
                return !0;
            break;
        case Eh:
            e: {
                u = u.value,
                c = [c, 0];
                for (var v = 0; v < c.length; ) {
                    var x = c[v++]
                      , E = c[v++]
                      , R = u[E];
                    if (x.tag !== 5 || !ee(x)) {
                        for (; R != null && mv(x, R); )
                            E++,
                            R = u[E];
                        if (E === u.length) {
                            u = !0;
                            break e
                        } else
                            for (x = x.child; x !== null; )
                                c.push(x, E),
                                x = x.sibling
                    }
                }
                u = !1
            }
            return u;
        case Th:
            if (c.tag === 5 && we(c.stateNode, u.value))
                return !0;
            break;
        case Rh:
            if ((c.tag === 5 || c.tag === 6) && (c = k(c),
            c !== null && 0 <= c.indexOf(u.value)))
                return !0;
            break;
        case Ah:
            if (c.tag === 5 && (c = c.memoizedProps["data-testname"],
            typeof c == "string" && c.toLowerCase() === u.value.toLowerCase()))
                return !0;
            break;
        default:
            throw Error(o(365))
        }
        return !1
    }
    function gv(c) {
        switch (c.$$typeof) {
        case Mh:
            return "<" + (P(c.value) || "Unknown") + ">";
        case Eh:
            return ":has(" + (gv(c) || "") + ")";
        case Th:
            return '[role="' + c.value + '"]';
        case Rh:
            return '"' + c.value + '"';
        case Ah:
            return '[data-testname="' + c.value + '"]';
        default:
            throw Error(o(365))
        }
    }
    function FM(c, u) {
        var v = [];
        c = [c, 0];
        for (var x = 0; x < c.length; ) {
            var E = c[x++]
              , R = c[x++]
              , W = u[R];
            if (E.tag !== 5 || !ee(E)) {
                for (; W != null && mv(E, W); )
                    R++,
                    W = u[R];
                if (R === u.length)
                    v.push(E);
                else
                    for (E = E.child; E !== null; )
                        c.push(E, R),
                        E = E.sibling
            }
        }
        return v
    }
    function vv(c, u) {
        if (!Ye)
            throw Error(o(363));
        c = pv(c),
        c = FM(c, u),
        u = [],
        c = Array.from(c);
        for (var v = 0; v < c.length; ) {
            var x = c[v++];
            if (x.tag === 5)
                ee(x) || u.push(x.stateNode);
            else
                for (x = x.child; x !== null; )
                    c.push(x),
                    x = x.sibling
        }
        return u
    }
    var q3 = Math.ceil
      , Ch = a.ReactCurrentDispatcher
      , yv = a.ReactCurrentOwner
      , Sn = a.ReactCurrentBatchConfig
      , Et = 0
      , Rn = null
      , Cn = null
      , Qn = 0
      , Gi = 0
      , Rl = Ei(0)
      , Un = 0
      , Nu = null
      , Cl = 0
      , bh = 0
      , _v = 0
      , Du = null
      , Ti = null
      , xv = 0
      , Sv = 1 / 0;
    function bl() {
        Sv = Hn() + 500
    }
    var Ph = !1
      , wv = null
      , fo = null
      , Lh = !1
      , ho = null
      , Ih = 0
      , Uu = 0
      , Mv = null
      , Nh = -1
      , Dh = 0;
    function gi() {
        return Et & 6 ? Hn() : Nh !== -1 ? Nh : Nh = Hn()
    }
    function po(c) {
        return c.mode & 1 ? Et & 2 && Qn !== 0 ? Qn & -Qn : L3.transition !== null ? (Dh === 0 && (c = jd,
        jd <<= 1,
        !(jd & 4194240) && (jd = 64),
        Dh = c),
        Dh) : (c = Ot,
        c !== 0 ? c : Re()) : 1
    }
    function lr(c, u, v) {
        if (50 < Uu)
            throw Uu = 0,
            Mv = null,
            Error(o(185));
        var x = Uh(c, u);
        return x === null ? null : (yu(x, u, v),
        (!(Et & 2) || x !== Rn) && (x === Rn && (!(Et & 2) && (bh |= u),
        Un === 4 && mo(x, Qn)),
        Ai(x, v),
        u === 1 && Et === 0 && !(c.mode & 1) && (bl(),
        Zd && cs())),
        x)
    }
    function Uh(c, u) {
        c.lanes |= u;
        var v = c.alternate;
        for (v !== null && (v.lanes |= u),
        v = c,
        c = c.return; c !== null; )
            c.childLanes |= u,
            v = c.alternate,
            v !== null && (v.childLanes |= u),
            v = c,
            c = c.return;
        return v.tag === 3 ? v.stateNode : null
    }
    function Ai(c, u) {
        var v = c.callbackNode;
        w3(c, u);
        var x = qd(c, c === Rn ? Qn : 0);
        if (x === 0)
            v !== null && Ew(v),
            c.callbackNode = null,
            c.callbackPriority = 0;
        else if (u = x & -x,
        c.callbackPriority !== u) {
            if (v != null && Ew(v),
            u === 1)
                c.tag === 0 ? P3(BM.bind(null, c)) : Tw(BM.bind(null, c)),
                Be ? Ze(function() {
                    Et === 0 && cs()
                }) : L0(I0, cs),
                v = null;
            else {
                switch (Mw(x)) {
                case 1:
                    v = I0;
                    break;
                case 4:
                    v = A3;
                    break;
                case 16:
                    v = N0;
                    break;
                case 536870912:
                    v = R3;
                    break;
                default:
                    v = N0
                }
                v = qM(v, zM.bind(null, c))
            }
            c.callbackPriority = u,
            c.callbackNode = v
        }
    }
    function zM(c, u) {
        if (Nh = -1,
        Dh = 0,
        Et & 6)
            throw Error(o(327));
        var v = c.callbackNode;
        if (ga() && c.callbackNode !== v)
            return null;
        var x = qd(c, c === Rn ? Qn : 0);
        if (x === 0)
            return null;
        if (x & 30 || x & c.expiredLanes || u)
            u = kh(c, x);
        else {
            u = x;
            var E = Et;
            Et |= 2;
            var R = GM();
            (Rn !== c || Qn !== u) && (bl(),
            pa(c, u));
            do
                try {
                    Q3();
                    break
                } catch (ne) {
                    HM(c, ne)
                }
            while (1);
            k0(),
            Ch.current = R,
            Et = E,
            Cn !== null ? u = 0 : (Rn = null,
            Qn = 0,
            u = Un)
        }
        if (u !== 0) {
            if (u === 2 && (E = C0(c),
            E !== 0 && (x = E,
            u = Ev(c, E))),
            u === 1)
                throw v = Nu,
                pa(c, 0),
                mo(c, x),
                Ai(c, Hn()),
                v;
            if (u === 6)
                mo(c, x);
            else {
                if (E = c.current.alternate,
                !(x & 30) && !K3(E) && (u = kh(c, x),
                u === 2 && (R = C0(c),
                R !== 0 && (x = R,
                u = Ev(c, R))),
                u === 1))
                    throw v = Nu,
                    pa(c, 0),
                    mo(c, x),
                    Ai(c, Hn()),
                    v;
                switch (c.finishedWork = E,
                c.finishedLanes = x,
                u) {
                case 0:
                case 1:
                    throw Error(o(345));
                case 2:
                    ma(c, Ti);
                    break;
                case 3:
                    if (mo(c, x),
                    (x & 130023424) === x && (u = xv + 500 - Hn(),
                    10 < u)) {
                        if (qd(c, 0) !== 0)
                            break;
                        if (E = c.suspendedLanes,
                        (E & x) !== x) {
                            gi(),
                            c.pingedLanes |= c.suspendedLanes & E;
                            break
                        }
                        c.timeoutHandle = B(ma.bind(null, c, Ti), u);
                        break
                    }
                    ma(c, Ti);
                    break;
                case 4:
                    if (mo(c, x),
                    (x & 4194240) === x)
                        break;
                    for (u = c.eventTimes,
                    E = -1; 0 < x; ) {
                        var W = 31 - Ir(x);
                        R = 1 << W,
                        W = u[W],
                        W > E && (E = W),
                        x &= ~R
                    }
                    if (x = E,
                    x = Hn() - x,
                    x = (120 > x ? 120 : 480 > x ? 480 : 1080 > x ? 1080 : 1920 > x ? 1920 : 3e3 > x ? 3e3 : 4320 > x ? 4320 : 1960 * q3(x / 1960)) - x,
                    10 < x) {
                        c.timeoutHandle = B(ma.bind(null, c, Ti), x);
                        break
                    }
                    ma(c, Ti);
                    break;
                case 5:
                    ma(c, Ti);
                    break;
                default:
                    throw Error(o(329))
                }
            }
        }
        return Ai(c, Hn()),
        c.callbackNode === v ? zM.bind(null, c) : null
    }
    function Ev(c, u) {
        var v = Du;
        return c.current.memoizedState.isDehydrated && (pa(c, u).flags |= 256),
        c = kh(c, u),
        c !== 2 && (u = Ti,
        Ti = v,
        u !== null && Tv(u)),
        c
    }
    function Tv(c) {
        Ti === null ? Ti = c : Ti.push.apply(Ti, c)
    }
    function K3(c) {
        for (var u = c; ; ) {
            if (u.flags & 16384) {
                var v = u.updateQueue;
                if (v !== null && (v = v.stores,
                v !== null))
                    for (var x = 0; x < v.length; x++) {
                        var E = v[x]
                          , R = E.getSnapshot;
                        E = E.value;
                        try {
                            if (!ls(R(), E))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (v = u.child,
            u.subtreeFlags & 16384 && v !== null)
                v.return = u,
                u = v;
            else {
                if (u === c)
                    break;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === c)
                        return !0;
                    u = u.return
                }
                u.sibling.return = u.return,
                u = u.sibling
            }
        }
        return !0
    }
    function mo(c, u) {
        for (u &= ~_v,
        u &= ~bh,
        c.suspendedLanes |= u,
        c.pingedLanes &= ~u,
        c = c.expirationTimes; 0 < u; ) {
            var v = 31 - Ir(u)
              , x = 1 << v;
            c[v] = -1,
            u &= ~x
        }
    }
    function BM(c) {
        if (Et & 6)
            throw Error(o(327));
        ga();
        var u = qd(c, 0);
        if (!(u & 1))
            return Ai(c, Hn()),
            null;
        var v = kh(c, u);
        if (c.tag !== 0 && v === 2) {
            var x = C0(c);
            x !== 0 && (u = x,
            v = Ev(c, x))
        }
        if (v === 1)
            throw v = Nu,
            pa(c, 0),
            mo(c, u),
            Ai(c, Hn()),
            v;
        if (v === 6)
            throw Error(o(345));
        return c.finishedWork = c.current.alternate,
        c.finishedLanes = u,
        ma(c, Ti),
        Ai(c, Hn()),
        null
    }
    function VM(c) {
        ho !== null && ho.tag === 0 && !(Et & 6) && ga();
        var u = Et;
        Et |= 1;
        var v = Sn.transition
          , x = Ot;
        try {
            if (Sn.transition = null,
            Ot = 1,
            c)
                return c()
        } finally {
            Ot = x,
            Sn.transition = v,
            Et = u,
            !(Et & 6) && cs()
        }
    }
    function Av() {
        Gi = Rl.current,
        Gt(Rl)
    }
    function pa(c, u) {
        c.finishedWork = null,
        c.finishedLanes = 0;
        var v = c.timeoutHandle;
        if (v !== _e && (c.timeoutHandle = _e,
        ae(v)),
        Cn !== null)
            for (v = Cn.return; v !== null; ) {
                var x = v;
                switch (G0(x),
                x.tag) {
                case 1:
                    x = x.type.childContextTypes,
                    x != null && Xd();
                    break;
                case 3:
                    Tl(),
                    Gt(Yt),
                    Gt(An),
                    K0();
                    break;
                case 5:
                    Y0(x);
                    break;
                case 4:
                    Tl();
                    break;
                case 13:
                    Gt(un);
                    break;
                case 19:
                    Gt(un);
                    break;
                case 10:
                    O0(x.type._context);
                    break;
                case 22:
                case 23:
                    Av()
                }
                v = v.return
            }
        if (Rn = c,
        Cn = c = go(c.current, null),
        Qn = Gi = u,
        Un = 0,
        Nu = null,
        _v = bh = Cl = 0,
        Ti = Du = null,
        us !== null) {
            for (u = 0; u < us.length; u++)
                if (v = us[u],
                x = v.interleaved,
                x !== null) {
                    v.interleaved = null;
                    var E = x.next
                      , R = v.pending;
                    if (R !== null) {
                        var W = R.next;
                        R.next = E,
                        x.next = W
                    }
                    v.pending = x
                }
            us = null
        }
        return c
    }
    function HM(c, u) {
        do {
            var v = Cn;
            try {
                if (k0(),
                lh.current = ph,
                ch) {
                    for (var x = gn.memoizedState; x !== null; ) {
                        var E = x.queue;
                        E !== null && (E.pending = null),
                        x = x.next
                    }
                    ch = !1
                }
                if (Al = 0,
                Gn = ri = gn = null,
                Eu = !1,
                Tu = 0,
                yv.current = null,
                v === null || v.return === null) {
                    Un = 1,
                    Nu = u,
                    Cn = null;
                    break
                }
                e: {
                    var R = c
                      , W = v.return
                      , ne = v
                      , ye = u;
                    if (u = Qn,
                    ne.flags |= 32768,
                    ye !== null && typeof ye == "object" && typeof ye.then == "function") {
                        var Ue = ye
                          , Ke = ne
                          , dt = Ke.tag;
                        if (!(Ke.mode & 1) && (dt === 0 || dt === 11 || dt === 15)) {
                            var ot = Ke.alternate;
                            ot ? (Ke.updateQueue = ot.updateQueue,
                            Ke.memoizedState = ot.memoizedState,
                            Ke.lanes = ot.lanes) : (Ke.updateQueue = null,
                            Ke.memoizedState = null)
                        }
                        var Kt = cM(W);
                        if (Kt !== null) {
                            Kt.flags &= -257,
                            uM(Kt, W, ne, R, u),
                            Kt.mode & 1 && lM(R, Ue, u),
                            u = Kt,
                            ye = Ue;
                            var nt = u.updateQueue;
                            if (nt === null) {
                                var ai = new Set;
                                ai.add(ye),
                                u.updateQueue = ai
                            } else
                                nt.add(ye);
                            break e
                        } else {
                            if (!(u & 1)) {
                                lM(R, Ue, u),
                                Rv();
                                break e
                            }
                            ye = Error(o(426))
                        }
                    } else if (an && ne.mode & 1) {
                        var ur = cM(W);
                        if (ur !== null) {
                            !(ur.flags & 65536) && (ur.flags |= 256),
                            uM(ur, W, ne, R, u),
                            $0(ye);
                            break e
                        }
                    }
                    R = ye,
                    Un !== 4 && (Un = 2),
                    Du === null ? Du = [R] : Du.push(R),
                    ye = iv(ye, ne),
                    ne = W;
                    do {
                        switch (ne.tag) {
                        case 3:
                            ne.flags |= 65536,
                            u &= -u,
                            ne.lanes |= u;
                            var de = oM(ne, ye, u);
                            Cw(ne, de);
                            break e;
                        case 1:
                            R = ye;
                            var re = ne.type
                              , ge = ne.stateNode;
                            if (!(ne.flags & 128) && (typeof re.getDerivedStateFromError == "function" || ge !== null && typeof ge.componentDidCatch == "function" && (fo === null || !fo.has(ge)))) {
                                ne.flags |= 65536,
                                u &= -u,
                                ne.lanes |= u;
                                var He = aM(ne, R, u);
                                Cw(ne, He);
                                break e
                            }
                        }
                        ne = ne.return
                    } while (ne !== null)
                }
                XM(v)
            } catch (et) {
                u = et,
                Cn === v && v !== null && (Cn = v = v.return);
                continue
            }
            break
        } while (1)
    }
    function GM() {
        var c = Ch.current;
        return Ch.current = ph,
        c === null ? ph : c
    }
    function Rv() {
        (Un === 0 || Un === 3 || Un === 2) && (Un = 4),
        Rn === null || !(Cl & 268435455) && !(bh & 268435455) || mo(Rn, Qn)
    }
    function kh(c, u) {
        var v = Et;
        Et |= 2;
        var x = GM();
        Rn === c && Qn === u || pa(c, u);
        do
            try {
                Z3();
                break
            } catch (E) {
                HM(c, E)
            }
        while (1);
        if (k0(),
        Et = v,
        Ch.current = x,
        Cn !== null)
            throw Error(o(261));
        return Rn = null,
        Qn = 0,
        Un
    }
    function Z3() {
        for (; Cn !== null; )
            WM(Cn)
    }
    function Q3() {
        for (; Cn !== null && !E3(); )
            WM(Cn)
    }
    function WM(c) {
        var u = YM(c.alternate, c, Gi);
        c.memoizedProps = c.pendingProps,
        u === null ? XM(c) : Cn = u,
        yv.current = null
    }
    function XM(c) {
        var u = c;
        do {
            var v = u.alternate;
            if (c = u.return,
            u.flags & 32768) {
                if (v = W3(v, u),
                v !== null) {
                    v.flags &= 32767,
                    Cn = v;
                    return
                }
                if (c !== null)
                    c.flags |= 32768,
                    c.subtreeFlags = 0,
                    c.deletions = null;
                else {
                    Un = 6,
                    Cn = null;
                    return
                }
            } else if (v = V3(v, u, Gi),
            v !== null) {
                Cn = v;
                return
            }
            if (u = u.sibling,
            u !== null) {
                Cn = u;
                return
            }
            Cn = u = c
        } while (u !== null);
        Un === 0 && (Un = 5)
    }
    function ma(c, u) {
        var v = Ot
          , x = Sn.transition;
        try {
            Sn.transition = null,
            Ot = 1,
            J3(c, u, v)
        } finally {
            Sn.transition = x,
            Ot = v
        }
        return null
    }
    function J3(c, u, v) {
        do
            ga();
        while (ho !== null);
        if (Et & 6)
            throw Error(o(327));
        var x = c.finishedWork
          , E = c.finishedLanes;
        if (x === null)
            return null;
        if (c.finishedWork = null,
        c.finishedLanes = 0,
        x === c.current)
            throw Error(o(177));
        c.callbackNode = null,
        c.callbackPriority = 0;
        var R = x.lanes | x.childLanes;
        if (M3(c, R),
        c === Rn && (Cn = Rn = null,
        Qn = 0),
        !(x.subtreeFlags & 2064) && !(x.flags & 2064) || Lh || (Lh = !0,
        qM(N0, function() {
            return ga(),
            null
        })),
        R = (x.flags & 15990) !== 0,
        x.subtreeFlags & 15990 || R) {
            R = Sn.transition,
            Sn.transition = null;
            var W = Ot;
            Ot = 1;
            var ne = Et;
            Et |= 4,
            yv.current = null,
            $3(c, x),
            j3(c, x),
            X(c.containerInfo),
            c.current = x,
            Y3(x),
            T3(),
            Et = ne,
            Ot = W,
            Sn.transition = R
        } else
            c.current = x;
        if (Lh && (Lh = !1,
        ho = c,
        Ih = E),
        R = c.pendingLanes,
        R === 0 && (fo = null),
        C3(x.stateNode),
        Ai(c, Hn()),
        u !== null)
            for (v = c.onRecoverableError,
            x = 0; x < u.length; x++)
                v(u[x]);
        if (Ph)
            throw Ph = !1,
            c = wv,
            wv = null,
            c;
        return Ih & 1 && c.tag !== 0 && ga(),
        R = c.pendingLanes,
        R & 1 ? c === Mv ? Uu++ : (Uu = 0,
        Mv = c) : Uu = 0,
        cs(),
        null
    }
    function ga() {
        if (ho !== null) {
            var c = Mw(Ih)
              , u = Sn.transition
              , v = Ot;
            try {
                if (Sn.transition = null,
                Ot = 16 > c ? 16 : c,
                ho === null)
                    var x = !1;
                else {
                    if (c = ho,
                    ho = null,
                    Ih = 0,
                    Et & 6)
                        throw Error(o(331));
                    var E = Et;
                    for (Et |= 4,
                    Ve = c.current; Ve !== null; ) {
                        var R = Ve
                          , W = R.child;
                        if (Ve.flags & 16) {
                            var ne = R.deletions;
                            if (ne !== null) {
                                for (var ye = 0; ye < ne.length; ye++) {
                                    var Ue = ne[ye];
                                    for (Ve = Ue; Ve !== null; ) {
                                        var Ke = Ve;
                                        switch (Ke.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            ha(8, Ke, R)
                                        }
                                        var dt = Ke.child;
                                        if (dt !== null)
                                            dt.return = Ke,
                                            Ve = dt;
                                        else
                                            for (; Ve !== null; ) {
                                                Ke = Ve;
                                                var ot = Ke.sibling
                                                  , Kt = Ke.return;
                                                if (bM(Ke),
                                                Ke === Ue) {
                                                    Ve = null;
                                                    break
                                                }
                                                if (ot !== null) {
                                                    ot.return = Kt,
                                                    Ve = ot;
                                                    break
                                                }
                                                Ve = Kt
                                            }
                                    }
                                }
                                var nt = R.alternate;
                                if (nt !== null) {
                                    var ai = nt.child;
                                    if (ai !== null) {
                                        nt.child = null;
                                        do {
                                            var ur = ai.sibling;
                                            ai.sibling = null,
                                            ai = ur
                                        } while (ai !== null)
                                    }
                                }
                                Ve = R
                            }
                        }
                        if (R.subtreeFlags & 2064 && W !== null)
                            W.return = R,
                            Ve = W;
                        else
                            e: for (; Ve !== null; ) {
                                if (R = Ve,
                                R.flags & 2048)
                                    switch (R.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ha(9, R, R.return)
                                    }
                                var de = R.sibling;
                                if (de !== null) {
                                    de.return = R.return,
                                    Ve = de;
                                    break e
                                }
                                Ve = R.return
                            }
                    }
                    var re = c.current;
                    for (Ve = re; Ve !== null; ) {
                        W = Ve;
                        var ge = W.child;
                        if (W.subtreeFlags & 2064 && ge !== null)
                            ge.return = W,
                            Ve = ge;
                        else
                            e: for (W = re; Ve !== null; ) {
                                if (ne = Ve,
                                ne.flags & 2048)
                                    try {
                                        switch (ne.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Lu(9, ne)
                                        }
                                    } catch (et) {
                                        Ri(ne, ne.return, et)
                                    }
                                if (ne === W) {
                                    Ve = null;
                                    break e
                                }
                                var He = ne.sibling;
                                if (He !== null) {
                                    He.return = ne.return,
                                    Ve = He;
                                    break e
                                }
                                Ve = ne.return
                            }
                    }
                    if (Et = E,
                    cs(),
                    as && typeof as.onPostCommitFiberRoot == "function")
                        try {
                            as.onPostCommitFiberRoot(Kd, c)
                        } catch {}
                    x = !0
                }
                return x
            } finally {
                Ot = v,
                Sn.transition = u
            }
        }
        return !1
    }
    function $M(c, u, v) {
        u = iv(v, u),
        u = oM(c, u, 1),
        uo(c, u),
        u = gi(),
        c = Uh(c, 1),
        c !== null && (yu(c, 1, u),
        Ai(c, u))
    }
    function Ri(c, u, v) {
        if (c.tag === 3)
            $M(c, c, v);
        else
            for (; u !== null; ) {
                if (u.tag === 3) {
                    $M(u, c, v);
                    break
                } else if (u.tag === 1) {
                    var x = u.stateNode;
                    if (typeof u.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (fo === null || !fo.has(x))) {
                        c = iv(v, c),
                        c = aM(u, c, 1),
                        uo(u, c),
                        c = gi(),
                        u = Uh(u, 1),
                        u !== null && (yu(u, 1, c),
                        Ai(u, c));
                        break
                    }
                }
                u = u.return
            }
    }
    function eN(c, u, v) {
        var x = c.pingCache;
        x !== null && x.delete(u),
        u = gi(),
        c.pingedLanes |= c.suspendedLanes & v,
        Rn === c && (Qn & v) === v && (Un === 4 || Un === 3 && (Qn & 130023424) === Qn && 500 > Hn() - xv ? pa(c, 0) : _v |= v),
        Ai(c, u)
    }
    function jM(c, u) {
        u === 0 && (c.mode & 1 ? (u = Yd,
        Yd <<= 1,
        !(Yd & 130023424) && (Yd = 4194304)) : u = 1);
        var v = gi();
        c = Uh(c, u),
        c !== null && (yu(c, u, v),
        Ai(c, v))
    }
    function tN(c) {
        var u = c.memoizedState
          , v = 0;
        u !== null && (v = u.retryLane),
        jM(c, v)
    }
    function nN(c, u) {
        var v = 0;
        switch (c.tag) {
        case 13:
            var x = c.stateNode
              , E = c.memoizedState;
            E !== null && (v = E.retryLane);
            break;
        case 19:
            x = c.stateNode;
            break;
        default:
            throw Error(o(314))
        }
        x !== null && x.delete(u),
        jM(c, v)
    }
    var YM;
    YM = function(c, u, v) {
        if (c !== null)
            if (c.memoizedProps !== u.pendingProps || Yt.current)
                Hi = !0;
            else {
                if (!(c.lanes & v) && !(u.flags & 128))
                    return Hi = !1,
                    G3(c, u, v);
                Hi = !!(c.flags & 131072)
            }
        else
            Hi = !1,
            an && u.flags & 1048576 && Dw(u, sh, u.index);
        switch (u.lanes = 0,
        u.tag) {
        case 2:
            var x = u.type;
            c !== null && (c.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            c = u.pendingProps;
            var E = lo(u, An.current);
            _l(u, v),
            E = Q0(null, u, x, c, E, v);
            var R = J0();
            return u.flags |= 1,
            typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0 ? (u.tag = 1,
            u.memoizedState = null,
            u.updateQueue = null,
            Zn(x) ? (R = !0,
            $d(u)) : R = !1,
            u.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null,
            z0(u),
            E.updater = ih,
            u.stateNode = E,
            E._reactInternals = u,
            V0(u, x, c, v),
            u = ov(null, u, x, !0, R, v)) : (u.tag = 0,
            an && R && H0(u),
            mi(null, u, E, v),
            u = u.child),
            u;
        case 16:
            x = u.elementType;
            e: {
                switch (c !== null && (c.alternate = null,
                u.alternate = null,
                u.flags |= 2),
                c = u.pendingProps,
                E = x._init,
                x = E(x._payload),
                u.type = x,
                E = u.tag = rN(x),
                c = Nr(x, c),
                E) {
                case 0:
                    u = sv(null, u, x, c, v);
                    break e;
                case 1:
                    u = yM(null, u, x, c, v);
                    break e;
                case 11:
                    u = hM(null, u, x, c, v);
                    break e;
                case 14:
                    u = pM(null, u, x, Nr(x.type, c), v);
                    break e
                }
                throw Error(o(306, x, ""))
            }
            return u;
        case 0:
            return x = u.type,
            E = u.pendingProps,
            E = u.elementType === x ? E : Nr(x, E),
            sv(c, u, x, E, v);
        case 1:
            return x = u.type,
            E = u.pendingProps,
            E = u.elementType === x ? E : Nr(x, E),
            yM(c, u, x, E, v);
        case 3:
            e: {
                if (_M(u),
                c === null)
                    throw Error(o(387));
                x = u.pendingProps,
                R = u.memoizedState,
                E = R.element,
                Rw(c, u),
                nh(u, x, null, v);
                var W = u.memoizedState;
                if (x = W.element,
                oe && R.isDehydrated)
                    if (R = {
                        element: x,
                        isDehydrated: !1,
                        cache: W.cache,
                        transitions: W.transitions
                    },
                    u.updateQueue.baseState = R,
                    u.memoizedState = R,
                    u.flags & 256) {
                        E = Error(o(423)),
                        u = xM(c, u, x, v, E);
                        break e
                    } else if (x !== E) {
                        E = Error(o(424)),
                        u = xM(c, u, x, v, E);
                        break e
                    } else
                        for (oe && (Vi = Se(u.stateNode.containerInfo),
                        Bi = u,
                        an = !0,
                        Dr = null,
                        _u = !1),
                        v = Bw(u, null, x, v),
                        u.child = v; v; )
                            v.flags = v.flags & -3 | 4096,
                            v = v.sibling;
                else {
                    if (wl(),
                    x === E) {
                        u = Ns(c, u, v);
                        break e
                    }
                    mi(c, u, x, v)
                }
                u = u.child
            }
            return u;
        case 5:
            return Vw(u),
            c === null && X0(u),
            x = u.type,
            E = u.pendingProps,
            R = c !== null ? c.memoizedProps : null,
            W = E.children,
            J(x, E) ? W = null : R !== null && J(x, R) && (u.flags |= 32),
            vM(c, u),
            mi(c, u, W, v),
            u.child;
        case 6:
            return c === null && X0(u),
            null;
        case 13:
            return SM(c, u, v);
        case 4:
            return j0(u, u.stateNode.containerInfo),
            x = u.pendingProps,
            c === null ? u.child = Ml(u, null, x, v) : mi(c, u, x, v),
            u.child;
        case 11:
            return x = u.type,
            E = u.pendingProps,
            E = u.elementType === x ? E : Nr(x, E),
            hM(c, u, x, E, v);
        case 7:
            return mi(c, u, u.pendingProps, v),
            u.child;
        case 8:
            return mi(c, u, u.pendingProps.children, v),
            u.child;
        case 12:
            return mi(c, u, u.pendingProps.children, v),
            u.child;
        case 10:
            e: {
                if (x = u.type._context,
                E = u.pendingProps,
                R = u.memoizedProps,
                W = E.value,
                Aw(u, x, W),
                R !== null)
                    if (ls(R.value, W)) {
                        if (R.children === E.children && !Yt.current) {
                            u = Ns(c, u, v);
                            break e
                        }
                    } else
                        for (R = u.child,
                        R !== null && (R.return = u); R !== null; ) {
                            var ne = R.dependencies;
                            if (ne !== null) {
                                W = R.child;
                                for (var ye = ne.firstContext; ye !== null; ) {
                                    if (ye.context === x) {
                                        if (R.tag === 1) {
                                            ye = bs(-1, v & -v),
                                            ye.tag = 2;
                                            var Ue = R.updateQueue;
                                            if (Ue !== null) {
                                                Ue = Ue.shared;
                                                var Ke = Ue.pending;
                                                Ke === null ? ye.next = ye : (ye.next = Ke.next,
                                                Ke.next = ye),
                                                Ue.pending = ye
                                            }
                                        }
                                        R.lanes |= v,
                                        ye = R.alternate,
                                        ye !== null && (ye.lanes |= v),
                                        F0(R.return, v, u),
                                        ne.lanes |= v;
                                        break
                                    }
                                    ye = ye.next
                                }
                            } else if (R.tag === 10)
                                W = R.type === u.type ? null : R.child;
                            else if (R.tag === 18) {
                                if (W = R.return,
                                W === null)
                                    throw Error(o(341));
                                W.lanes |= v,
                                ne = W.alternate,
                                ne !== null && (ne.lanes |= v),
                                F0(W, v, u),
                                W = R.sibling
                            } else
                                W = R.child;
                            if (W !== null)
                                W.return = R;
                            else
                                for (W = R; W !== null; ) {
                                    if (W === u) {
                                        W = null;
                                        break
                                    }
                                    if (R = W.sibling,
                                    R !== null) {
                                        R.return = W.return,
                                        W = R;
                                        break
                                    }
                                    W = W.return
                                }
                            R = W
                        }
                mi(c, u, E.children, v),
                u = u.child
            }
            return u;
        case 9:
            return E = u.type,
            x = u.pendingProps.children,
            _l(u, v),
            E = ir(E),
            x = x(E),
            u.flags |= 1,
            mi(c, u, x, v),
            u.child;
        case 14:
            return x = u.type,
            E = Nr(x, u.pendingProps),
            E = Nr(x.type, E),
            pM(c, u, x, E, v);
        case 15:
            return mM(c, u, u.type, u.pendingProps, v);
        case 17:
            return x = u.type,
            E = u.pendingProps,
            E = u.elementType === x ? E : Nr(x, E),
            c !== null && (c.alternate = null,
            u.alternate = null,
            u.flags |= 2),
            u.tag = 1,
            Zn(x) ? (c = !0,
            $d(u)) : c = !1,
            _l(u, v),
            Iw(u, x, E),
            V0(u, x, E, v),
            ov(null, u, x, !0, c, v);
        case 19:
            return TM(c, u, v);
        case 22:
            return gM(c, u, v)
        }
        throw Error(o(156, u.tag))
    }
    ;
    function qM(c, u) {
        return L0(c, u)
    }
    function iN(c, u, v, x) {
        this.tag = c,
        this.key = v,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = u,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = x,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function cr(c, u, v, x) {
        return new iN(c,u,v,x)
    }
    function Cv(c) {
        return c = c.prototype,
        !(!c || !c.isReactComponent)
    }
    function rN(c) {
        if (typeof c == "function")
            return Cv(c) ? 1 : 0;
        if (c != null) {
            if (c = c.$$typeof,
            c === S)
                return 11;
            if (c === _)
                return 14
        }
        return 2
    }
    function go(c, u) {
        var v = c.alternate;
        return v === null ? (v = cr(c.tag, u, c.key, c.mode),
        v.elementType = c.elementType,
        v.type = c.type,
        v.stateNode = c.stateNode,
        v.alternate = c,
        c.alternate = v) : (v.pendingProps = u,
        v.type = c.type,
        v.flags = 0,
        v.subtreeFlags = 0,
        v.deletions = null),
        v.flags = c.flags & 14680064,
        v.childLanes = c.childLanes,
        v.lanes = c.lanes,
        v.child = c.child,
        v.memoizedProps = c.memoizedProps,
        v.memoizedState = c.memoizedState,
        v.updateQueue = c.updateQueue,
        u = c.dependencies,
        v.dependencies = u === null ? null : {
            lanes: u.lanes,
            firstContext: u.firstContext
        },
        v.sibling = c.sibling,
        v.index = c.index,
        v.ref = c.ref,
        v
    }
    function Oh(c, u, v, x, E, R) {
        var W = 2;
        if (x = c,
        typeof c == "function")
            Cv(c) && (W = 1);
        else if (typeof c == "string")
            W = 5;
        else
            e: switch (c) {
            case d:
                return va(v.children, E, R, u);
            case h:
                W = 8,
                E |= 8;
                break;
            case p:
                return c = cr(12, v, u, E | 2),
                c.elementType = p,
                c.lanes = R,
                c;
            case M:
                return c = cr(13, v, u, E),
                c.elementType = M,
                c.lanes = R,
                c;
            case g:
                return c = cr(19, v, u, E),
                c.elementType = g,
                c.lanes = R,
                c;
            case T:
                return Fh(v, E, R, u);
            default:
                if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                    case m:
                        W = 10;
                        break e;
                    case y:
                        W = 9;
                        break e;
                    case S:
                        W = 11;
                        break e;
                    case _:
                        W = 14;
                        break e;
                    case w:
                        W = 16,
                        x = null;
                        break e
                    }
                throw Error(o(130, c == null ? c : typeof c, ""))
            }
        return u = cr(W, v, u, E),
        u.elementType = c,
        u.type = x,
        u.lanes = R,
        u
    }
    function va(c, u, v, x) {
        return c = cr(7, c, x, u),
        c.lanes = v,
        c
    }
    function Fh(c, u, v, x) {
        return c = cr(22, c, x, u),
        c.elementType = T,
        c.lanes = v,
        c.stateNode = {},
        c
    }
    function bv(c, u, v) {
        return c = cr(6, c, null, u),
        c.lanes = v,
        c
    }
    function Pv(c, u, v) {
        return u = cr(4, c.children !== null ? c.children : [], c.key, u),
        u.lanes = v,
        u.stateNode = {
            containerInfo: c.containerInfo,
            pendingChildren: null,
            implementation: c.implementation
        },
        u
    }
    function sN(c, u, v, x, E) {
        this.tag = u,
        this.containerInfo = c,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = _e,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = b0(0),
        this.expirationTimes = b0(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = b0(0),
        this.identifierPrefix = x,
        this.onRecoverableError = E,
        oe && (this.mutableSourceEagerHydrationData = null)
    }
    function KM(c, u, v, x, E, R, W, ne, ye) {
        return c = new sN(c,u,v,ne,ye),
        u === 1 ? (u = 1,
        R === !0 && (u |= 8)) : u = 0,
        R = cr(3, null, null, u),
        c.current = R,
        R.stateNode = c,
        R.memoizedState = {
            element: x,
            isDehydrated: v,
            cache: null,
            transitions: null
        },
        z0(R),
        c
    }
    function ZM(c) {
        if (!c)
            return ii;
        c = c._reactInternals;
        e: {
            if (b(c) !== c || c.tag !== 1)
                throw Error(o(170));
            var u = c;
            do {
                switch (u.tag) {
                case 3:
                    u = u.stateNode.context;
                    break e;
                case 1:
                    if (Zn(u.type)) {
                        u = u.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                u = u.return
            } while (u !== null);
            throw Error(o(171))
        }
        if (c.tag === 1) {
            var v = c.type;
            if (Zn(v))
                return Sw(c, v, u)
        }
        return u
    }
    function QM(c) {
        var u = c._reactInternals;
        if (u === void 0)
            throw typeof c.render == "function" ? Error(o(188)) : (c = Object.keys(c).join(","),
            Error(o(268, c)));
        return c = Z(u),
        c === null ? null : c.stateNode
    }
    function JM(c, u) {
        if (c = c.memoizedState,
        c !== null && c.dehydrated !== null) {
            var v = c.retryLane;
            c.retryLane = v !== 0 && v < u ? v : u
        }
    }
    function Lv(c, u) {
        JM(c, u),
        (c = c.alternate) && JM(c, u)
    }
    function oN(c) {
        return c = Z(c),
        c === null ? null : c.stateNode
    }
    function aN() {
        return null
    }
    return t.attemptContinuousHydration = function(c) {
        if (c.tag === 13) {
            var u = gi();
            lr(c, 134217728, u),
            Lv(c, 134217728)
        }
    }
    ,
    t.attemptHydrationAtCurrentPriority = function(c) {
        if (c.tag === 13) {
            var u = gi()
              , v = po(c);
            lr(c, v, u),
            Lv(c, v)
        }
    }
    ,
    t.attemptSynchronousHydration = function(c) {
        switch (c.tag) {
        case 3:
            var u = c.stateNode;
            if (u.current.memoizedState.isDehydrated) {
                var v = vu(u.pendingLanes);
                v !== 0 && (P0(u, v | 1),
                Ai(u, Hn()),
                !(Et & 6) && (bl(),
                cs()))
            }
            break;
        case 13:
            var x = gi();
            VM(function() {
                return lr(c, 1, x)
            }),
            Lv(c, 1)
        }
    }
    ,
    t.batchedUpdates = function(c, u) {
        var v = Et;
        Et |= 1;
        try {
            return c(u)
        } finally {
            Et = v,
            Et === 0 && (bl(),
            Zd && cs())
        }
    }
    ,
    t.createComponentSelector = function(c) {
        return {
            $$typeof: Mh,
            value: c
        }
    }
    ,
    t.createContainer = function(c, u, v, x, E, R, W) {
        return KM(c, u, !1, null, v, x, E, R, W)
    }
    ,
    t.createHasPseudoClassSelector = function(c) {
        return {
            $$typeof: Eh,
            value: c
        }
    }
    ,
    t.createHydrationContainer = function(c, u, v, x, E, R, W, ne, ye) {
        return c = KM(v, x, !0, c, E, R, W, ne, ye),
        c.context = ZM(null),
        v = c.current,
        x = gi(),
        E = po(v),
        R = bs(x, E),
        R.callback = u ?? null,
        uo(v, R),
        c.current.lanes = E,
        yu(c, E, x),
        Ai(c, x),
        c
    }
    ,
    t.createPortal = function(c, u, v) {
        var x = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: f,
            key: x == null ? null : "" + x,
            children: c,
            containerInfo: u,
            implementation: v
        }
    }
    ,
    t.createRoleSelector = function(c) {
        return {
            $$typeof: Th,
            value: c
        }
    }
    ,
    t.createTestNameSelector = function(c) {
        return {
            $$typeof: Ah,
            value: c
        }
    }
    ,
    t.createTextSelector = function(c) {
        return {
            $$typeof: Rh,
            value: c
        }
    }
    ,
    t.deferredUpdates = function(c) {
        var u = Ot
          , v = Sn.transition;
        try {
            return Sn.transition = null,
            Ot = 16,
            c()
        } finally {
            Ot = u,
            Sn.transition = v
        }
    }
    ,
    t.discreteUpdates = function(c, u, v, x, E) {
        var R = Ot
          , W = Sn.transition;
        try {
            return Sn.transition = null,
            Ot = 1,
            c(u, v, x, E)
        } finally {
            Ot = R,
            Sn.transition = W,
            Et === 0 && bl()
        }
    }
    ,
    t.findAllNodes = vv,
    t.findBoundingRects = function(c, u) {
        if (!Ye)
            throw Error(o(363));
        u = vv(c, u),
        c = [];
        for (var v = 0; v < u.length; v++)
            c.push(G(u[v]));
        for (u = c.length - 1; 0 < u; u--) {
            v = c[u];
            for (var x = v.x, E = x + v.width, R = v.y, W = R + v.height, ne = u - 1; 0 <= ne; ne--)
                if (u !== ne) {
                    var ye = c[ne]
                      , Ue = ye.x
                      , Ke = Ue + ye.width
                      , dt = ye.y
                      , ot = dt + ye.height;
                    if (x >= Ue && R >= dt && E <= Ke && W <= ot) {
                        c.splice(u, 1);
                        break
                    } else if (x !== Ue || v.width !== ye.width || ot < R || dt > W) {
                        if (!(R !== dt || v.height !== ye.height || Ke < x || Ue > E)) {
                            Ue > x && (ye.width += Ue - x,
                            ye.x = x),
                            Ke < E && (ye.width = E - Ue),
                            c.splice(u, 1);
                            break
                        }
                    } else {
                        dt > R && (ye.height += dt - R,
                        ye.y = R),
                        ot < W && (ye.height = W - dt),
                        c.splice(u, 1);
                        break
                    }
                }
        }
        return c
    }
    ,
    t.findHostInstance = QM,
    t.findHostInstanceWithNoPortals = function(c) {
        return c = Y(c),
        c = c !== null ? Q(c) : null,
        c === null ? null : c.stateNode
    }
    ,
    t.findHostInstanceWithWarning = function(c) {
        return QM(c)
    }
    ,
    t.flushControlled = function(c) {
        var u = Et;
        Et |= 1;
        var v = Sn.transition
          , x = Ot;
        try {
            Sn.transition = null,
            Ot = 1,
            c()
        } finally {
            Ot = x,
            Sn.transition = v,
            Et = u,
            Et === 0 && (bl(),
            cs())
        }
    }
    ,
    t.flushPassiveEffects = ga,
    t.flushSync = VM,
    t.focusWithin = function(c, u) {
        if (!Ye)
            throw Error(o(363));
        for (c = pv(c),
        u = FM(c, u),
        u = Array.from(u),
        c = 0; c < u.length; ) {
            var v = u[c++];
            if (!ee(v)) {
                if (v.tag === 5 && Ie(v.stateNode))
                    return !0;
                for (v = v.child; v !== null; )
                    u.push(v),
                    v = v.sibling
            }
        }
        return !1
    }
    ,
    t.getCurrentUpdatePriority = function() {
        return Ot
    }
    ,
    t.getFindAllNodesFailureDescription = function(c, u) {
        if (!Ye)
            throw Error(o(363));
        var v = 0
          , x = [];
        c = [pv(c), 0];
        for (var E = 0; E < c.length; ) {
            var R = c[E++]
              , W = c[E++]
              , ne = u[W];
            if ((R.tag !== 5 || !ee(R)) && (mv(R, ne) && (x.push(gv(ne)),
            W++,
            W > v && (v = W)),
            W < u.length))
                for (R = R.child; R !== null; )
                    c.push(R, W),
                    R = R.sibling
        }
        if (v < u.length) {
            for (c = []; v < u.length; v++)
                c.push(gv(u[v]));
            return `findAllNodes was able to match part of the selector:
  ` + (x.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ")
        }
        return null
    }
    ,
    t.getPublicRootInstance = function(c) {
        if (c = c.current,
        !c.child)
            return null;
        switch (c.child.tag) {
        case 5:
            return fe(c.child.stateNode);
        default:
            return c.child.stateNode
        }
    }
    ,
    t.injectIntoDevTools = function(c) {
        if (c = {
            bundleType: c.bundleType,
            version: c.version,
            rendererPackageName: c.rendererPackageName,
            rendererConfig: c.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: a.ReactCurrentDispatcher,
            findHostInstanceByFiber: oN,
            findFiberByHostInstance: c.findFiberByHostInstance || aN,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.0.0-fc46dba67-20220329"
        },
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
            c = !1;
        else {
            var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (u.isDisabled || !u.supportsFiber)
                c = !0;
            else {
                try {
                    Kd = u.inject(c),
                    as = u
                } catch {}
                c = !!u.checkDCE
            }
        }
        return c
    }
    ,
    t.isAlreadyRendering = function() {
        return !1
    }
    ,
    t.observeVisibleRects = function(c, u, v, x) {
        if (!Ye)
            throw Error(o(363));
        c = vv(c, u);
        var E = Fe(c, v, x).disconnect;
        return {
            disconnect: function() {
                E()
            }
        }
    }
    ,
    t.registerMutableSourceForHydration = function(c, u) {
        var v = u._getVersion;
        v = v(u._source),
        c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [u, v] : c.mutableSourceEagerHydrationData.push(u, v)
    }
    ,
    t.runWithPriority = function(c, u) {
        var v = Ot;
        try {
            return Ot = c,
            u()
        } finally {
            Ot = v
        }
    }
    ,
    t.shouldError = function() {
        return null
    }
    ,
    t.shouldSuspend = function() {
        return !1
    }
    ,
    t.updateContainer = function(c, u, v, x) {
        var E = u.current
          , R = gi()
          , W = po(E);
        return v = ZM(v),
        u.context === null ? u.context = v : u.pendingContext = v,
        u = bs(R, W),
        u.payload = {
            element: c
        },
        x = x === void 0 ? null : x,
        x !== null && (u.callback = x),
        uo(E, u),
        c = lr(E, W, R),
        c !== null && th(c, E, W),
        W
    }
    ,
    t
};
DI.exports = NX;
var DX = DI.exports;
const UX = fd(DX);
var UI = {
    exports: {}
}
  , kI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(D, j) {
        var X = D.length;
        D.push(j);
        e: for (; 0 < X; ) {
            var ue = X - 1 >>> 1
              , I = D[ue];
            if (0 < r(I, j))
                D[ue] = j,
                D[X] = I,
                X = ue;
            else
                break e
        }
    }
    function t(D) {
        return D.length === 0 ? null : D[0]
    }
    function i(D) {
        if (D.length === 0)
            return null;
        var j = D[0]
          , X = D.pop();
        if (X !== j) {
            D[0] = X;
            e: for (var ue = 0, I = D.length, U = I >>> 1; ue < U; ) {
                var O = 2 * (ue + 1) - 1
                  , J = D[O]
                  , F = O + 1
                  , B = D[F];
                if (0 > r(J, X))
                    F < I && 0 > r(B, J) ? (D[ue] = B,
                    D[F] = X,
                    ue = F) : (D[ue] = J,
                    D[O] = X,
                    ue = O);
                else if (F < I && 0 > r(B, X))
                    D[ue] = B,
                    D[F] = X,
                    ue = F;
                else
                    break e
            }
        }
        return j
    }
    function r(D, j) {
        var X = D.sortIndex - j.sortIndex;
        return X !== 0 ? X : D.id - j.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , f = []
      , d = 1
      , h = null
      , p = 3
      , m = !1
      , y = !1
      , S = !1
      , M = typeof setTimeout == "function" ? setTimeout : null
      , g = typeof clearTimeout == "function" ? clearTimeout : null
      , _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(D) {
        for (var j = t(f); j !== null; ) {
            if (j.callback === null)
                i(f);
            else if (j.startTime <= D)
                i(f),
                j.sortIndex = j.expirationTime,
                e(l, j);
            else
                break;
            j = t(f)
        }
    }
    function T(D) {
        if (S = !1,
        w(D),
        !y)
            if (t(l) !== null)
                y = !0,
                fe(A);
            else {
                var j = t(f);
                j !== null && le(T, j.startTime - D)
            }
    }
    function A(D, j) {
        y = !1,
        S && (S = !1,
        g(N),
        N = -1),
        m = !0;
        var X = p;
        try {
            for (w(j),
            h = t(l); h !== null && (!(h.expirationTime > j) || D && !Y()); ) {
                var ue = h.callback;
                if (typeof ue == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var I = ue(h.expirationTime <= j);
                    j = n.unstable_now(),
                    typeof I == "function" ? h.callback = I : h === t(l) && i(l),
                    w(j)
                } else
                    i(l);
                h = t(l)
            }
            if (h !== null)
                var U = !0;
            else {
                var O = t(f);
                O !== null && le(T, O.startTime - j),
                U = !1
            }
            return U
        } finally {
            h = null,
            p = X,
            m = !1
        }
    }
    var C = !1
      , P = null
      , N = -1
      , b = 5
      , L = -1;
    function Y() {
        return !(n.unstable_now() - L < b)
    }
    function Z() {
        if (P !== null) {
            var D = n.unstable_now();
            L = D;
            var j = !0;
            try {
                j = P(!0, D)
            } finally {
                j ? $() : (C = !1,
                P = null)
            }
        } else
            C = !1
    }
    var $;
    if (typeof _ == "function")
        $ = function() {
            _(Z)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Q = new MessageChannel
          , ie = Q.port2;
        Q.port1.onmessage = Z,
        $ = function() {
            ie.postMessage(null)
        }
    } else
        $ = function() {
            M(Z, 0)
        }
        ;
    function fe(D) {
        P = D,
        C || (C = !0,
        $())
    }
    function le(D, j) {
        N = M(function() {
            D(n.unstable_now())
        }, j)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(D) {
        D.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        y || m || (y = !0,
        fe(A))
    }
    ,
    n.unstable_forceFrameRate = function(D) {
        0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < D ? Math.floor(1e3 / D) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(D) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var j = 3;
            break;
        default:
            j = p
        }
        var X = p;
        p = j;
        try {
            return D()
        } finally {
            p = X
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(D, j) {
        switch (D) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            D = 3
        }
        var X = p;
        p = D;
        try {
            return j()
        } finally {
            p = X
        }
    }
    ,
    n.unstable_scheduleCallback = function(D, j, X) {
        var ue = n.unstable_now();
        switch (typeof X == "object" && X !== null ? (X = X.delay,
        X = typeof X == "number" && 0 < X ? ue + X : ue) : X = ue,
        D) {
        case 1:
            var I = -1;
            break;
        case 2:
            I = 250;
            break;
        case 5:
            I = 1073741823;
            break;
        case 4:
            I = 1e4;
            break;
        default:
            I = 5e3
        }
        return I = X + I,
        D = {
            id: d++,
            callback: j,
            priorityLevel: D,
            startTime: X,
            expirationTime: I,
            sortIndex: -1
        },
        X > ue ? (D.sortIndex = X,
        e(f, D),
        t(l) === null && D === t(f) && (S ? (g(N),
        N = -1) : S = !0,
        le(T, X - ue))) : (D.sortIndex = I,
        e(l, D),
        y || m || (y = !0,
        fe(A))),
        D
    }
    ,
    n.unstable_shouldYield = Y,
    n.unstable_wrapCallback = function(D) {
        var j = p;
        return function() {
            var X = p;
            p = j;
            try {
                return D.apply(this, arguments)
            } finally {
                p = X
            }
        }
    }
}
)(kI);
UI.exports = kI;
var gR = UI.exports;
function OI(n, e, t=(i,r)=>i === r) {
    if (n === e)
        return !0;
    if (!n || !e)
        return !1;
    const i = n.length;
    if (e.length !== i)
        return !1;
    for (let r = 0; r < i; r++)
        if (!t(n[r], e[r]))
            return !1;
    return !0
}
const Ws = [];
function FI(n, e, t=!1, i={}) {
    for (const s of Ws)
        if (OI(e, s.keys, s.equal)) {
            if (t)
                return;
            if (Object.prototype.hasOwnProperty.call(s, "error"))
                throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response"))
                return s.response;
            if (!t)
                throw s.promise
        }
    const r = {
        keys: e,
        equal: i.equal,
        promise: n(...e).then(s=>r.response = s).then(()=>{
            i.lifespan && i.lifespan > 0 && setTimeout(()=>{
                const s = Ws.indexOf(r);
                s !== -1 && Ws.splice(s, 1)
            }
            , i.lifespan)
        }
        ).catch(s=>r.error = s)
    };
    if (Ws.push(r),
    !t)
        throw r.promise
}
const kX = (n,e,t)=>FI(n, e, !1, t)
  , OX = (n,e,t)=>void FI(n, e, !0, t)
  , FX = n=>{
    if (n === void 0 || n.length === 0)
        Ws.splice(0, Ws.length);
    else {
        const e = Ws.find(t=>OI(n, t.keys, t.equal));
        if (e) {
            const t = Ws.indexOf(e);
            t !== -1 && Ws.splice(t, 1)
        }
    }
}
  , gw = {}
  , zX = n=>void Object.assign(gw, n);
function BX(n, e) {
    function t(d, {args: h=[], attach: p, ...m}, y) {
        let S = `${d[0].toUpperCase()}${d.slice(1)}`, M;
        if (d === "primitive") {
            if (m.object === void 0)
                throw new Error("R3F: Primitives without 'object' are invalid!");
            const g = m.object;
            M = ic(g, {
                type: d,
                root: y,
                attach: p,
                primitive: !0
            })
        } else {
            const g = gw[S];
            if (!g)
                throw new Error(`R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(h))
                throw new Error("R3F: The args prop must be an array!");
            M = ic(new g(...h), {
                type: d,
                root: y,
                attach: p,
                memoizedProps: {
                    args: h
                }
            })
        }
        return M.__r3f.attach === void 0 && (M instanceof ft ? M.__r3f.attach = "geometry" : M instanceof Nn && (M.__r3f.attach = "material")),
        S !== "inject" && qy(M, m),
        M
    }
    function i(d, h) {
        let p = !1;
        if (h) {
            var m, y;
            (m = h.__r3f) != null && m.attach ? Yy(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h),
            p = !0),
            p || (y = d.__r3f) == null || y.objects.push(h),
            h.__r3f || ic(h, {}),
            h.__r3f.parent = d,
            nS(h),
            rc(h)
        }
    }
    function r(d, h, p) {
        let m = !1;
        if (h) {
            var y, S;
            if ((y = h.__r3f) != null && y.attach)
                Yy(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                h.parent = d,
                h.dispatchEvent({
                    type: "added"
                });
                const M = d.children.filter(_=>_ !== h)
                  , g = M.indexOf(p);
                d.children = [...M.slice(0, g), h, ...M.slice(g)],
                m = !0
            }
            m || (S = d.__r3f) == null || S.objects.push(h),
            h.__r3f || ic(h, {}),
            h.__r3f.parent = d,
            nS(h),
            rc(h)
        }
    }
    function s(d, h, p=!1) {
        d && [...d].forEach(m=>o(h, m, p))
    }
    function o(d, h, p) {
        if (h) {
            var m, y, S;
            if (h.__r3f && (h.__r3f.parent = null),
            (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(T=>T !== h)),
            (y = h.__r3f) != null && y.attach)
                SR(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var M;
                d.remove(h),
                (M = h.__r3f) != null && M.root && YX(h.__r3f.root, h)
            }
            const _ = (S = h.__r3f) == null ? void 0 : S.primitive
              , w = p === void 0 ? h.dispose !== null && !_ : p;
            if (!_) {
                var g;
                s((g = h.__r3f) == null ? void 0 : g.objects, h, w),
                s(h.children, h, w)
            }
            h.__r3f && (delete h.__r3f.root,
            delete h.__r3f.objects,
            delete h.__r3f.handlers,
            delete h.__r3f.memoizedProps,
            _ || delete h.__r3f),
            w && h.dispose && h.type !== "Scene" && gR.unstable_scheduleCallback(gR.unstable_IdlePriority, ()=>{
                try {
                    h.dispose()
                } catch {}
            }
            ),
            rc(d)
        }
    }
    function a(d, h, p, m) {
        var y;
        const S = (y = d.__r3f) == null ? void 0 : y.parent;
        if (!S)
            return;
        const M = t(h, p, d.__r3f.root);
        if (d.children) {
            for (const g of d.children)
                g.__r3f && i(M, g);
            d.children = d.children.filter(g=>!g.__r3f)
        }
        d.__r3f.objects.forEach(g=>i(M, g)),
        d.__r3f.objects = [],
        d.__r3f.autoRemovedBeforeAppend || o(S, d),
        M.parent && (M.__r3f.autoRemovedBeforeAppend = !0),
        i(S, M),
        M.raycast && M.__r3f.eventCount && M.__r3f.root.getState().internal.interaction.push(M),
        [m, m.alternate].forEach(g=>{
            g !== null && (g.stateNode = M,
            g.ref && (typeof g.ref == "function" ? g.ref(M) : g.ref.current = M))
        }
        )
    }
    const l = ()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: UX({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d,h)=>{
                if (!h)
                    return;
                const p = d.getState().scene;
                p.__r3f && (p.__r3f.root = d,
                i(p, h))
            }
            ,
            removeChildFromContainer: (d,h)=>{
                h && o(d.getState().scene, h)
            }
            ,
            insertInContainerBefore: (d,h,p)=>{
                if (!h || !p)
                    return;
                const m = d.getState().scene;
                m.__r3f && r(m, h, p)
            }
            ,
            getRootHostContext: ()=>null,
            getChildHostContext: d=>d,
            finalizeInitialChildren(d) {
                var h;
                return !!((h = d == null ? void 0 : d.__r3f) != null ? h : {}).handlers
            },
            prepareUpdate(d, h, p, m) {
                if (d.__r3f.primitive && m.object && m.object !== d)
                    return [!0];
                {
                    const {args: y=[], children: S, ...M} = m
                      , {args: g=[], children: _, ...w} = p;
                    if (!Array.isArray(y))
                        throw new Error("R3F: the args prop must be an array!");
                    if (y.some((A,C)=>A !== g[C]))
                        return [!0];
                    const T = XI(d, M, w, !0);
                    return T.changes.length ? [!1, T] : null
                }
            },
            commitUpdate(d, [h,p], m, y, S, M) {
                h ? a(d, m, S, M) : qy(d, p)
            },
            commitMount(d, h, p, m) {
                var y;
                const S = (y = d.__r3f) != null ? y : {};
                d.raycast && S.handlers && S.eventCount && d.__r3f.root.getState().internal.interaction.push(d)
            },
            getPublicInstance: d=>d,
            prepareForCommit: ()=>null,
            preparePortalMount: d=>ic(d.getState().scene),
            resetAfterCommit: ()=>{}
            ,
            shouldSetTextContent: ()=>!1,
            clearContainer: ()=>!1,
            hideInstance(d) {
                var h;
                const {attach: p, parent: m} = (h = d.__r3f) != null ? h : {};
                p && m && SR(m, d, p),
                d.isObject3D && (d.visible = !1),
                rc(d)
            },
            unhideInstance(d, h) {
                var p;
                const {attach: m, parent: y} = (p = d.__r3f) != null ? p : {};
                m && y && Yy(y, d, m),
                (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0),
                rc(d)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: ()=>e ? e() : Sc.DefaultEventPriority,
            beforeActiveInstanceBlur: ()=>{}
            ,
            afterActiveInstanceBlur: ()=>{}
            ,
            detachDeletedInstance: ()=>{}
            ,
            now: typeof performance < "u" && nn.fun(performance.now) ? performance.now : nn.fun(Date.now) ? Date.now : ()=>0,
            scheduleTimeout: nn.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: nn.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: qy
    }
}
var vR, yR;
const jy = n=>"colorSpace"in n || "outputColorSpace"in n
  , zI = ()=>{
    var n;
    return (n = gw.ColorManagement) != null ? n : null
}
  , BI = n=>n && n.isOrthographicCamera
  , VX = n=>n && n.hasOwnProperty("current")
  , Gd = typeof window < "u" && ((vR = window.document) != null && vR.createElement || ((yR = window.navigator) == null ? void 0 : yR.product) === "ReactNative") ? ke.useLayoutEffect : ke.useEffect;
function VI(n) {
    const e = ke.useRef(n);
    return Gd(()=>void (e.current = n), [n]),
    e
}
function HX({set: n}) {
    return Gd(()=>(n(new Promise(()=>null)),
    ()=>n(!1)), [n]),
    null
}
class HI extends ke.Component {
    constructor(...e) {
        super(...e),
        this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
HI.getDerivedStateFromError = ()=>({
    error: !0
});
const GI = "__default"
  , _R = new Map
  , GX = n=>n && !!n.memoized && !!n.changes;
function WI(n) {
    var e;
    const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n
}
const of = n=>{
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
  , nn = {
    obj: n=>n === Object(n) && !nn.arr(n) && typeof n != "function",
    fun: n=>typeof n == "function",
    str: n=>typeof n == "string",
    num: n=>typeof n == "number",
    boo: n=>typeof n == "boolean",
    und: n=>n === void 0,
    arr: n=>Array.isArray(n),
    equ(n, e, {arrays: t="shallow", objects: i="reference", strict: r=!0}={}) {
        if (typeof n != typeof e || !!n != !!e)
            return !1;
        if (nn.str(n) || nn.num(n))
            return n === e;
        const s = nn.obj(n);
        if (s && i === "reference")
            return n === e;
        const o = nn.arr(n);
        if (o && t === "reference")
            return n === e;
        if ((o || s) && n === e)
            return !0;
        let a;
        for (a in n)
            if (!(a in e))
                return !1;
        if (s && t === "shallow" && i === "shallow") {
            for (a in r ? e : n)
                if (!nn.equ(n[a], e[a], {
                    strict: r,
                    objects: "reference"
                }))
                    return !1
        } else
            for (a in r ? e : n)
                if (n[a] !== e[a])
                    return !1;
        if (nn.und(a)) {
            if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
                return !0;
            if (n !== e)
                return !1
        }
        return !0
    }
};
function WX(n) {
    const e = {
        nodes: {},
        materials: {}
    };
    return n && n.traverse(t=>{
        t.name && (e.nodes[t.name] = t),
        t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }
    ),
    e
}
function XX(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n)
        e.dispose == null || e.dispose(),
        delete n[e]
}
function ic(n, e) {
    const t = n;
    return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }),
    n
}
function tS(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-")
          , r = i.pop();
        return t = i.reduce((s,o)=>s[o], n),
        {
            target: t,
            key: r
        }
    } else
        return {
            target: t,
            key: e
        }
}
const xR = /-\d+$/;
function Yy(n, e, t) {
    if (nn.str(t)) {
        if (xR.test(t)) {
            const s = t.replace(xR, "")
              , {target: o, key: a} = tS(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {target: i, key: r} = tS(n, t);
        e.__r3f.previousAttach = i[r],
        i[r] = e
    } else
        e.__r3f.previousAttach = t(n, e)
}
function SR(n, e, t) {
    var i, r;
    if (nn.str(t)) {
        const {target: s, key: o} = tS(n, t)
          , a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else
        (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}
function XI(n, {children: e, key: t, ref: i, ...r}, {children: s, key: o, ref: a, ...l}={}, f=!1) {
    var d;
    const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {}
      , p = Object.entries(r)
      , m = [];
    if (f) {
        const S = Object.keys(l);
        for (let M = 0; M < S.length; M++)
            r.hasOwnProperty(S[M]) || p.unshift([S[M], GI + "remove"])
    }
    p.forEach(([S,M])=>{
        var g;
        if ((g = n.__r3f) != null && g.primitive && S === "object" || nn.equ(M, l[S]))
            return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(S))
            return m.push([S, M, !0, []]);
        let _ = [];
        S.includes("-") && (_ = S.split("-")),
        m.push([S, M, !1, _]);
        for (const w in r) {
            const T = r[w];
            w.startsWith(`${S}-`) && m.push([w, T, !1, w.split("-")])
        }
    }
    );
    const y = {
        ...r
    };
    return h.memoizedProps && h.memoizedProps.args && (y.args = h.memoizedProps.args),
    h.memoizedProps && h.memoizedProps.attach && (y.attach = h.memoizedProps.attach),
    {
        memoized: y,
        changes: m
    }
}
function qy(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {}
      , o = s.root
      , a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}
      , {memoized: l, changes: f} = GX(e) ? e : XI(n, e)
      , d = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = l);
    for (let p = 0; p < f.length; p++) {
        let[m,y,S,M] = f[p];
        if (jy(n)) {
            const T = "srgb"
              , A = "srgb-linear";
            m === "encoding" ? (m = "colorSpace",
            y = y === 3001 ? T : A) : m === "outputEncoding" && (m = "outputColorSpace",
            y = y === 3001 ? T : A)
        }
        let g = n
          , _ = g[m];
        if (M.length && (_ = M.reduce((w,T)=>w[T], n),
        !(_ && _.set))) {
            const [w,...T] = M.reverse();
            g = T.reverse().reduce((A,C)=>A[C], n),
            m = w
        }
        if (y === GI + "remove")
            if (g.constructor) {
                let w = _R.get(g.constructor);
                w || (w = new g.constructor,
                _R.set(g.constructor, w)),
                y = w[m]
            } else
                y = 0;
        if (S)
            y ? s.handlers[m] = y : delete s.handlers[m],
            s.eventCount = Object.keys(s.handlers).length;
        else if (_ && _.set && (_.copy || _ instanceof Wa)) {
            if (Array.isArray(y))
                _.fromArray ? _.fromArray(y) : _.set(...y);
            else if (_.copy && y && y.constructor && _.constructor === y.constructor)
                _.copy(y);
            else if (y !== void 0) {
                const w = _ instanceof Oe;
                !w && _.setScalar ? _.setScalar(y) : _ instanceof Wa && y instanceof Wa ? _.mask = y.mask : _.set(y),
                !zI() && !a.linear && w && _.convertSRGBToLinear()
            }
        } else if (g[m] = y,
        g[m]instanceof en && g[m].format === Ii && g[m].type === to) {
            const w = g[m];
            jy(w) && jy(a.gl) ? w.colorSpace = a.gl.outputColorSpace : w.encoding = a.gl.outputEncoding
        }
        rc(n)
    }
    if (s.parent && a.internal && n.raycast && d !== s.eventCount) {
        const p = a.internal.interaction.indexOf(n);
        p > -1 && a.internal.interaction.splice(p, 1),
        s.eventCount && a.internal.interaction.push(n)
    }
    return !(f.length === 1 && f[0][0] === "onUpdate") && f.length && (r = n.__r3f) != null && r.parent && nS(n),
    n
}
function rc(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}
function nS(n) {
    n.onUpdate == null || n.onUpdate(n)
}
function $X(n, e) {
    n.manual || (BI(n) ? (n.left = e.width / -2,
    n.right = e.width / 2,
    n.top = e.height / 2,
    n.bottom = e.height / -2) : n.aspect = e.width / e.height,
    n.updateProjectionMatrix(),
    n.updateMatrixWorld())
}
function Kp(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}
function jX() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e)
        return Sc.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
        return Sc.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
        return Sc.ContinuousEventPriority;
    default:
        return Sc.DefaultEventPriority
    }
}
function $I(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e),
    t.size === 0 && (n.delete(i),
    r.target.releasePointerCapture(i)))
}
function YX(n, e) {
    const {internal: t} = n.getState();
    t.interaction = t.interaction.filter(i=>i !== e),
    t.initialHits = t.initialHits.filter(i=>i !== e),
    t.hovered.forEach((i,r)=>{
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }
    ),
    t.capturedMap.forEach((i,r)=>{
        $I(t.capturedMap, e, i, r)
    }
    )
}
function qX(n) {
    function e(l) {
        const {internal: f} = n.getState()
          , d = l.offsetX - f.initialClick[0]
          , h = l.offsetY - f.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h))
    }
    function t(l) {
        return l.filter(f=>["Move", "Over", "Enter", "Out", "Leave"].some(d=>{
            var h;
            return (h = f.__r3f) == null ? void 0 : h.handlers["onPointer" + d]
        }
        ))
    }
    function i(l, f) {
        const d = n.getState()
          , h = new Set
          , p = []
          , m = f ? f(d.internal.interaction) : d.internal.interaction;
        for (let g = 0; g < m.length; g++) {
            const _ = of(m[g]);
            _ && (_.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(l, d);
        function y(g) {
            const _ = of(g);
            if (!_ || !_.events.enabled || _.raycaster.camera === null)
                return [];
            if (_.raycaster.camera === void 0) {
                var w;
                _.events.compute == null || _.events.compute(l, _, (w = _.previousRoot) == null ? void 0 : w.getState()),
                _.raycaster.camera === void 0 && (_.raycaster.camera = null)
            }
            return _.raycaster.camera ? _.raycaster.intersectObject(g, !0) : []
        }
        let S = m.flatMap(y).sort((g,_)=>{
            const w = of(g.object)
              , T = of(_.object);
            return !w || !T ? g.distance - _.distance : T.events.priority - w.events.priority || g.distance - _.distance
        }
        ).filter(g=>{
            const _ = Kp(g);
            return h.has(_) ? !1 : (h.add(_),
            !0)
        }
        );
        d.events.filter && (S = d.events.filter(S, d));
        for (const g of S) {
            let _ = g.object;
            for (; _; ) {
                var M;
                (M = _.__r3f) != null && M.eventCount && p.push({
                    ...g,
                    eventObject: _
                }),
                _ = _.parent
            }
        }
        if ("pointerId"in l && d.internal.capturedMap.has(l.pointerId))
            for (let g of d.internal.capturedMap.get(l.pointerId).values())
                h.has(Kp(g.intersection)) || p.push(g.intersection);
        return p
    }
    function r(l, f, d, h) {
        const p = n.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const y of l) {
                const S = of(y.object) || p
                  , {raycaster: M, pointer: g, camera: _, internal: w} = S
                  , T = new z(g.x,g.y,0).unproject(_)
                  , A = L=>{
                    var Y, Z;
                    return (Y = (Z = w.capturedMap.get(L)) == null ? void 0 : Z.has(y.eventObject)) != null ? Y : !1
                }
                  , C = L=>{
                    const Y = {
                        intersection: y,
                        target: f.target
                    };
                    w.capturedMap.has(L) ? w.capturedMap.get(L).set(y.eventObject, Y) : w.capturedMap.set(L, new Map([[y.eventObject, Y]])),
                    f.target.setPointerCapture(L)
                }
                  , P = L=>{
                    const Y = w.capturedMap.get(L);
                    Y && $I(w.capturedMap, y.eventObject, Y, L)
                }
                ;
                let N = {};
                for (let L in f) {
                    let Y = f[L];
                    typeof Y != "function" && (N[L] = Y)
                }
                let b = {
                    ...y,
                    ...N,
                    pointer: g,
                    intersections: l,
                    stopped: m.stopped,
                    delta: d,
                    unprojectedPoint: T,
                    ray: M.ray,
                    camera: _,
                    stopPropagation() {
                        const L = "pointerId"in f && w.capturedMap.get(f.pointerId);
                        if ((!L || L.has(y.eventObject)) && (b.stopped = m.stopped = !0,
                        w.hovered.size && Array.from(w.hovered.values()).find(Y=>Y.eventObject === y.eventObject))) {
                            const Y = l.slice(0, l.indexOf(y));
                            s([...Y, y])
                        }
                    },
                    target: {
                        hasPointerCapture: A,
                        setPointerCapture: C,
                        releasePointerCapture: P
                    },
                    currentTarget: {
                        hasPointerCapture: A,
                        setPointerCapture: C,
                        releasePointerCapture: P
                    },
                    nativeEvent: f
                };
                if (h(b),
                m.stopped === !0)
                    break
            }
        }
        return l
    }
    function s(l) {
        const {internal: f} = n.getState();
        for (const d of f.hovered.values())
            if (!l.length || !l.find(h=>h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) {
                const p = d.eventObject.__r3f
                  , m = p == null ? void 0 : p.handlers;
                if (f.hovered.delete(Kp(d)),
                p != null && p.eventCount) {
                    const y = {
                        ...d,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(y),
                    m.onPointerLeave == null || m.onPointerLeave(y)
                }
            }
    }
    function o(l, f) {
        for (let d = 0; d < f.length; d++) {
            const h = f[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l)
        }
    }
    function a(l) {
        switch (l) {
        case "onPointerLeave":
        case "onPointerCancel":
            return ()=>s([]);
        case "onLostPointerCapture":
            return f=>{
                const {internal: d} = n.getState();
                "pointerId"in f && d.capturedMap.has(f.pointerId) && requestAnimationFrame(()=>{
                    d.capturedMap.has(f.pointerId) && (d.capturedMap.delete(f.pointerId),
                    s([]))
                }
                )
            }
        }
        return function(d) {
            const {onPointerMissed: h, internal: p} = n.getState();
            p.lastEvent.current = d;
            const m = l === "onPointerMove"
              , y = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick"
              , M = i(d, m ? t : void 0)
              , g = y ? e(d) : 0;
            l === "onPointerDown" && (p.initialClick = [d.offsetX, d.offsetY],
            p.initialHits = M.map(w=>w.eventObject)),
            y && !M.length && g <= 2 && (o(d, p.interaction),
            h && h(d)),
            m && s(M);
            function _(w) {
                const T = w.eventObject
                  , A = T.__r3f
                  , C = A == null ? void 0 : A.handlers;
                if (A != null && A.eventCount)
                    if (m) {
                        if (C.onPointerOver || C.onPointerEnter || C.onPointerOut || C.onPointerLeave) {
                            const P = Kp(w)
                              , N = p.hovered.get(P);
                            N ? N.stopped && w.stopPropagation() : (p.hovered.set(P, w),
                            C.onPointerOver == null || C.onPointerOver(w),
                            C.onPointerEnter == null || C.onPointerEnter(w))
                        }
                        C.onPointerMove == null || C.onPointerMove(w)
                    } else {
                        const P = C[l];
                        P ? (!y || p.initialHits.includes(T)) && (o(d, p.interaction.filter(N=>!p.initialHits.includes(N))),
                        P(w)) : y && p.initialHits.includes(T) && o(d, p.interaction.filter(N=>!p.initialHits.includes(N)))
                    }
            }
            r(M, d, g, _)
        }
    }
    return {
        handlePointer: a
    }
}
const jI = n=>!!(n != null && n.render)
  , YI = ke.createContext(null)
  , KX = (n,e)=>{
    const t = PX((a,l)=>{
        const f = new z
          , d = new z
          , h = new z;
        function p(g=l().camera, _=d, w=l().size) {
            const {width: T, height: A, top: C, left: P} = w
              , N = T / A;
            _ instanceof z ? h.copy(_) : h.set(..._);
            const b = g.getWorldPosition(f).distanceTo(h);
            if (BI(g))
                return {
                    width: T / g.zoom,
                    height: A / g.zoom,
                    top: C,
                    left: P,
                    factor: 1,
                    distance: b,
                    aspect: N
                };
            {
                const L = g.fov * Math.PI / 180
                  , Y = 2 * Math.tan(L / 2) * b
                  , Z = Y * (T / A);
                return {
                    width: Z,
                    height: Y,
                    top: C,
                    left: P,
                    factor: T / Z,
                    distance: b,
                    aspect: N
                }
            }
        }
        let m;
        const y = g=>a(_=>({
            performance: {
                ..._.performance,
                current: g
            }
        }))
          , S = new be;
        return {
            set: a,
            get: l,
            gl: null,
            camera: null,
            raycaster: null,
            events: {
                priority: 1,
                enabled: !0,
                connected: !1
            },
            xr: null,
            scene: null,
            invalidate: (g=1)=>n(l(), g),
            advance: (g,_)=>e(g, _, l()),
            legacy: !1,
            linear: !1,
            flat: !1,
            controls: null,
            clock: new dw,
            pointer: S,
            mouse: S,
            frameloop: "always",
            onPointerMissed: void 0,
            performance: {
                current: 1,
                min: .5,
                max: 1,
                debounce: 200,
                regress: ()=>{
                    const g = l();
                    m && clearTimeout(m),
                    g.performance.current !== g.performance.min && y(g.performance.min),
                    m = setTimeout(()=>y(l().performance.max), g.performance.debounce)
                }
            },
            size: {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                updateStyle: !1
            },
            viewport: {
                initialDpr: 0,
                dpr: 0,
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                aspect: 0,
                distance: 0,
                factor: 0,
                getCurrentViewport: p
            },
            setEvents: g=>a(_=>({
                ..._,
                events: {
                    ..._.events,
                    ...g
                }
            })),
            setSize: (g,_,w,T,A)=>{
                const C = l().camera
                  , P = {
                    width: g,
                    height: _,
                    top: T || 0,
                    left: A || 0,
                    updateStyle: w
                };
                a(N=>({
                    size: P,
                    viewport: {
                        ...N.viewport,
                        ...p(C, d, P)
                    }
                }))
            }
            ,
            setDpr: g=>a(_=>{
                const w = WI(g);
                return {
                    viewport: {
                        ..._.viewport,
                        dpr: w,
                        initialDpr: _.viewport.initialDpr || w
                    }
                }
            }
            ),
            setFrameloop: (g="always")=>{
                const _ = l().clock;
                _.stop(),
                _.elapsedTime = 0,
                g !== "never" && (_.start(),
                _.elapsedTime = 0),
                a(()=>({
                    frameloop: g
                }))
            }
            ,
            previousRoot: void 0,
            internal: {
                active: !1,
                priority: 0,
                frames: 0,
                lastEvent: ke.createRef(),
                interaction: [],
                hovered: new Map,
                subscribers: [],
                initialClick: [0, 0],
                initialHits: [],
                capturedMap: new Map,
                subscribe: (g,_,w)=>{
                    const T = l().internal;
                    return T.priority = T.priority + (_ > 0 ? 1 : 0),
                    T.subscribers.push({
                        ref: g,
                        priority: _,
                        store: w
                    }),
                    T.subscribers = T.subscribers.sort((A,C)=>A.priority - C.priority),
                    ()=>{
                        const A = l().internal;
                        A != null && A.subscribers && (A.priority = A.priority - (_ > 0 ? 1 : 0),
                        A.subscribers = A.subscribers.filter(C=>C.ref !== g))
                    }
                }
            }
        }
    }
    )
      , i = t.getState();
    let r = i.size
      , s = i.viewport.dpr
      , o = i.camera;
    return t.subscribe(()=>{
        const {camera: a, size: l, viewport: f, gl: d, set: h} = t.getState();
        if (l !== r || f.dpr !== s) {
            var p;
            r = l,
            s = f.dpr,
            $X(a, l),
            d.setPixelRatio(f.dpr);
            const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
            d.setSize(l.width, l.height, m)
        }
        a !== o && (o = a,
        h(m=>({
            viewport: {
                ...m.viewport,
                ...m.viewport.getCurrentViewport(a)
            }
        })))
    }
    ),
    t.subscribe(a=>n(a)),
    t
}
;
let Zp, ZX = new Set, QX = new Set, JX = new Set;
function Ky(n, e) {
    if (n.size)
        for (const {callback: t} of n.values())
            t(e)
}
function af(n, e) {
    switch (n) {
    case "before":
        return Ky(ZX, e);
    case "after":
        return Ky(QX, e);
    case "tail":
        return Ky(JX, e)
    }
}
let Zy, Qy;
function Jy(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime,
    e.clock.oldTime = e.clock.elapsedTime,
    e.clock.elapsedTime = n),
    Zy = e.internal.subscribers,
    Zp = 0; Zp < Zy.length; Zp++)
        Qy = Zy[Zp],
        Qy.ref.current(Qy.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    e.internal.frames = Math.max(0, e.internal.frames - 1),
    e.frameloop === "always" ? 1 : e.internal.frames
}
function e$(n) {
    let e = !1, t, i, r;
    function s(l) {
        i = requestAnimationFrame(s),
        e = !0,
        t = 0,
        af("before", l);
        for (const d of n.values()) {
            var f;
            r = d.store.getState(),
            r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((f = r.gl.xr) != null && f.isPresenting) && (t += Jy(l, r))
        }
        if (af("after", l),
        t === 0)
            return af("tail", l),
            e = !1,
            cancelAnimationFrame(i)
    }
    function o(l, f=1) {
        var d;
        if (!l)
            return n.forEach(h=>o(h.store.getState()), f);
        (d = l.gl.xr) != null && d.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + f),
        e || (e = !0,
        requestAnimationFrame(s)))
    }
    function a(l, f=!0, d, h) {
        if (f && af("before", l),
        d)
            Jy(l, d, h);
        else
            for (const p of n.values())
                Jy(l, p.store.getState());
        f && af("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}
function qI() {
    const n = ke.useContext(YI);
    if (!n)
        throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}
function KI(n=t=>t, e) {
    return qI()(n, e)
}
function ZI(n, e=0) {
    const t = qI()
      , i = t.getState().internal.subscribe
      , r = VI(n);
    return Gd(()=>i(r, e, t), [e, i, t]),
    null
}
function QI(n, e) {
    return function(t, ...i) {
        const r = new t;
        return n && n(r),
        Promise.all(i.map(s=>new Promise((o,a)=>r.load(s, l=>{
            l.scene && Object.assign(l, WX(l.scene)),
            o(l)
        }
        , e, l=>a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}
function Rr(n, e, t, i) {
    const r = Array.isArray(e) ? e : [e]
      , s = kX(QI(t, i), [n, ...r], {
        equal: nn.equ
    });
    return Array.isArray(e) ? s : s[0]
}
Rr.preload = function(n, e, t) {
    const i = Array.isArray(e) ? e : [e];
    return OX(QI(t), [n, ...i])
}
;
Rr.clear = function(n, e) {
    const t = Array.isArray(e) ? e : [e];
    return FX([n, ...t])
}
;
const nu = new Map
  , {invalidate: wR, advance: MR} = e$(nu)
  , {reconciler: ng, applyProps: ec} = BX(nu, jX)
  , tc = {
    objects: "shallow",
    strict: !1
}
  , t$ = (n,e)=>{
    const t = typeof n == "function" ? n(e) : n;
    return jI(t) ? t : new X1({
        powerPreference: "high-performance",
        canvas: e,
        antialias: !0,
        alpha: !0,
        ...n
    })
}
;
function n$(n, e) {
    if (e)
        return e;
    if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {width: t, height: i, top: r, left: s} = n.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: i,
            top: r,
            left: s
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
        return {
            width: n.width,
            height: n.height,
            top: 0,
            left: 0
        };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}
function i$(n) {
    const e = nu.get(n)
      , t = e == null ? void 0 : e.fiber
      , i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error
      , s = i || KX(wR, MR)
      , o = t || ng.createContainer(s, Sc.ConcurrentRoot, null, !1, null, "", r, null);
    e || nu.set(n, {
        fiber: o,
        store: s
    });
    let a, l = !1, f;
    return {
        configure(d={}) {
            let {gl: h, size: p, scene: m, events: y, onCreated: S, shadows: M=!1, linear: g=!1, flat: _=!1, legacy: w=!1, orthographic: T=!1, frameloop: A="always", dpr: C=[1, 2], performance: P, raycaster: N, camera: b, onPointerMissed: L} = d
              , Y = s.getState()
              , Z = Y.gl;
            Y.gl || Y.set({
                gl: Z = t$(h, n)
            });
            let $ = Y.raycaster;
            $ || Y.set({
                raycaster: $ = new LI
            });
            const {params: Q, ...ie} = N || {};
            if (nn.equ(ie, $, tc) || ec($, {
                ...ie
            }),
            nn.equ(Q, $.params, tc) || ec($, {
                params: {
                    ...$.params,
                    ...Q
                }
            }),
            !Y.camera || Y.camera === f && !nn.equ(f, b, tc)) {
                f = b;
                const ue = b instanceof Rd
                  , I = ue ? b : T ? new dl(0,0,0,0,.1,1e3) : new Pn(75,0,.1,1e3);
                ue || (I.position.z = 5,
                b && ec(I, b),
                !Y.camera && !(b != null && b.rotation) && I.lookAt(0, 0, 0)),
                Y.set({
                    camera: I
                })
            }
            if (!Y.scene) {
                let ue;
                m instanceof tg ? ue = m : (ue = new tg,
                m && ec(ue, m)),
                Y.set({
                    scene: ic(ue)
                })
            }
            if (!Y.xr) {
                const ue = (O,J)=>{
                    const F = s.getState();
                    F.frameloop !== "never" && MR(O, !0, F, J)
                }
                  , I = ()=>{
                    const O = s.getState();
                    O.gl.xr.enabled = O.gl.xr.isPresenting,
                    O.gl.xr.setAnimationLoop(O.gl.xr.isPresenting ? ue : null),
                    O.gl.xr.isPresenting || wR(O)
                }
                  , U = {
                    connect() {
                        const O = s.getState().gl;
                        O.xr.addEventListener("sessionstart", I),
                        O.xr.addEventListener("sessionend", I)
                    },
                    disconnect() {
                        const O = s.getState().gl;
                        O.xr.removeEventListener("sessionstart", I),
                        O.xr.removeEventListener("sessionend", I)
                    }
                };
                Z.xr && U.connect(),
                Y.set({
                    xr: U
                })
            }
            if (Z.shadowMap) {
                const ue = Z.shadowMap.enabled
                  , I = Z.shadowMap.type;
                if (Z.shadowMap.enabled = !!M,
                nn.boo(M))
                    Z.shadowMap.type = bc;
                else if (nn.str(M)) {
                    var fe;
                    const U = {
                        basic: BP,
                        percentage: l0,
                        soft: bc,
                        variance: Hr
                    };
                    Z.shadowMap.type = (fe = U[M]) != null ? fe : bc
                } else
                    nn.obj(M) && Object.assign(Z.shadowMap, M);
                (ue !== Z.shadowMap.enabled || I !== Z.shadowMap.type) && (Z.shadowMap.needsUpdate = !0)
            }
            const le = zI();
            le && ("enabled"in le ? le.enabled = !w : "legacyMode"in le && (le.legacyMode = w)),
            ec(Z, {
                outputEncoding: g ? 3e3 : 3001,
                toneMapping: _ ? qr : I1
            }),
            Y.legacy !== w && Y.set(()=>({
                legacy: w
            })),
            Y.linear !== g && Y.set(()=>({
                linear: g
            })),
            Y.flat !== _ && Y.set(()=>({
                flat: _
            })),
            h && !nn.fun(h) && !jI(h) && !nn.equ(h, Z, tc) && ec(Z, h),
            y && !Y.events.handlers && Y.set({
                events: y(s)
            });
            const X = n$(n, p);
            return nn.equ(X, Y.size, tc) || Y.setSize(X.width, X.height, X.updateStyle, X.top, X.left),
            C && Y.viewport.dpr !== WI(C) && Y.setDpr(C),
            Y.frameloop !== A && Y.setFrameloop(A),
            Y.onPointerMissed || Y.set({
                onPointerMissed: L
            }),
            P && !nn.equ(P, Y.performance, tc) && Y.set(ue=>({
                performance: {
                    ...ue.performance,
                    ...P
                }
            })),
            a = S,
            l = !0,
            this
        },
        render(d) {
            return l || this.configure(),
            ng.updateContainer(ke.createElement(r$, {
                store: s,
                children: d,
                onCreated: a,
                rootElement: n
            }), o, null, ()=>{}
            ),
            s
        },
        unmount() {
            JI(n)
        }
    }
}
function r$({store: n, children: e, onCreated: t, rootElement: i}) {
    return Gd(()=>{
        const r = n.getState();
        r.set(s=>({
            internal: {
                ...s.internal,
                active: !0
            }
        })),
        t && t(r),
        n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }
    , []),
    ke.createElement(YI.Provider, {
        value: n
    }, e)
}
function JI(n, e) {
    const t = nu.get(n)
      , i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1),
        ng.updateContainer(null, i, null, ()=>{
            r && setTimeout(()=>{
                try {
                    var s, o, a, l;
                    r.events.disconnect == null || r.events.disconnect(),
                    (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(),
                    (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(),
                    (l = r.gl) != null && l.xr && r.xr.disconnect(),
                    XX(r),
                    nu.delete(n),
                    e && e(n)
                } catch {}
            }
            , 500)
        }
        )
    }
}
ng.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: ke.version
});
function ig() {
    return ig = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }
    ,
    ig.apply(this, arguments)
}
function iS(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);
    function l() {
        var d = Date.now() - o;
        d < e && d >= 0 ? i = setTimeout(l, e - d) : (i = null,
        t || (a = n.apply(s, r),
        s = r = null))
    }
    var f = function() {
        s = this,
        r = arguments,
        o = Date.now();
        var d = t && !i;
        return i || (i = setTimeout(l, e)),
        d && (a = n.apply(s, r),
        s = r = null),
        a
    };
    return f.clear = function() {
        i && (clearTimeout(i),
        i = null)
    }
    ,
    f.flush = function() {
        i && (a = n.apply(s, r),
        s = r = null,
        clearTimeout(i),
        i = null)
    }
    ,
    f
}
iS.debounce = iS;
var s$ = iS;
const ER = fd(s$);
function o$(n) {
    let {debounce: e, scroll: t, polyfill: i, offsetSize: r} = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {
    }
    : window.ResizeObserver);
    if (!s)
        throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o,a] = ke.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    })
      , l = ke.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    })
      , f = e ? typeof e == "number" ? e : e.scroll : null
      , d = e ? typeof e == "number" ? e : e.resize : null
      , h = ke.useRef(!1);
    ke.useEffect(()=>(h.current = !0,
    ()=>void (h.current = !1)));
    const [p,m,y] = ke.useMemo(()=>{
        const _ = ()=>{
            if (!l.current.element)
                return;
            const {left: w, top: T, width: A, height: C, bottom: P, right: N, x: b, y: L} = l.current.element.getBoundingClientRect()
              , Y = {
                left: w,
                top: T,
                width: A,
                height: C,
                bottom: P,
                right: N,
                x: b,
                y: L
            };
            l.current.element instanceof HTMLElement && r && (Y.height = l.current.element.offsetHeight,
            Y.width = l.current.element.offsetWidth),
            Object.freeze(Y),
            h.current && !u$(l.current.lastBounds, Y) && a(l.current.lastBounds = Y)
        }
        ;
        return [_, d ? ER(_, d) : _, f ? ER(_, f) : _]
    }
    , [a, r, f, d]);
    function S() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(_=>_.removeEventListener("scroll", y, !0)),
        l.current.scrollContainers = null),
        l.current.resizeObserver && (l.current.resizeObserver.disconnect(),
        l.current.resizeObserver = null)
    }
    function M() {
        l.current.element && (l.current.resizeObserver = new s(y),
        l.current.resizeObserver.observe(l.current.element),
        t && l.current.scrollContainers && l.current.scrollContainers.forEach(_=>_.addEventListener("scroll", y, {
            capture: !0,
            passive: !0
        })))
    }
    const g = _=>{
        !_ || _ === l.current.element || (S(),
        l.current.element = _,
        l.current.scrollContainers = e3(_),
        M())
    }
    ;
    return l$(y, !!t),
    a$(m),
    ke.useEffect(()=>{
        S(),
        M()
    }
    , [t, y, m]),
    ke.useEffect(()=>S, []),
    [g, o, p]
}
function a$(n) {
    ke.useEffect(()=>{
        const e = n;
        return window.addEventListener("resize", e),
        ()=>void window.removeEventListener("resize", e)
    }
    , [n])
}
function l$(n, e) {
    ke.useEffect(()=>{
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }),
            ()=>void window.removeEventListener("scroll", t, !0)
        }
    }
    , [n, e])
}
function e3(n) {
    const e = [];
    if (!n || n === document.body)
        return e;
    const {overflow: t, overflowX: i, overflowY: r} = window.getComputedStyle(n);
    return [t, i, r].some(s=>s === "auto" || s === "scroll") && e.push(n),
    [...e, ...e3(n.parentElement)]
}
const c$ = ["x", "y", "top", "bottom", "left", "right", "width", "height"]
  , u$ = (n,e)=>c$.every(t=>n[t] === e[t]);
var f$ = Object.defineProperty
  , d$ = Object.defineProperties
  , h$ = Object.getOwnPropertyDescriptors
  , TR = Object.getOwnPropertySymbols
  , p$ = Object.prototype.hasOwnProperty
  , m$ = Object.prototype.propertyIsEnumerable
  , AR = (n,e,t)=>e in n ? f$(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , RR = (n,e)=>{
    for (var t in e || (e = {}))
        p$.call(e, t) && AR(n, t, e[t]);
    if (TR)
        for (var t of TR(e))
            m$.call(e, t) && AR(n, t, e[t]);
    return n
}
  , g$ = (n,e)=>d$(n, h$(e));
function t3(n, e, t) {
    if (!n)
        return;
    if (t(n) === !0)
        return n;
    let i = e ? n.return : n.child;
    for (; i; ) {
        const r = t3(i, e, t);
        if (r)
            return r;
        i = e ? null : i.sibling
    }
}
function n3(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const vw = n3(ke.createContext(null));
class i3 extends ke.Component {
    render() {
        return ke.createElement(vw.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {ReactCurrentOwner: CR, ReactCurrentDispatcher: bR} = ke.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function v$() {
    const n = ke.useContext(vw);
    if (n === null)
        throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = ke.useId();
    return ke.useMemo(()=>{
        for (const i of [CR == null ? void 0 : CR.current, n, n == null ? void 0 : n.alternate]) {
            if (!i)
                continue;
            const r = t3(i, !1, s=>{
                let o = s.memoizedState;
                for (; o; ) {
                    if (o.memoizedState === e)
                        return !0;
                    o = o.next
                }
            }
            );
            if (r)
                return r
        }
    }
    , [n, e])
}
function y$() {
    var n, e;
    const t = v$()
      , [i] = ke.useState(()=>new Map);
    i.clear();
    let r = t;
    for (; r; ) {
        const s = (n = r.type) == null ? void 0 : n._context;
        s && s !== vw && !i.has(s) && i.set(s, (e = bR == null ? void 0 : bR.current) == null ? void 0 : e.readContext(n3(s))),
        r = r.return
    }
    return i
}
function _$() {
    const n = y$();
    return ke.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>i=>ke.createElement(e, null, ke.createElement(t.Provider, g$(RR({}, i), {
        value: n.get(t)
    }))), e=>ke.createElement(i3, RR({}, e))), [n])
}
const e_ = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};
function x$(n) {
    const {handlePointer: e} = qX(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1),
            i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(e_).reduce((t,i)=>({
            ...t,
            [i]: e(i)
        }), {}),
        update: ()=>{
            var t;
            const {events: i, internal: r} = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        }
        ,
        connect: t=>{
            var i;
            const {set: r, events: s} = n.getState();
            s.disconnect == null || s.disconnect(),
            r(o=>({
                events: {
                    ...o.events,
                    connected: t
                }
            })),
            Object.entries((i = s.handlers) != null ? i : []).forEach(([o,a])=>{
                const [l,f] = e_[o];
                t.addEventListener(l, a, {
                    passive: f
                })
            }
            )
        }
        ,
        disconnect: ()=>{
            const {set: t, events: i} = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s,o])=>{
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = e_[s];
                        i.connected.removeEventListener(a, o)
                    }
                }
                ),
                t(s=>({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const S$ = ke.forwardRef(function({children: e, fallback: t, resize: i, style: r, gl: s, events: o=x$, eventSource: a, eventPrefix: l, shadows: f, linear: d, flat: h, legacy: p, orthographic: m, frameloop: y, dpr: S, performance: M, raycaster: g, camera: _, onPointerMissed: w, onCreated: T, ...A}, C) {
    ke.useMemo(()=>zX(RX), []);
    const P = _$()
      , [N,b] = o$({
        scroll: !0,
        debounce: {
            scroll: 50,
            resize: 0
        },
        ...i
    })
      , L = ke.useRef(null)
      , Y = ke.useRef(null);
    ke.useImperativeHandle(C, ()=>L.current);
    const Z = VI(w)
      , [$,Q] = ke.useState(!1)
      , [ie,fe] = ke.useState(!1);
    if ($)
        throw $;
    if (ie)
        throw ie;
    const le = ke.useRef(null);
    Gd(()=>{
        const j = L.current;
        b.width > 0 && b.height > 0 && j && (le.current || (le.current = i$(j)),
        le.current.configure({
            gl: s,
            events: o,
            shadows: f,
            linear: d,
            flat: h,
            legacy: p,
            orthographic: m,
            frameloop: y,
            dpr: S,
            performance: M,
            raycaster: g,
            camera: _,
            size: b,
            onPointerMissed: (...X)=>Z.current == null ? void 0 : Z.current(...X),
            onCreated: X=>{
                X.events.connect == null || X.events.connect(a ? VX(a) ? a.current : a : Y.current),
                l && X.setEvents({
                    compute: (ue,I)=>{
                        const U = ue[l + "X"]
                          , O = ue[l + "Y"];
                        I.pointer.set(U / I.size.width * 2 - 1, -(O / I.size.height) * 2 + 1),
                        I.raycaster.setFromCamera(I.pointer, I.camera)
                    }
                }),
                T == null || T(X)
            }
        }),
        le.current.render(ke.createElement(P, null, ke.createElement(HI, {
            set: fe
        }, ke.createElement(ke.Suspense, {
            fallback: ke.createElement(HX, {
                set: Q
            })
        }, e)))))
    }
    ),
    ke.useEffect(()=>{
        const j = L.current;
        if (j)
            return ()=>JI(j)
    }
    , []);
    const D = a ? "none" : "auto";
    return ke.createElement("div", ig({
        ref: Y,
        style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: D,
            ...r
        }
    }, A), ke.createElement("div", {
        ref: N,
        style: {
            width: "100%",
            height: "100%"
        }
    }, ke.createElement("canvas", {
        ref: L,
        style: {
            display: "block"
        }
    }, t)))
})
  , w$ = ke.forwardRef(function(e, t) {
    return ke.createElement(i3, null, ke.createElement(S$, ig({}, e, {
        ref: t
    })))
})
  , r3 = n=>({
    x: n.x * 2 + 50 - 5,
    y: n.z * 2 + 50 - 5
})
  , M$ = n=>{
    const {boundingBox: e} = n.geometry;
    return e ? (e.max.y - e.min.y) / 2 : 0
}
  , PR = 1;
let Qp = !1;
const t_ = new be
  , gs = new z;
let n_ = 0;
const E$ = ()=>{
    const [n,e] = gx(OP)
      , t = ke.useRef(null)
      , {scene: i, camera: r, raycaster: s, gl: o, frameloop: a, setFrameloop: l} = KI()
      , f = ()=>{
        const p = i.getObjectByName("floor")
          , m = s.intersectObject(p)
          , y = t.current
          , S = i.getObjectByName("pointerMesh");
        if (y)
            for (const M of m) {
                M.object.name === "floor" && (gs.x = M.point.x,
                gs.y = .3,
                gs.z = M.point.z,
                y.lookAt(gs),
                y.userData.moving = !0,
                S.position.x = gs.x,
                S.position.z = gs.z);
                break
            }
    }
      , d = ()=>{
        s.setFromCamera(t_, r),
        f()
    }
      , h = p=>{
        t_.x = p.clientX / window.innerWidth * 2 - 1,
        t_.y = -(p.clientY / window.innerHeight * 2 - 1)
    }
    ;
    return ke.useEffect(()=>{
        const p = S=>{
            Qp = !0,
            h(S)
        }
          , m = S=>{
            h(S)
        }
          , y = ()=>{
            Qp = !1
        }
        ;
        return o.domElement.addEventListener("pointerdown", p),
        o.domElement.addEventListener("pointermove", m),
        o.domElement.addEventListener("pointerup", y),
        ()=>{
            Qp = !1,
            o.domElement.removeEventListener("pointerdown", p),
            o.domElement.removeEventListener("pointermove", m),
            o.domElement.removeEventListener("pointerup", y)
        }
    }
    , []),
    ZI(()=>{
        const p = t.current;
        if (!p || !i.getObjectByName("house"))
            return;
        const y = document.getElementById("current-position-circle");
        if (y) {
            const M = r3(p.position);
            y.style.transform = `translate(${M.x}px, ${M.y}px)`
        }
        document.querySelector(".info-wrapper");
        const S = document.querySelector(".dialog-wrapper");
        Qp && d(),
        p.rotation.y += .01,
        p.userData.moving && (n_ = Math.atan2(gs.z - p.position.z, gs.x - p.position.x),
        p.position.x += Math.cos(n_) * .06,
        p.position.z += Math.sin(n_) * .06,
        r.position.x = 1 + p.position.x,
        r.position.z = 5 + p.position.z,
        p.position.x < -4 && p.position.z < -4 ? (e(1),
        S.style.display = "block") : p.position.x > 10 && p.position.z < -10 ? (e(2),
        S.style.display = "block") : (e(0),
        S.style.display = "none"),
        Math.abs(gs.x - p.position.x) < .03 && Math.abs(gs.z - p.position.z) < .03 && (p.userData.moving = !1))
    }
    ),
    es("mesh", {
        castShadow: !0,
        receiveShadow: !0,
        ref: t,
        name: "player",
        position: [0, PR / 2 + 1, 0],
        children: [ct("boxGeometry", {
            args: [1, PR, 1]
        }), ct("meshStandardMaterial", {
            color: "red"
        })]
    })
}
  , T$ = ()=>{
    const n = Rr(gl, "/images/floor.jpg");
    return n.wrapS = Yn,
    n.wrapT = Yn,
    n.repeat.x = 4,
    n.repeat.y = 4,
    es("mesh", {
        castShadow: !0,
        receiveShadow: !0,
        name: "floor",
        rotation: [-Math.PI / 2, 0, 0],
        children: [ct("planeGeometry", {
            args: [50, 50]
        }), ct("meshStandardMaterial", {
            shadowSide: hi,
            map: n
        })]
    })
}
  , A$ = ()=>es("mesh", {
    receiveShadow: !0,
    castShadow: !0,
    name: "pointerMesh",
    position: [0, .01, 0],
    rotation: [-Math.PI / 2, 0, 0],
    children: [ct("circleGeometry", {
        args: [1, 32]
    }), ct("meshStandardMaterial", {
        color: "yellow",
        transparent: !0,
        opacity: .8
    })]
});
function LR(n, e) {
    if (e === PL)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        n;
    if (e === Jm || e === U1) {
        let t = n.getIndex();
        if (t === null) {
            const o = []
              , a = n.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++)
                    o.push(l);
                n.setIndex(o),
                t = n.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                n
        }
        const i = t.count - 2
          , r = [];
        if (e === Jm)
            for (let o = 1; o <= i; o++)
                r.push(t.getX(0)),
                r.push(t.getX(o)),
                r.push(t.getX(o + 1));
        else
            for (let o = 0; o < i; o++)
                o % 2 === 0 ? (r.push(t.getX(o)),
                r.push(t.getX(o + 1)),
                r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)),
                r.push(t.getX(o + 1)),
                r.push(t.getX(o)));
        r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = n.clone();
        return s.setIndex(r),
        s.clearGroups(),
        s
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        n
}
class yw extends Mi {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new L$(t)
        }),
        this.register(function(t) {
            return new F$(t)
        }),
        this.register(function(t) {
            return new z$(t)
        }),
        this.register(function(t) {
            return new B$(t)
        }),
        this.register(function(t) {
            return new N$(t)
        }),
        this.register(function(t) {
            return new D$(t)
        }),
        this.register(function(t) {
            return new U$(t)
        }),
        this.register(function(t) {
            return new k$(t)
        }),
        this.register(function(t) {
            return new P$(t)
        }),
        this.register(function(t) {
            return new O$(t)
        }),
        this.register(function(t) {
            return new I$(t)
        }),
        this.register(function(t) {
            return new C$(t)
        }),
        this.register(function(t) {
            return new V$(t)
        }),
        this.register(function(t) {
            return new H$(t)
        })
    }
    load(e, t, i, r) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ol.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(f) {
            r ? r(f) : console.error(f),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , l = new Er(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(f) {
            try {
                s.parse(f, o, function(d) {
                    t(d),
                    s.manager.itemEnd(e)
                }, a)
            } catch (d) {
                a(d)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, i, r) {
        let s;
        const o = {}
          , a = {}
          , l = new TextDecoder;
        if (typeof e == "string")
            s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e,0,4)) === s3) {
                try {
                    o[Nt.KHR_BINARY_GLTF] = new G$(e)
                } catch (h) {
                    r && r(h);
                    return
                }
                s = JSON.parse(o[Nt.KHR_BINARY_GLTF].content)
            } else
                s = JSON.parse(l.decode(e));
        else
            s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const f = new nj(s,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        f.fileLoader.setRequestHeader(this.requestHeader);
        for (let d = 0; d < this.pluginCallbacks.length; d++) {
            const h = this.pluginCallbacks[d](f);
            a[h.name] = h,
            o[h.name] = !0
        }
        if (s.extensionsUsed)
            for (let d = 0; d < s.extensionsUsed.length; ++d) {
                const h = s.extensionsUsed[d]
                  , p = s.extensionsRequired || [];
                switch (h) {
                case Nt.KHR_MATERIALS_UNLIT:
                    o[h] = new b$;
                    break;
                case Nt.KHR_DRACO_MESH_COMPRESSION:
                    o[h] = new W$(s,this.dracoLoader);
                    break;
                case Nt.KHR_TEXTURE_TRANSFORM:
                    o[h] = new X$;
                    break;
                case Nt.KHR_MESH_QUANTIZATION:
                    o[h] = new $$;
                    break;
                default:
                    p.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        f.setExtensions(o),
        f.setPlugins(a),
        f.parse(i, r)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.parse(e, t, r, s)
        }
        )
    }
}
function R$() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const Nt = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class C$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , i = "light:" + e;
        let r = t.cache.get(i);
        if (r)
            return r;
        const s = t.json
          , l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let f;
        const d = new Oe(16777215);
        l.color !== void 0 && d.fromArray(l.color);
        const h = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            f = new E0(d),
            f.target.position.set(0, 0, -1),
            f.add(f.target);
            break;
        case "point":
            f = new ud(d),
            f.distance = h;
            break;
        case "spot":
            f = new M0(d),
            f.distance = h,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            f.angle = l.spot.outerConeAngle,
            f.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            f.target.position.set(0, 0, -1),
            f.add(f.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return f.position.set(0, 0, 0),
        f.decay = 2,
        Po(f, l),
        l.intensity !== void 0 && (f.intensity = l.intensity),
        f.name = t.createUniqueName(l.name || "light_" + e),
        r = Promise.resolve(f),
        t.cache.add(i, r),
        r
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , i = this.parser
          , s = i.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class b$ {
    constructor() {
        this.name = Nt.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Ki
    }
    extendParams(e, t, i) {
        const r = [];
        e.color = new Oe(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, lt))
        }
        return Promise.all(r)
    }
}
class P$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
class L$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new be(a,a)
        }
        return Promise.all(s)
    }
}
class I$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
class N$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Oe(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = r.extensions[this.name];
        return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor),
        o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, lt)),
        o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
class D$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
class U$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Oe(a[0],a[1],a[2]),
        Promise.all(s)
    }
}
class k$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = r.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
class O$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : ao
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = r.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Oe(a[0],a[1],a[2]),
        o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, lt)),
        Promise.all(s)
    }
}
class F$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , i = t.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[this.name])
            return null;
        const s = r.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class z$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , r = i.json
          , s = r.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = r.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const f = i.options.manager.getHandler(a.uri);
            f !== null && (l = f)
        }
        return this.detectSupport().then(function(f) {
            if (f)
                return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class B$ {
    constructor(e) {
        this.parser = e,
        this.name = Nt.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , r = i.json
          , s = r.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = r.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const f = i.options.manager.getHandler(a.uri);
            f !== null && (l = f)
        }
        return this.detectSupport().then(function(f) {
            if (f)
                return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class V$ {
    constructor(e) {
        this.name = Nt.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name]
              , s = this.parser.getDependency("buffer", r.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = r.byteOffset || 0
                  , f = r.byteLength || 0
                  , d = r.count
                  , h = r.byteStride
                  , p = new Uint8Array(a,l,f);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, h, p, r.mode, r.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(d * h);
                    return o.decodeGltfBuffer(new Uint8Array(m), d, h, p, r.mode, r.filter),
                    m
                })
            })
        } else
            return null
    }
}
class H$ {
    constructor(e) {
        this.name = Nt.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , i = t.nodes[e];
        if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
            return null;
        const r = t.meshes[i.mesh];
        for (const f of r.primitives)
            if (f.mode !== hr.TRIANGLES && f.mode !== hr.TRIANGLE_STRIP && f.mode !== hr.TRIANGLE_FAN && f.mode !== void 0)
                return null;
        const o = i.extensions[this.name].attributes
          , a = []
          , l = {};
        for (const f in o)
            a.push(this.parser.getDependency("accessor", o[f]).then(d=>(l[f] = d,
            l[f])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(f=>{
            const d = f.pop()
              , h = d.isGroup ? d.children : [d]
              , p = f[0].count
              , m = [];
            for (const y of h) {
                const S = new $e
                  , M = new z
                  , g = new In
                  , _ = new z(1,1,1)
                  , w = new j1(y.geometry,y.material,p);
                for (let T = 0; T < p; T++)
                    l.TRANSLATION && M.fromBufferAttribute(l.TRANSLATION, T),
                    l.ROTATION && g.fromBufferAttribute(l.ROTATION, T),
                    l.SCALE && _.fromBufferAttribute(l.SCALE, T),
                    w.setMatrixAt(T, S.compose(M, g, _));
                for (const T in l)
                    T !== "TRANSLATION" && T !== "ROTATION" && T !== "SCALE" && y.geometry.setAttribute(T, l[T]);
                Lt.prototype.copy.call(w, y),
                this.parser.assignFinalMaterial(w),
                m.push(w)
            }
            return d.isGroup ? (d.clear(),
            d.add(...m),
            d) : m[0]
        }
        ))
    }
}
const s3 = "glTF"
  , lf = 12
  , IR = {
    JSON: 1313821514,
    BIN: 5130562
};
class G$ {
    constructor(e) {
        this.name = Nt.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,lf)
          , i = new TextDecoder;
        if (this.header = {
            magic: i.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== s3)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const r = this.header.length - lf
          , s = new DataView(e,lf);
        let o = 0;
        for (; o < r; ) {
            const a = s.getUint32(o, !0);
            o += 4;
            const l = s.getUint32(o, !0);
            if (o += 4,
            l === IR.JSON) {
                const f = new Uint8Array(e,lf + o,a);
                this.content = i.decode(f)
            } else if (l === IR.BIN) {
                const f = lf + o;
                this.body = e.slice(f, f + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class W$ {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Nt.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json
          , r = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , f = {};
        for (const d in o) {
            const h = rS[d] || d.toLowerCase();
            a[h] = o[d]
        }
        for (const d in e.attributes) {
            const h = rS[d] || d.toLowerCase();
            if (o[d] !== void 0) {
                const p = i.accessors[e.attributes[d]]
                  , m = Nc[p.componentType];
                f[h] = m.name,
                l[h] = p.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(d) {
            return new Promise(function(h) {
                r.decodeDracoFile(d, function(p) {
                    for (const m in p.attributes) {
                        const y = p.attributes[m]
                          , S = l[m];
                        S !== void 0 && (y.normalized = S)
                    }
                    h(p)
                }, a, f)
            }
            )
        })
    }
}
class X$ {
    constructor() {
        this.name = Nt.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class $$ {
    constructor() {
        this.name = Nt.KHR_MESH_QUANTIZATION
    }
}
class o3 extends mu {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r * 3 + r;
        for (let o = 0; o !== r; o++)
            t[o] = i[s + o];
        return t
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , f = a * 3
          , d = r - t
          , h = (i - t) / d
          , p = h * h
          , m = p * h
          , y = e * f
          , S = y - f
          , M = -2 * m + 3 * p
          , g = m - p
          , _ = 1 - M
          , w = g - p + h;
        for (let T = 0; T !== a; T++) {
            const A = o[S + T + a]
              , C = o[S + T + l] * d
              , P = o[y + T + a]
              , N = o[y + T] * d;
            s[T] = _ * A + w * C + M * P + g * N
        }
        return s
    }
}
const j$ = new In;
class Y$ extends o3 {
    interpolate_(e, t, i, r) {
        const s = super.interpolate_(e, t, i, r);
        return j$.fromArray(s).normalize().toArray(s),
        s
    }
}
const hr = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , Nc = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , NR = {
    9728: _n,
    9729: dn,
    9984: td,
    9985: u0,
    9986: Pc,
    9987: ws
}
  , DR = {
    33071: On,
    33648: qc,
    10497: Yn
}
  , i_ = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , rS = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Eo = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , q$ = {
    CUBICSPLINE: void 0,
    LINEAR: el,
    STEP: Zc
}
  , r_ = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function K$(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Hd({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Zr
    })),
    n.DefaultMaterial
}
function cf(n, e, t) {
    for (const i in t.extensions)
        n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[i] = t.extensions[i])
}
function Po(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function Z$(n, e, t) {
    let i = !1
      , r = !1
      , s = !1;
    for (let f = 0, d = e.length; f < d; f++) {
        const h = e[f];
        if (h.POSITION !== void 0 && (i = !0),
        h.NORMAL !== void 0 && (r = !0),
        h.COLOR_0 !== void 0 && (s = !0),
        i && r && s)
            break
    }
    if (!i && !r && !s)
        return Promise.resolve(n);
    const o = []
      , a = []
      , l = [];
    for (let f = 0, d = e.length; f < d; f++) {
        const h = e[f];
        if (i) {
            const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
            o.push(p)
        }
        if (r) {
            const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
            a.push(p)
        }
        if (s) {
            const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
            l.push(p)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(f) {
        const d = f[0]
          , h = f[1]
          , p = f[2];
        return i && (n.morphAttributes.position = d),
        r && (n.morphAttributes.normal = h),
        s && (n.morphAttributes.color = p),
        n.morphTargetsRelative = !0,
        n
    })
}
function Q$(n, e) {
    if (n.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++)
            n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++)
                n.morphTargetDictionary[t[i]] = i
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function J$(n) {
    const e = n.extensions && n.extensions[Nt.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + UR(e.attributes) : t = n.indices + ":" + UR(n.attributes) + ":" + n.mode,
    t
}
function UR(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let i = 0, r = t.length; i < r; i++)
        e += t[i] + ":" + n[t[i]] + ";";
    return e
}
function sS(n) {
    switch (n) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function ej(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const tj = new $e;
class nj {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new R$,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let i = !1
          , r = !1
          , s = -1;
        typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
        r = navigator.userAgent.indexOf("Firefox") > -1,
        s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
        typeof createImageBitmap > "u" || i || r && s < 98 ? this.textureLoader = new gl(this.options.manager) : this.textureLoader = new RI(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Er(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this
          , r = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][r.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: r.asset,
                parser: i,
                userData: {}
            };
            cf(s, a, r),
            Po(a, r),
            Promise.all(i._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , i = this.json.meshes || [];
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let r = 0, s = e.length; r < s; r++) {
            const o = e[r];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1)
            return i;
        const r = i.clone()
          , s = (o,a)=>{
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [f,d] of o.children.entries())
                s(d, a.children[f])
        }
        ;
        return s(i, r),
        r.name += "_instance_" + e.uses[t]++,
        r
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r)
                return r
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let r = this.cache.get(i);
        if (!r) {
            switch (e) {
            case "scene":
                r = this.loadScene(t);
                break;
            case "node":
                r = this._invokeOne(function(s) {
                    return s.loadNode && s.loadNode(t)
                });
                break;
            case "mesh":
                r = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                r = this.loadAccessor(t);
                break;
            case "bufferView":
                r = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                r = this.loadBuffer(t);
                break;
            case "material":
                r = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                r = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                r = this.loadSkin(t);
                break;
            case "animation":
                r = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                r = this.loadCamera(t);
                break;
            default:
                if (r = this._invokeOne(function(s) {
                    return s != this && s.getDependency && s.getDependency(e, t)
                }),
                !r)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(i, r)
        }
        return r
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this
              , r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(r.map(function(s, o) {
                return i.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Nt.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function(s, o) {
            i.load(ol.resolveURL(t.uri, r.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
            const r = t.byteLength || 0
              , s = t.byteOffset || 0;
            return i.slice(s, s + r)
        })
    }
    loadAccessor(e) {
        const t = this
          , i = this.json
          , r = this.json.accessors[e];
        if (r.bufferView === void 0 && r.sparse === void 0) {
            const o = i_[r.type]
              , a = Nc[r.componentType]
              , l = r.normalized === !0
              , f = new a(r.count * o);
            return Promise.resolve(new Ht(f,o,l))
        }
        const s = [];
        return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null),
        r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , l = i_[r.type]
              , f = Nc[r.componentType]
              , d = f.BYTES_PER_ELEMENT
              , h = d * l
              , p = r.byteOffset || 0
              , m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0
              , y = r.normalized === !0;
            let S, M;
            if (m && m !== h) {
                const g = Math.floor(p / m)
                  , _ = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + g + ":" + r.count;
                let w = t.cache.get(_);
                w || (S = new f(a,g * m,r.count * m / d),
                w = new bd(S,m / d),
                t.cache.add(_, w)),
                M = new Jo(w,l,p % m / d,y)
            } else
                a === null ? S = new f(r.count * l) : S = new f(a,p,r.count * l),
                M = new Ht(S,l,y);
            if (r.sparse !== void 0) {
                const g = i_.SCALAR
                  , _ = Nc[r.sparse.indices.componentType]
                  , w = r.sparse.indices.byteOffset || 0
                  , T = r.sparse.values.byteOffset || 0
                  , A = new _(o[1],w,r.sparse.count * g)
                  , C = new f(o[2],T,r.sparse.count * l);
                a !== null && (M = new Ht(M.array.slice(),M.itemSize,M.normalized));
                for (let P = 0, N = A.length; P < N; P++) {
                    const b = A[P];
                    if (M.setX(b, C[P * l]),
                    l >= 2 && M.setY(b, C[P * l + 1]),
                    l >= 3 && M.setZ(b, C[P * l + 2]),
                    l >= 4 && M.setW(b, C[P * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return M
        })
    }
    loadTexture(e) {
        const t = this.json
          , i = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, i) {
        const r = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const f = this.loadImageSource(t, i).then(function(d) {
            d.flipY = !1,
            d.name = o.name || a.name || "",
            d.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (d.name = a.uri);
            const p = (s.samplers || {})[o.sampler] || {};
            return d.magFilter = NR[p.magFilter] || dn,
            d.minFilter = NR[p.minFilter] || ws,
            d.wrapS = DR[p.wrapS] || Yn,
            d.wrapT = DR[p.wrapT] || Yn,
            r.associations.set(d, {
                textures: e
            }),
            d
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = f,
        f
    }
    loadImageSource(e, t) {
        const i = this
          , r = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(h=>h.clone());
        const o = r.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , f = !1;
        if (o.bufferView !== void 0)
            l = i.getDependency("bufferView", o.bufferView).then(function(h) {
                f = !0;
                const p = new Blob([h],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(p),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const d = Promise.resolve(l).then(function(h) {
            return new Promise(function(p, m) {
                let y = p;
                t.isImageBitmapLoader === !0 && (y = function(S) {
                    const M = new en(S);
                    M.needsUpdate = !0,
                    p(M)
                }
                ),
                t.load(ol.resolveURL(h, s.path), y, void 0, m)
            }
            )
        }).then(function(h) {
            return f === !0 && a.revokeObjectURL(l),
            h.userData.mimeType = o.mimeType || ej(o.uri),
            h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            h
        });
        return this.sourceCache[e] = d,
        d
    }
    assignTexture(e, t, i, r) {
        const s = this;
        return this.getDependency("texture", i.index).then(function(o) {
            if (!o)
                return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (o = o.clone(),
            o.channel = i.texCoord),
            s.extensions[Nt.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[Nt.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[Nt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return r !== void 0 && (o.colorSpace = r),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const r = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new _0,
            Nn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new ni,
            Nn.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            this.cache.add(a, l)),
            i = l
        }
        if (r || s || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            r && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(),
            s && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            r && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(i))),
            i = l
        }
        e.material = i
    }
    getMaterialType() {
        return Hd
    }
    loadMaterial(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.materials[e];
        let o;
        const a = {}
          , l = s.extensions || {}
          , f = [];
        if (l[Nt.KHR_MATERIALS_UNLIT]) {
            const h = r[Nt.KHR_MATERIALS_UNLIT];
            o = h.getMaterialType(),
            f.push(h.extendParams(a, s, t))
        } else {
            const h = s.pbrMetallicRoughness || {};
            if (a.color = new Oe(1,1,1),
            a.opacity = 1,
            Array.isArray(h.baseColorFactor)) {
                const p = h.baseColorFactor;
                a.color.fromArray(p),
                a.opacity = p[3]
            }
            h.baseColorTexture !== void 0 && f.push(t.assignTexture(a, "map", h.baseColorTexture, lt)),
            a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1,
            a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1,
            h.metallicRoughnessTexture !== void 0 && (f.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)),
            f.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))),
            o = this._invokeOne(function(p) {
                return p.getMaterialType && p.getMaterialType(e)
            }),
            f.push(Promise.all(this._invokeAll(function(p) {
                return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = $r);
        const d = s.alphaMode || r_.OPAQUE;
        if (d === r_.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        d === r_.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== Ki && (f.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new be(1,1),
        s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        return s.occlusionTexture !== void 0 && o !== Ki && (f.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== Ki && (a.emissive = new Oe().fromArray(s.emissiveFactor)),
        s.emissiveTexture !== void 0 && o !== Ki && f.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, lt)),
        Promise.all(f).then(function() {
            const h = new o(a);
            return s.name && (h.name = s.name),
            Po(h, s),
            t.associations.set(h, {
                materials: e
            }),
            s.extensions && cf(r, h, s),
            h
        })
    }
    createUniqueName(e) {
        const t = Ct.sanitizeNodeName(e || "");
        let i = t;
        for (let r = 1; this.nodeNamesUsed[i]; ++r)
            i = t + "_" + r;
        return this.nodeNamesUsed[i] = !0,
        i
    }
    loadGeometries(e) {
        const t = this
          , i = this.extensions
          , r = this.primitiveCache;
        function s(a) {
            return i[Nt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return kR(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const f = e[a]
              , d = J$(f)
              , h = r[d];
            if (h)
                o.push(h.promise);
            else {
                let p;
                f.extensions && f.extensions[Nt.KHR_DRACO_MESH_COMPRESSION] ? p = s(f) : p = kR(new ft, f, t),
                r[d] = {
                    primitive: f,
                    promise: p
                },
                o.push(p)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , i = this.json
          , r = this.extensions
          , s = i.meshes[e]
          , o = s.primitives
          , a = [];
        for (let l = 0, f = o.length; l < f; l++) {
            const d = o[l].material === void 0 ? K$(this.cache) : this.getDependency("material", o[l].material);
            a.push(d)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const f = l.slice(0, l.length - 1)
              , d = l[l.length - 1]
              , h = [];
            for (let m = 0, y = d.length; m < y; m++) {
                const S = d[m]
                  , M = o[m];
                let g;
                const _ = f[m];
                if (M.mode === hr.TRIANGLES || M.mode === hr.TRIANGLE_STRIP || M.mode === hr.TRIANGLE_FAN || M.mode === void 0)
                    g = s.isSkinnedMesh === !0 ? new y0(S,_) : new zn(S,_),
                    g.isSkinnedMesh === !0 && g.normalizeSkinWeights(),
                    M.mode === hr.TRIANGLE_STRIP ? g.geometry = LR(g.geometry, U1) : M.mode === hr.TRIANGLE_FAN && (g.geometry = LR(g.geometry, Jm));
                else if (M.mode === hr.LINES)
                    g = new is(S,_);
                else if (M.mode === hr.LINE_STRIP)
                    g = new Es(S,_);
                else if (M.mode === hr.LINE_LOOP)
                    g = new Y1(S,_);
                else if (M.mode === hr.POINTS)
                    g = new q1(S,_);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + M.mode);
                Object.keys(g.geometry.morphAttributes).length > 0 && Q$(g, s),
                g.name = t.createUniqueName(s.name || "mesh_" + e),
                Po(g, s),
                M.extensions && cf(r, g, M),
                t.assignFinalMaterial(g),
                h.push(g)
            }
            for (let m = 0, y = h.length; m < y; m++)
                t.associations.set(h[m], {
                    meshes: e,
                    primitives: m
                });
            if (h.length === 1)
                return h[0];
            const p = new xr;
            t.associations.set(p, {
                meshes: e
            });
            for (let m = 0, y = h.length; m < y; m++)
                p.add(h[m]);
            return p
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e]
          , r = i[i.type];
        if (!r) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new Pn(vr.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : i.type === "orthographic" && (t = new dl(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        Po(t, i),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , i = [];
        for (let r = 0, s = t.joints.length; r < s; r++)
            i.push(this._loadNodeShallow(t.joints[r]));
        return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null),
        Promise.all(i).then(function(r) {
            const s = r.pop()
              , o = r
              , a = []
              , l = [];
            for (let f = 0, d = o.length; f < d; f++) {
                const h = o[f];
                if (h) {
                    a.push(h);
                    const p = new $e;
                    s !== null && p.fromArray(s.array, f * 16),
                    l.push(p)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[f])
            }
            return new fu(a,l)
        })
    }
    loadAnimation(e) {
        const i = this.json.animations[e]
          , r = i.name ? i.name : "animation_" + e
          , s = []
          , o = []
          , a = []
          , l = []
          , f = [];
        for (let d = 0, h = i.channels.length; d < h; d++) {
            const p = i.channels[d]
              , m = i.samplers[p.sampler]
              , y = p.target
              , S = y.node
              , M = i.parameters !== void 0 ? i.parameters[m.input] : m.input
              , g = i.parameters !== void 0 ? i.parameters[m.output] : m.output;
            y.node !== void 0 && (s.push(this.getDependency("node", S)),
            o.push(this.getDependency("accessor", M)),
            a.push(this.getDependency("accessor", g)),
            l.push(m),
            f.push(y))
        }
        return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(f)]).then(function(d) {
            const h = d[0]
              , p = d[1]
              , m = d[2]
              , y = d[3]
              , S = d[4]
              , M = [];
            for (let g = 0, _ = h.length; g < _; g++) {
                const w = h[g]
                  , T = p[g]
                  , A = m[g]
                  , C = y[g]
                  , P = S[g];
                if (w === void 0)
                    continue;
                w.updateMatrix();
                let N;
                switch (Eo[P.path]) {
                case Eo.weights:
                    N = nl;
                    break;
                case Eo.rotation:
                    N = no;
                    break;
                case Eo.position:
                case Eo.scale:
                default:
                    N = il;
                    break
                }
                const b = w.name ? w.name : w.uuid
                  , L = C.interpolation !== void 0 ? q$[C.interpolation] : el
                  , Y = [];
                Eo[P.path] === Eo.weights ? w.traverse(function($) {
                    $.morphTargetInfluences && Y.push($.name ? $.name : $.uuid)
                }) : Y.push(b);
                let Z = A.array;
                if (A.normalized) {
                    const $ = sS(Z.constructor)
                      , Q = new Float32Array(Z.length);
                    for (let ie = 0, fe = Z.length; ie < fe; ie++)
                        Q[ie] = Z[ie] * $;
                    Z = Q
                }
                for (let $ = 0, Q = Y.length; $ < Q; $++) {
                    const ie = new N(Y[$] + "." + Eo[P.path],T.array,Z,L);
                    C.interpolation === "CUBICSPLINE" && (ie.createInterpolant = function(le) {
                        const D = this instanceof no ? Y$ : o3;
                        return new D(this.times,this.values,this.getValueSize() / 3,le)
                    }
                    ,
                    ie.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    M.push(ie)
                }
            }
            return new rl(r,void 0,M)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , i = this
          , r = t.nodes[e];
        return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
            const o = i._getNodeRef(i.meshCache, r.mesh, s);
            return r.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, f = r.weights.length; l < f; l++)
                        a.morphTargetInfluences[l] = r.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , i = this
          , r = t.nodes[e]
          , s = i._loadNodeShallow(e)
          , o = []
          , a = r.children || [];
        for (let f = 0, d = a.length; f < d; f++)
            o.push(i.getDependency("node", a[f]));
        const l = r.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", r.skin);
        return Promise.all([s, Promise.all(o), l]).then(function(f) {
            const d = f[0]
              , h = f[1]
              , p = f[2];
            p !== null && d.traverse(function(m) {
                m.isSkinnedMesh && m.bind(p, tj)
            });
            for (let m = 0, y = h.length; m < y; m++)
                d.add(h[m]);
            return d
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , i = this.extensions
          , r = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const s = t.nodes[e]
          , o = s.name ? r.createUniqueName(s.name) : ""
          , a = []
          , l = r._invokeOne(function(f) {
            return f.createNodeMesh && f.createNodeMesh(e)
        });
        return l && a.push(l),
        s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function(f) {
            return r._getNodeRef(r.cameraCache, s.camera, f)
        })),
        r._invokeAll(function(f) {
            return f.createNodeAttachment && f.createNodeAttachment(e)
        }).forEach(function(f) {
            a.push(f)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(f) {
            let d;
            if (s.isBone === !0 ? d = new eu : f.length > 1 ? d = new xr : f.length === 1 ? d = f[0] : d = new Lt,
            d !== f[0])
                for (let h = 0, p = f.length; h < p; h++)
                    d.add(f[h]);
            if (s.name && (d.userData.name = s.name,
            d.name = o),
            Po(d, s),
            s.extensions && cf(i, d, s),
            s.matrix !== void 0) {
                const h = new $e;
                h.fromArray(s.matrix),
                d.applyMatrix4(h)
            } else
                s.translation !== void 0 && d.position.fromArray(s.translation),
                s.rotation !== void 0 && d.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && d.scale.fromArray(s.scale);
            return r.associations.has(d) || r.associations.set(d, {}),
            r.associations.get(d).nodes = e,
            d
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , i = this.json.scenes[e]
          , r = this
          , s = new xr;
        i.name && (s.name = r.createUniqueName(i.name)),
        Po(s, i),
        i.extensions && cf(t, s, i);
        const o = i.nodes || []
          , a = [];
        for (let l = 0, f = o.length; l < f; l++)
            a.push(r.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let d = 0, h = l.length; d < h; d++)
                s.add(l[d]);
            const f = d=>{
                const h = new Map;
                for (const [p,m] of r.associations)
                    (p instanceof Nn || p instanceof en) && h.set(p, m);
                return d.traverse(p=>{
                    const m = r.associations.get(p);
                    m != null && h.set(p, m)
                }
                ),
                h
            }
            ;
            return r.associations = f(s),
            s
        })
    }
}
function ij(n, e, t) {
    const i = e.attributes
      , r = new ts;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION]
          , l = a.min
          , f = a.max;
        if (l !== void 0 && f !== void 0) {
            if (r.set(new z(l[0],l[1],l[2]), new z(f[0],f[1],f[2])),
            a.normalized) {
                const d = sS(Nc[a.componentType]);
                r.min.multiplyScalar(d),
                r.max.multiplyScalar(d)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new z
          , l = new z;
        for (let f = 0, d = s.length; f < d; f++) {
            const h = s[f];
            if (h.POSITION !== void 0) {
                const p = t.json.accessors[h.POSITION]
                  , m = p.min
                  , y = p.max;
                if (m !== void 0 && y !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(y[0]))),
                    l.setY(Math.max(Math.abs(m[1]), Math.abs(y[1]))),
                    l.setZ(Math.max(Math.abs(m[2]), Math.abs(y[2]))),
                    p.normalized) {
                        const S = sS(Nc[p.componentType]);
                        l.multiplyScalar(S)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        r.expandByVector(a)
    }
    n.boundingBox = r;
    const o = new ns;
    r.getCenter(o.center),
    o.radius = r.min.distanceTo(r.max) / 2,
    n.boundingSphere = o
}
function kR(n, e, t) {
    const i = e.attributes
      , r = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = rS[o] || o.toLowerCase();
        a in n.attributes || r.push(s(i[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        r.push(o)
    }
    return Po(n, e),
    ij(n, e, t),
    Promise.all(r).then(function() {
        return e.targets !== void 0 ? Z$(n, e.targets, t) : n
    })
}
const rj = ()=>{
    const {scene: n} = Rr(yw, "/house.glb");
    return ke.useEffect(()=>{
        const e = n.children[0];
        e.castShadow = !0,
        e.receiveShadow = !0,
        n.castShadow = !0,
        n.receiveShadow = !0;
        const t = M$(e);
        n.position.set(5, 0 + t, 2),
        n.visible = !1,
        n.scale.set(2, 2, 2)
    }
    , [n]),
    ct("primitive", {
        name: "house",
        object: n
    })
}
  , sj = ()=>{
    const n = ke.useRef(null);
    return ke.useEffect(()=>{
        const e = n.current;
        e && (e.shadow.mapSize.width = 2048,
        e.shadow.mapSize.height = 2048,
        e.shadow.camera.left = -100,
        e.shadow.camera.right = 100,
        e.shadow.camera.top = 100,
        e.shadow.camera.bottom = -100,
        e.shadow.camera.near = -100,
        e.shadow.camera.far = 100)
    }
    , []),
    es(hS, {
        children: [ct("ambientLight", {
            intensity: .3
        }), ct("directionalLight", {
            ref: n,
            castShadow: !0,
            intensity: .5,
            position: [2, 10, -5]
        })]
    })
}
  , oj = ({side: n, width: e, depth: t, height: i})=>{
    const r = Rr(gl, "/images/brick.jpg");
    return r.wrapS = Yn,
    r.wrapT = Yn,
    r.repeat.x = 4,
    r.repeat.y = 1,
    es("mesh", {
        position: (()=>{
            switch (n) {
            case "top":
                return [0, i / 2, -e / 2];
            case "right":
                return [e / 2, i / 2, 0];
            case "bottom":
                return [0, i / 2, e / 2];
            case "left":
                return [-e / 2, i / 2, 0]
            }
        }
        )(),
        children: [ct("boxGeometry", {
            args: (()=>{
                switch (n) {
                case "top":
                    return [e, i, t];
                case "right":
                    return [t, i, e];
                case "bottom":
                    return [e, i, t];
                case "left":
                    return [t, i, e]
                }
            }
            )()
        }), ct("meshStandardMaterial", {
            map: r
        })]
    })
}
  , aj = ()=>{
    const {scene: n} = Rr(yw, "/book.glb")
      , [e,t] = ke.useState(!1);
    return ke.useEffect(()=>{
        n.traverse(i=>{
            i.isMesh && (i.receiveShadow = !0,
            i.castShadow = !0)
        }
        ),
        n.castShadow = !0,
        n.receiveShadow = !0,
        n.position.set(-11, 0, -12),
        n.scale.set(3, 3, 3),
        n.rotation.set(0, -Math.PI / 4, 0),
        t(!0)
    }
    , [n]),
    e ? ct("primitive", {
        name: "book",
        object: n
    }) : null
}
  , lj = ()=>{
    const n = Rr(gl, "/images/rug.jpg");
    return n.wrapS = Yn,
    n.wrapT = Yn,
    n.repeat.x = 4,
    n.repeat.y = 4,
    es("mesh", {
        position: [-10, 0, -10],
        castShadow: !0,
        receiveShadow: !0,
        name: "floor",
        rotation: [0, 0, 0],
        children: [ct("cylinderGeometry", {
            args: [5, 5, .1, 32]
        }), ct("meshStandardMaterial", {
            map: n
        })]
    })
}
  , cj = ({url: n, name: e, position: t, width: i, depth: r, height: s, rotation: o})=>{
    const a = Rr(gl, n);
    return a.wrapS = Yn,
    a.wrapT = Yn,
    a.repeat.x = 1,
    a.repeat.y = 1,
    es("mesh", {
        castShadow: !0,
        receiveShadow: !0,
        name: e,
        position: t,
        rotation: o,
        children: [ct("boxGeometry", {
            args: [i, s, r]
        }), ct("meshStandardMaterial", {
            clipShadows: !0,
            shadowSide: Zr,
            map: a,
            metalness: .2,
            roughness: .9
        })]
    })
}
  , uj = [{
    name: "typescript",
    position: [-22, 2, -22],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, 0, 0]
}, {
    name: "javascript",
    position: [-16, 2, -22],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, 0, 0]
}, {
    name: "html",
    position: [-10, 2, -22],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, 0, 0]
}, {
    name: "css",
    position: [-4, 2, -22],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, 0, 0]
}, {
    name: "node",
    position: [0, 2, -18],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, -Math.PI / 3, 0]
}, {
    name: "react",
    position: [-17, 2, -15],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, -Math.PI / 4, 0]
}, {
    name: "next",
    position: [-3, 2, -9],
    width: 4,
    depth: 4,
    height: 4,
    rotation: [0, -Math.PI / 7, 0]
}, {
    name: "three",
    position: [-11, 1.5, -5],
    width: 3,
    depth: 3,
    height: 3,
    rotation: [0, -Math.PI / 7, 0]
}, {
    name: "aws",
    position: [-22, 1, 0],
    width: 2,
    depth: 2,
    height: 2,
    rotation: [0, 0, 0]
}, {
    name: "flutter",
    position: [-22, 1, -5],
    width: 2,
    depth: 2,
    height: 2,
    rotation: [0, Math.PI / 8, 0]
}, {
    name: "graphql",
    position: [-20, 1, -10],
    width: 2,
    depth: 2,
    height: 2,
    rotation: [0, Math.PI / 17, 0]
}, {
    name: "pixi",
    position: [-15, 1, -10],
    width: 2,
    depth: 2,
    height: 2,
    rotation: [0, Math.PI / 17, 0]
}, {
    name: "python",
    position: [-10, 1, -17],
    width: 2,
    depth: 2,
    height: 2,
    rotation: [0, Math.PI / 17, 0]
}]
  , fj = new Array(5).fill(null).map((n,e)=>new z(23 + 10 * Math.cos(Math.PI / 2 / 4 * (e + 4)),0,-23 + 10 * Math.sin(Math.PI / 2 / 4 * (e + 4))))
  , dj = ()=>{
    const {scene: n} = Rr(yw, "/laptop.glb")
      , [e,t] = ke.useState();
    return ke.useEffect(()=>{
        n.traverse(o=>{
            o.isMesh && (o.receiveShadow = !0,
            o.castShadow = !0)
        }
        );
        const i = new xr
          , [r,s] = n.children;
        i.add(r.clone(), s.clone()),
        i.position.set(-8, -.5, -15),
        i.scale.set(1, 1, 1),
        i.rotation.set(0, Math.PI * 3 / 4, 0),
        t(i)
    }
    , [e]),
    e ? ct("primitive", {
        name: "book",
        object: e
    }) : null
}
;
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var OR = function(n) {
    return URL.createObjectURL(new Blob([n],{
        type: "text/javascript"
    }))
};
try {
    URL.revokeObjectURL(OR(""))
} catch {
    OR = function(e) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(e)
    }
}
var yr = Uint8Array
  , ko = Uint16Array
  , oS = Uint32Array
  , a3 = new yr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , l3 = new yr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , hj = new yr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , c3 = function(n, e) {
    for (var t = new ko(31), i = 0; i < 31; ++i)
        t[i] = e += 1 << n[i - 1];
    for (var r = new oS(t[30]), i = 1; i < 30; ++i)
        for (var s = t[i]; s < t[i + 1]; ++s)
            r[s] = s - t[i] << 5 | i;
    return [t, r]
}
  , u3 = c3(a3, 2)
  , f3 = u3[0]
  , pj = u3[1];
f3[28] = 258,
pj[258] = 28;
var mj = c3(l3, 0)
  , gj = mj[0]
  , aS = new ko(32768);
for (var sn = 0; sn < 32768; ++sn) {
    var To = (sn & 43690) >>> 1 | (sn & 21845) << 1;
    To = (To & 52428) >>> 2 | (To & 13107) << 2,
    To = (To & 61680) >>> 4 | (To & 3855) << 4,
    aS[sn] = ((To & 65280) >>> 8 | (To & 255) << 8) >>> 1
}
var Uf = function(n, e, t) {
    for (var i = n.length, r = 0, s = new ko(e); r < i; ++r)
        ++s[n[r] - 1];
    var o = new ko(e);
    for (r = 0; r < e; ++r)
        o[r] = o[r - 1] + s[r - 1] << 1;
    var a;
    if (t) {
        a = new ko(1 << e);
        var l = 15 - e;
        for (r = 0; r < i; ++r)
            if (n[r])
                for (var f = r << 4 | n[r], d = e - n[r], h = o[n[r] - 1]++ << d, p = h | (1 << d) - 1; h <= p; ++h)
                    a[aS[h] >>> l] = f
    } else
        for (a = new ko(i),
        r = 0; r < i; ++r)
            n[r] && (a[r] = aS[o[n[r] - 1]++] >>> 15 - n[r]);
    return a
}
  , Wd = new yr(288);
for (var sn = 0; sn < 144; ++sn)
    Wd[sn] = 8;
for (var sn = 144; sn < 256; ++sn)
    Wd[sn] = 9;
for (var sn = 256; sn < 280; ++sn)
    Wd[sn] = 7;
for (var sn = 280; sn < 288; ++sn)
    Wd[sn] = 8;
var d3 = new yr(32);
for (var sn = 0; sn < 32; ++sn)
    d3[sn] = 5;
var vj = Uf(Wd, 9, 1)
  , yj = Uf(d3, 5, 1)
  , s_ = function(n) {
    for (var e = n[0], t = 1; t < n.length; ++t)
        n[t] > e && (e = n[t]);
    return e
}
  , zr = function(n, e, t) {
    var i = e / 8 | 0;
    return (n[i] | n[i + 1] << 8) >> (e & 7) & t
}
  , o_ = function(n, e) {
    var t = e / 8 | 0;
    return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >> (e & 7)
}
  , _j = function(n) {
    return (n / 8 | 0) + (n & 7 && 1)
}
  , xj = function(n, e, t) {
    (e == null || e < 0) && (e = 0),
    (t == null || t > n.length) && (t = n.length);
    var i = new (n instanceof ko ? ko : n instanceof oS ? oS : yr)(t - e);
    return i.set(n.subarray(e, t)),
    i
}
  , Sj = function(n, e, t) {
    var i = n.length;
    if (!i || t && !t.l && i < 5)
        return e || new yr(0);
    var r = !e || t
      , s = !t || t.i;
    t || (t = {}),
    e || (e = new yr(i * 3));
    var o = function(F) {
        var B = e.length;
        if (F > B) {
            var ae = new yr(Math.max(B * 2, F));
            ae.set(e),
            e = ae
        }
    }
      , a = t.f || 0
      , l = t.p || 0
      , f = t.b || 0
      , d = t.l
      , h = t.d
      , p = t.m
      , m = t.n
      , y = i * 8;
    do {
        if (!d) {
            t.f = a = zr(n, l, 1);
            var S = zr(n, l + 1, 3);
            if (l += 3,
            S)
                if (S == 1)
                    d = vj,
                    h = yj,
                    p = 9,
                    m = 5;
                else if (S == 2) {
                    var w = zr(n, l, 31) + 257
                      , T = zr(n, l + 10, 15) + 4
                      , A = w + zr(n, l + 5, 31) + 1;
                    l += 14;
                    for (var C = new yr(A), P = new yr(19), N = 0; N < T; ++N)
                        P[hj[N]] = zr(n, l + N * 3, 7);
                    l += T * 3;
                    for (var b = s_(P), L = (1 << b) - 1, Y = Uf(P, b, 1), N = 0; N < A; ) {
                        var Z = Y[zr(n, l, L)];
                        l += Z & 15;
                        var M = Z >>> 4;
                        if (M < 16)
                            C[N++] = M;
                        else {
                            var $ = 0
                              , Q = 0;
                            for (M == 16 ? (Q = 3 + zr(n, l, 3),
                            l += 2,
                            $ = C[N - 1]) : M == 17 ? (Q = 3 + zr(n, l, 7),
                            l += 3) : M == 18 && (Q = 11 + zr(n, l, 127),
                            l += 7); Q--; )
                                C[N++] = $
                        }
                    }
                    var ie = C.subarray(0, w)
                      , fe = C.subarray(w);
                    p = s_(ie),
                    m = s_(fe),
                    d = Uf(ie, p, 1),
                    h = Uf(fe, m, 1)
                } else
                    throw "invalid block type";
            else {
                var M = _j(l) + 4
                  , g = n[M - 4] | n[M - 3] << 8
                  , _ = M + g;
                if (_ > i) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
                r && o(f + g),
                e.set(n.subarray(M, _), f),
                t.b = f += g,
                t.p = l = _ * 8;
                continue
            }
            if (l > y) {
                if (s)
                    throw "unexpected EOF";
                break
            }
        }
        r && o(f + 131072);
        for (var le = (1 << p) - 1, D = (1 << m) - 1, j = l; ; j = l) {
            var $ = d[o_(n, l) & le]
              , X = $ >>> 4;
            if (l += $ & 15,
            l > y) {
                if (s)
                    throw "unexpected EOF";
                break
            }
            if (!$)
                throw "invalid length/literal";
            if (X < 256)
                e[f++] = X;
            else if (X == 256) {
                j = l,
                d = null;
                break
            } else {
                var ue = X - 254;
                if (X > 264) {
                    var N = X - 257
                      , I = a3[N];
                    ue = zr(n, l, (1 << I) - 1) + f3[N],
                    l += I
                }
                var U = h[o_(n, l) & D]
                  , O = U >>> 4;
                if (!U)
                    throw "invalid distance";
                l += U & 15;
                var fe = gj[O];
                if (O > 3) {
                    var I = l3[O];
                    fe += o_(n, l) & (1 << I) - 1,
                    l += I
                }
                if (l > y) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
                r && o(f + 131072);
                for (var J = f + ue; f < J; f += 4)
                    e[f] = e[f - fe],
                    e[f + 1] = e[f + 1 - fe],
                    e[f + 2] = e[f + 2 - fe],
                    e[f + 3] = e[f + 3 - fe];
                f = J
            }
        }
        t.l = d,
        t.p = j,
        t.b = f,
        d && (a = 1,
        t.m = p,
        t.d = h,
        t.n = m)
    } while (!a);
    return f == e.length ? e : xj(e, 0, f)
}
  , wj = new yr(0)
  , Mj = function(n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || (n[0] << 8 | n[1]) % 31)
        throw "invalid zlib data";
    if (n[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported"
};
function Ej(n, e) {
    return Sj((Mj(n),
    n.subarray(2, -4)), e)
}
var Tj = typeof TextDecoder < "u" && new TextDecoder
  , Aj = 0;
try {
    Tj.decode(wj, {
        stream: !0
    }),
    Aj = 1
} catch {}
function h3(n, e, t) {
    const i = t.length - n - 1;
    if (e >= t[i])
        return i - 1;
    if (e <= t[n])
        return n;
    let r = n
      , s = i
      , o = Math.floor((r + s) / 2);
    for (; e < t[o] || e >= t[o + 1]; )
        e < t[o] ? s = o : r = o,
        o = Math.floor((r + s) / 2);
    return o
}
function Rj(n, e, t, i) {
    const r = []
      , s = []
      , o = [];
    r[0] = 1;
    for (let a = 1; a <= t; ++a) {
        s[a] = e - i[n + 1 - a],
        o[a] = i[n + a] - e;
        let l = 0;
        for (let f = 0; f < a; ++f) {
            const d = o[f + 1]
              , h = s[a - f]
              , p = r[f] / (d + h);
            r[f] = l + d * p,
            l = h * p
        }
        r[a] = l
    }
    return r
}
function Cj(n, e, t, i) {
    const r = h3(n, i, e)
      , s = Rj(r, i, n, e)
      , o = new Ut(0,0,0,0);
    for (let a = 0; a <= n; ++a) {
        const l = t[r - n + a]
          , f = s[a]
          , d = l.w * f;
        o.x += l.x * d,
        o.y += l.y * d,
        o.z += l.z * d,
        o.w += l.w * f
    }
    return o
}
function bj(n, e, t, i, r) {
    const s = [];
    for (let h = 0; h <= t; ++h)
        s[h] = 0;
    const o = [];
    for (let h = 0; h <= i; ++h)
        o[h] = s.slice(0);
    const a = [];
    for (let h = 0; h <= t; ++h)
        a[h] = s.slice(0);
    a[0][0] = 1;
    const l = s.slice(0)
      , f = s.slice(0);
    for (let h = 1; h <= t; ++h) {
        l[h] = e - r[n + 1 - h],
        f[h] = r[n + h] - e;
        let p = 0;
        for (let m = 0; m < h; ++m) {
            const y = f[m + 1]
              , S = l[h - m];
            a[h][m] = y + S;
            const M = a[m][h - 1] / a[h][m];
            a[m][h] = p + y * M,
            p = S * M
        }
        a[h][h] = p
    }
    for (let h = 0; h <= t; ++h)
        o[0][h] = a[h][t];
    for (let h = 0; h <= t; ++h) {
        let p = 0
          , m = 1;
        const y = [];
        for (let S = 0; S <= t; ++S)
            y[S] = s.slice(0);
        y[0][0] = 1;
        for (let S = 1; S <= i; ++S) {
            let M = 0;
            const g = h - S
              , _ = t - S;
            h >= S && (y[m][0] = y[p][0] / a[_ + 1][g],
            M = y[m][0] * a[g][_]);
            const w = g >= -1 ? 1 : -g
              , T = h - 1 <= _ ? S - 1 : t - h;
            for (let C = w; C <= T; ++C)
                y[m][C] = (y[p][C] - y[p][C - 1]) / a[_ + 1][g + C],
                M += y[m][C] * a[g + C][_];
            h <= _ && (y[m][S] = -y[p][S - 1] / a[_ + 1][h],
            M += y[m][S] * a[h][_]),
            o[S][h] = M;
            const A = p;
            p = m,
            m = A
        }
    }
    let d = t;
    for (let h = 1; h <= i; ++h) {
        for (let p = 0; p <= t; ++p)
            o[h][p] *= d;
        d *= t - h
    }
    return o
}
function Pj(n, e, t, i, r) {
    const s = r < n ? r : n
      , o = []
      , a = h3(n, i, e)
      , l = bj(a, i, n, s, e)
      , f = [];
    for (let d = 0; d < t.length; ++d) {
        const h = t[d].clone()
          , p = h.w;
        h.x *= p,
        h.y *= p,
        h.z *= p,
        f[d] = h
    }
    for (let d = 0; d <= s; ++d) {
        const h = f[a - n].clone().multiplyScalar(l[d][0]);
        for (let p = 1; p <= n; ++p)
            h.add(f[a - n + p].clone().multiplyScalar(l[d][p]));
        o[d] = h
    }
    for (let d = s + 1; d <= r + 1; ++d)
        o[d] = new Ut(0,0,0);
    return o
}
function Lj(n, e) {
    let t = 1;
    for (let r = 2; r <= n; ++r)
        t *= r;
    let i = 1;
    for (let r = 2; r <= e; ++r)
        i *= r;
    for (let r = 2; r <= n - e; ++r)
        i *= r;
    return t / i
}
function Ij(n) {
    const e = n.length
      , t = []
      , i = [];
    for (let s = 0; s < e; ++s) {
        const o = n[s];
        t[s] = new z(o.x,o.y,o.z),
        i[s] = o.w
    }
    const r = [];
    for (let s = 0; s < e; ++s) {
        const o = t[s].clone();
        for (let a = 1; a <= s; ++a)
            o.sub(r[s - a].clone().multiplyScalar(Lj(s, a) * i[a]));
        r[s] = o.divideScalar(i[0])
    }
    return r
}
function Nj(n, e, t, i, r) {
    const s = Pj(n, e, t, i, r);
    return Ij(s)
}
class Dj extends Ar {
    constructor(e, t, i, r, s) {
        super(),
        this.degree = e,
        this.knots = t,
        this.controlPoints = [],
        this.startKnot = r || 0,
        this.endKnot = s || this.knots.length - 1;
        for (let o = 0; o < i.length; ++o) {
            const a = i[o];
            this.controlPoints[o] = new Ut(a.x,a.y,a.z,a.w)
        }
    }
    getPoint(e, t=new z) {
        const i = t
          , r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot])
          , s = Cj(this.degree, this.knots, this.controlPoints, r);
        return s.w !== 1 && s.divideScalar(s.w),
        i.set(s.x, s.y, s.z)
    }
    getTangent(e, t=new z) {
        const i = t
          , r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0])
          , s = Nj(this.degree, this.knots, this.controlPoints, r, 1);
        return i.copy(s[1]).normalize(),
        i
    }
}
let Pt, Mn, bi;
class _w extends Mi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = s.path === "" ? ol.extractUrlBase(e) : s.path
          , a = new Er(this.manager);
        a.setPath(s.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(s.requestHeader),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            try {
                t(s.parse(l, o))
            } catch (f) {
                r ? r(f) : console.error(f),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e, t) {
        if (Bj(e))
            Pt = new zj().parse(e);
        else {
            const r = v3(e);
            if (!Vj(r))
                throw new Error("THREE.FBXLoader: Unknown format.");
            if (zR(r) < 7e3)
                throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + zR(r));
            Pt = new Fj().parse(r)
        }
        const i = new gl(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
        return new Uj(i,this.manager).parse(Pt)
    }
}
class Uj {
    constructor(e, t) {
        this.textureLoader = e,
        this.manager = t
    }
    parse() {
        Mn = this.parseConnections();
        const e = this.parseImages()
          , t = this.parseTextures(e)
          , i = this.parseMaterials(t)
          , r = this.parseDeformers()
          , s = new kj().parse(r);
        return this.parseScene(r, s, i),
        bi
    }
    parseConnections() {
        const e = new Map;
        return "Connections"in Pt && Pt.Connections.connections.forEach(function(i) {
            const r = i[0]
              , s = i[1]
              , o = i[2];
            e.has(r) || e.set(r, {
                parents: [],
                children: []
            });
            const a = {
                ID: s,
                relationship: o
            };
            e.get(r).parents.push(a),
            e.has(s) || e.set(s, {
                parents: [],
                children: []
            });
            const l = {
                ID: r,
                relationship: o
            };
            e.get(s).children.push(l)
        }),
        e
    }
    parseImages() {
        const e = {}
          , t = {};
        if ("Video"in Pt.Objects) {
            const i = Pt.Objects.Video;
            for (const r in i) {
                const s = i[r]
                  , o = parseInt(r);
                if (e[o] = s.RelativeFilename || s.Filename,
                "Content"in s) {
                    const a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0
                      , l = typeof s.Content == "string" && s.Content !== "";
                    if (a || l) {
                        const f = this.parseImage(i[r]);
                        t[s.RelativeFilename || s.Filename] = f
                    }
                }
            }
        }
        for (const i in e) {
            const r = e[i];
            t[r] !== void 0 ? e[i] = t[r] : e[i] = e[i].split("\\").pop()
        }
        return e
    }
    parseImage(e) {
        const t = e.Content
          , i = e.RelativeFilename || e.Filename
          , r = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
        let s;
        switch (r) {
        case "bmp":
            s = "image/bmp";
            break;
        case "jpg":
        case "jpeg":
            s = "image/jpeg";
            break;
        case "png":
            s = "image/png";
            break;
        case "tif":
            s = "image/tiff";
            break;
        case "tga":
            this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", i),
            s = "image/tga";
            break;
        default:
            console.warn('FBXLoader: Image type "' + r + '" is not supported.');
            return
        }
        if (typeof t == "string")
            return "data:" + s + ";base64," + t;
        {
            const o = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([o],{
                type: s
            }))
        }
    }
    parseTextures(e) {
        const t = new Map;
        if ("Texture"in Pt.Objects) {
            const i = Pt.Objects.Texture;
            for (const r in i) {
                const s = this.parseTexture(i[r], e);
                t.set(parseInt(r), s)
            }
        }
        return t
    }
    parseTexture(e, t) {
        const i = this.loadTexture(e, t);
        i.ID = e.id,
        i.name = e.attrName;
        const r = e.WrapModeU
          , s = e.WrapModeV
          , o = r !== void 0 ? r.value : 0
          , a = s !== void 0 ? s.value : 0;
        if (i.wrapS = o === 0 ? Yn : On,
        i.wrapT = a === 0 ? Yn : On,
        "Scaling"in e) {
            const l = e.Scaling.value;
            i.repeat.x = l[0],
            i.repeat.y = l[1]
        }
        if ("Translation"in e) {
            const l = e.Translation.value;
            i.offset.x = l[0],
            i.offset.y = l[1]
        }
        return i
    }
    loadTexture(e, t) {
        let i;
        const r = this.textureLoader.path
          , s = Mn.get(e.id).children;
        s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (i = t[s[0].ID],
        (i.indexOf("blob:") === 0 || i.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
        let o;
        const a = e.FileName.slice(-3).toLowerCase();
        if (a === "tga") {
            const l = this.manager.getHandler(".tga");
            l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename),
            o = new en) : (l.setPath(this.textureLoader.path),
            o = l.load(i))
        } else
            a === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename),
            o = new en) : o = this.textureLoader.load(i);
        return this.textureLoader.setPath(r),
        o
    }
    parseMaterials(e) {
        const t = new Map;
        if ("Material"in Pt.Objects) {
            const i = Pt.Objects.Material;
            for (const r in i) {
                const s = this.parseMaterial(i[r], e);
                s !== null && t.set(parseInt(r), s)
            }
        }
        return t
    }
    parseMaterial(e, t) {
        const i = e.id
          , r = e.attrName;
        let s = e.ShadingModel;
        if (typeof s == "object" && (s = s.value),
        !Mn.has(i))
            return null;
        const o = this.parseParameters(e, t, i);
        let a;
        switch (s.toLowerCase()) {
        case "phong":
            a = new Df;
            break;
        case "lambert":
            a = new iw;
            break;
        default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s),
            a = new Df;
            break
        }
        return a.setValues(o),
        a.name = r,
        a
    }
    parseParameters(e, t, i) {
        const r = {};
        e.BumpFactor && (r.bumpScale = e.BumpFactor.value),
        e.Diffuse ? r.color = new Oe().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (r.color = new Oe().fromArray(e.DiffuseColor.value).convertSRGBToLinear()),
        e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value),
        e.Emissive ? r.emissive = new Oe().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (r.emissive = new Oe().fromArray(e.EmissiveColor.value).convertSRGBToLinear()),
        e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
        e.Opacity && (r.opacity = parseFloat(e.Opacity.value)),
        r.opacity < 1 && (r.transparent = !0),
        e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value),
        e.Shininess && (r.shininess = e.Shininess.value),
        e.Specular ? r.specular = new Oe().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (r.specular = new Oe().fromArray(e.SpecularColor.value).convertSRGBToLinear());
        const s = this;
        return Mn.get(i).children.forEach(function(o) {
            const a = o.relationship;
            switch (a) {
            case "Bump":
                r.bumpMap = s.getTexture(t, o.ID);
                break;
            case "Maya|TEX_ao_map":
                r.aoMap = s.getTexture(t, o.ID);
                break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
                r.map = s.getTexture(t, o.ID),
                r.map !== void 0 && (r.map.colorSpace = lt);
                break;
            case "DisplacementColor":
                r.displacementMap = s.getTexture(t, o.ID);
                break;
            case "EmissiveColor":
                r.emissiveMap = s.getTexture(t, o.ID),
                r.emissiveMap !== void 0 && (r.emissiveMap.colorSpace = lt);
                break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
                r.normalMap = s.getTexture(t, o.ID);
                break;
            case "ReflectionColor":
                r.envMap = s.getTexture(t, o.ID),
                r.envMap !== void 0 && (r.envMap.mapping = Yc,
                r.envMap.colorSpace = lt);
                break;
            case "SpecularColor":
                r.specularMap = s.getTexture(t, o.ID),
                r.specularMap !== void 0 && (r.specularMap.colorSpace = lt);
                break;
            case "TransparentColor":
            case "TransparencyFactor":
                r.alphaMap = s.getTexture(t, o.ID),
                r.transparent = !0;
                break;
            case "AmbientColor":
            case "ShininessExponent":
            case "SpecularFactor":
            case "VectorDisplacementColor":
            default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
                break
            }
        }),
        r
    }
    getTexture(e, t) {
        return "LayeredTexture"in Pt.Objects && t in Pt.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
        t = Mn.get(t).children[0].ID),
        e.get(t)
    }
    parseDeformers() {
        const e = {}
          , t = {};
        if ("Deformer"in Pt.Objects) {
            const i = Pt.Objects.Deformer;
            for (const r in i) {
                const s = i[r]
                  , o = Mn.get(parseInt(r));
                if (s.attrType === "Skin") {
                    const a = this.parseSkeleton(o, i);
                    a.ID = r,
                    o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                    a.geometryID = o.parents[0].ID,
                    e[r] = a
                } else if (s.attrType === "BlendShape") {
                    const a = {
                        id: r
                    };
                    a.rawTargets = this.parseMorphTargets(o, i),
                    a.id = r,
                    o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                    t[r] = a
                }
            }
        }
        return {
            skeletons: e,
            morphTargets: t
        }
    }
    parseSkeleton(e, t) {
        const i = [];
        return e.children.forEach(function(r) {
            const s = t[r.ID];
            if (s.attrType !== "Cluster")
                return;
            const o = {
                ID: r.ID,
                indices: [],
                weights: [],
                transformLink: new $e().fromArray(s.TransformLink.a)
            };
            "Indexes"in s && (o.indices = s.Indexes.a,
            o.weights = s.Weights.a),
            i.push(o)
        }),
        {
            rawBones: i,
            bones: []
        }
    }
    parseMorphTargets(e, t) {
        const i = [];
        for (let r = 0; r < e.children.length; r++) {
            const s = e.children[r]
              , o = t[s.ID]
              , a = {
                name: o.attrName,
                initialWeight: o.DeformPercent,
                id: o.id,
                fullWeights: o.FullWeights.a
            };
            if (o.attrType !== "BlendShapeChannel")
                return;
            a.geoID = Mn.get(parseInt(s.ID)).children.filter(function(l) {
                return l.relationship === void 0
            })[0].ID,
            i.push(a)
        }
        return i
    }
    parseScene(e, t, i) {
        bi = new xr;
        const r = this.parseModels(e.skeletons, t, i)
          , s = Pt.Objects.Model
          , o = this;
        r.forEach(function(l) {
            const f = s[l.ID];
            o.setLookAtProperties(l, f),
            Mn.get(l.ID).parents.forEach(function(h) {
                const p = r.get(h.ID);
                p !== void 0 && p.add(l)
            }),
            l.parent === null && bi.add(l)
        }),
        this.bindSkeleton(e.skeletons, t, r),
        this.createAmbientLight(),
        bi.traverse(function(l) {
            if (l.userData.transformData) {
                l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix,
                l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
                const f = m3(l.userData.transformData);
                l.applyMatrix4(f),
                l.updateWorldMatrix()
            }
        });
        const a = new Oj().parse();
        bi.children.length === 1 && bi.children[0].isGroup && (bi.children[0].animations = a,
        bi = bi.children[0]),
        bi.animations = a
    }
    parseModels(e, t, i) {
        const r = new Map
          , s = Pt.Objects.Model;
        for (const o in s) {
            const a = parseInt(o)
              , l = s[o]
              , f = Mn.get(a);
            let d = this.buildSkeleton(f, e, a, l.attrName);
            if (!d) {
                switch (l.attrType) {
                case "Camera":
                    d = this.createCamera(f);
                    break;
                case "Light":
                    d = this.createLight(f);
                    break;
                case "Mesh":
                    d = this.createMesh(f, t, i);
                    break;
                case "NurbsCurve":
                    d = this.createCurve(f, t);
                    break;
                case "LimbNode":
                case "Root":
                    d = new eu;
                    break;
                case "Null":
                default:
                    d = new xr;
                    break
                }
                d.name = l.attrName ? Ct.sanitizeNodeName(l.attrName) : "",
                d.ID = a
            }
            this.getTransformData(d, l),
            r.set(a, d)
        }
        return r
    }
    buildSkeleton(e, t, i, r) {
        let s = null;
        return e.parents.forEach(function(o) {
            for (const a in t) {
                const l = t[a];
                l.rawBones.forEach(function(f, d) {
                    if (f.ID === o.ID) {
                        const h = s;
                        s = new eu,
                        s.matrixWorld.copy(f.transformLink),
                        s.name = r ? Ct.sanitizeNodeName(r) : "",
                        s.ID = i,
                        l.bones[d] = s,
                        h !== null && s.add(h)
                    }
                })
            }
        }),
        s
    }
    createCamera(e) {
        let t, i;
        if (e.children.forEach(function(r) {
            const s = Pt.Objects.NodeAttribute[r.ID];
            s !== void 0 && (i = s)
        }),
        i === void 0)
            t = new Lt;
        else {
            let r = 0;
            i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (r = 1);
            let s = 1;
            i.NearPlane !== void 0 && (s = i.NearPlane.value / 1e3);
            let o = 1e3;
            i.FarPlane !== void 0 && (o = i.FarPlane.value / 1e3);
            let a = window.innerWidth
              , l = window.innerHeight;
            i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (a = i.AspectWidth.value,
            l = i.AspectHeight.value);
            const f = a / l;
            let d = 45;
            i.FieldOfView !== void 0 && (d = i.FieldOfView.value);
            const h = i.FocalLength ? i.FocalLength.value : null;
            switch (r) {
            case 0:
                t = new Pn(d,f,s,o),
                h !== null && t.setFocalLength(h);
                break;
            case 1:
                t = new dl(-a / 2,a / 2,l / 2,-l / 2,s,o);
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown camera type " + r + "."),
                t = new Lt;
                break
            }
        }
        return t
    }
    createLight(e) {
        let t, i;
        if (e.children.forEach(function(r) {
            const s = Pt.Objects.NodeAttribute[r.ID];
            s !== void 0 && (i = s)
        }),
        i === void 0)
            t = new Lt;
        else {
            let r;
            i.LightType === void 0 ? r = 0 : r = i.LightType.value;
            let s = 16777215;
            i.Color !== void 0 && (s = new Oe().fromArray(i.Color.value).convertSRGBToLinear());
            let o = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
            i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (o = 0);
            let a = 0;
            i.FarAttenuationEnd !== void 0 && (i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? a = 0 : a = i.FarAttenuationEnd.value);
            const l = 1;
            switch (r) {
            case 0:
                t = new ud(s,o,a,l);
                break;
            case 1:
                t = new E0(s,o);
                break;
            case 2:
                let f = Math.PI / 3;
                i.InnerAngle !== void 0 && (f = vr.degToRad(i.InnerAngle.value));
                let d = 0;
                i.OuterAngle !== void 0 && (d = vr.degToRad(i.OuterAngle.value),
                d = Math.max(d, 1)),
                t = new M0(s,o,a,f,d,l);
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."),
                t = new ud(s,o);
                break
            }
            i.CastShadows !== void 0 && i.CastShadows.value === 1 && (t.castShadow = !0)
        }
        return t
    }
    createMesh(e, t, i) {
        let r, s = null, o = null;
        const a = [];
        return e.children.forEach(function(l) {
            t.has(l.ID) && (s = t.get(l.ID)),
            i.has(l.ID) && a.push(i.get(l.ID))
        }),
        a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new Df({
            color: 13421772
        }),
        a.push(o)),
        "color"in s.attributes && a.forEach(function(l) {
            l.vertexColors = !0
        }),
        s.FBX_Deformer ? (r = new y0(s,o),
        r.normalizeSkinWeights()) : r = new zn(s,o),
        r
    }
    createCurve(e, t) {
        const i = e.children.reduce(function(s, o) {
            return t.has(o.ID) && (s = t.get(o.ID)),
            s
        }, null)
          , r = new ni({
            color: 3342591,
            linewidth: 1
        });
        return new Es(i,r)
    }
    getTransformData(e, t) {
        const i = {};
        "InheritType"in t && (i.inheritType = parseInt(t.InheritType.value)),
        "RotationOrder"in t ? i.eulerOrder = g3(t.RotationOrder.value) : i.eulerOrder = "ZYX",
        "Lcl_Translation"in t && (i.translation = t.Lcl_Translation.value),
        "PreRotation"in t && (i.preRotation = t.PreRotation.value),
        "Lcl_Rotation"in t && (i.rotation = t.Lcl_Rotation.value),
        "PostRotation"in t && (i.postRotation = t.PostRotation.value),
        "Lcl_Scaling"in t && (i.scale = t.Lcl_Scaling.value),
        "ScalingOffset"in t && (i.scalingOffset = t.ScalingOffset.value),
        "ScalingPivot"in t && (i.scalingPivot = t.ScalingPivot.value),
        "RotationOffset"in t && (i.rotationOffset = t.RotationOffset.value),
        "RotationPivot"in t && (i.rotationPivot = t.RotationPivot.value),
        e.userData.transformData = i
    }
    setLookAtProperties(e, t) {
        "LookAtProperty"in t && Mn.get(e.ID).children.forEach(function(r) {
            if (r.relationship === "LookAtProperty") {
                const s = Pt.Objects.Model[r.ID];
                if ("Lcl_Translation"in s) {
                    const o = s.Lcl_Translation.value;
                    e.target !== void 0 ? (e.target.position.fromArray(o),
                    bi.add(e.target)) : e.lookAt(new z().fromArray(o))
                }
            }
        })
    }
    bindSkeleton(e, t, i) {
        const r = this.parsePoseNodes();
        for (const s in e) {
            const o = e[s];
            Mn.get(parseInt(o.ID)).parents.forEach(function(l) {
                if (t.has(l.ID)) {
                    const f = l.ID;
                    Mn.get(f).parents.forEach(function(h) {
                        i.has(h.ID) && i.get(h.ID).bind(new fu(o.bones), r[h.ID])
                    })
                }
            })
        }
    }
    parsePoseNodes() {
        const e = {};
        if ("Pose"in Pt.Objects) {
            const t = Pt.Objects.Pose;
            for (const i in t)
                if (t[i].attrType === "BindPose" && t[i].NbPoseNodes > 0) {
                    const r = t[i].PoseNode;
                    Array.isArray(r) ? r.forEach(function(s) {
                        e[s.Node] = new $e().fromArray(s.Matrix.a)
                    }) : e[r.Node] = new $e().fromArray(r.Matrix.a)
                }
        }
        return e
    }
    createAmbientLight() {
        if ("GlobalSettings"in Pt && "AmbientColor"in Pt.GlobalSettings) {
            const e = Pt.GlobalSettings.AmbientColor.value
              , t = e[0]
              , i = e[1]
              , r = e[2];
            if (t !== 0 || i !== 0 || r !== 0) {
                const s = new Oe(t,i,r).convertSRGBToLinear();
                bi.add(new uw(s,1))
            }
        }
    }
}
class kj {
    constructor() {
        this.negativeMaterialIndices = !1
    }
    parse(e) {
        const t = new Map;
        if ("Geometry"in Pt.Objects) {
            const i = Pt.Objects.Geometry;
            for (const r in i) {
                const s = Mn.get(parseInt(r))
                  , o = this.parseGeometry(s, i[r], e);
                t.set(parseInt(r), o)
            }
        }
        return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
        t
    }
    parseGeometry(e, t, i) {
        switch (t.attrType) {
        case "Mesh":
            return this.parseMeshGeometry(e, t, i);
        case "NurbsCurve":
            return this.parseNurbsGeometry(t)
        }
    }
    parseMeshGeometry(e, t, i) {
        const r = i.skeletons
          , s = []
          , o = e.parents.map(function(h) {
            return Pt.Objects.Model[h.ID]
        });
        if (o.length === 0)
            return;
        const a = e.children.reduce(function(h, p) {
            return r[p.ID] !== void 0 && (h = r[p.ID]),
            h
        }, null);
        e.children.forEach(function(h) {
            i.morphTargets[h.ID] !== void 0 && s.push(i.morphTargets[h.ID])
        });
        const l = o[0]
          , f = {};
        "RotationOrder"in l && (f.eulerOrder = g3(l.RotationOrder.value)),
        "InheritType"in l && (f.inheritType = parseInt(l.InheritType.value)),
        "GeometricTranslation"in l && (f.translation = l.GeometricTranslation.value),
        "GeometricRotation"in l && (f.rotation = l.GeometricRotation.value),
        "GeometricScaling"in l && (f.scale = l.GeometricScaling.value);
        const d = m3(f);
        return this.genGeometry(t, a, s, d)
    }
    genGeometry(e, t, i, r) {
        const s = new ft;
        e.attrName && (s.name = e.attrName);
        const o = this.parseGeoNode(e, t)
          , a = this.genBuffers(o)
          , l = new je(a.vertex,3);
        if (l.applyMatrix4(r),
        s.setAttribute("position", l),
        a.colors.length > 0 && s.setAttribute("color", new je(a.colors,3)),
        t && (s.setAttribute("skinIndex", new h0(a.weightsIndices,4)),
        s.setAttribute("skinWeight", new je(a.vertexWeights,4)),
        s.FBX_Deformer = t),
        a.normal.length > 0) {
            const f = new Rt().getNormalMatrix(r)
              , d = new je(a.normal,3);
            d.applyNormalMatrix(f),
            s.setAttribute("normal", d)
        }
        if (a.uvs.forEach(function(f, d) {
            const h = d === 0 ? "uv" : `uv ${d}`;
            s.setAttribute(h, new je(a.uvs[d],2))
        }),
        o.material && o.material.mappingType !== "AllSame") {
            let f = a.materialIndex[0]
              , d = 0;
            if (a.materialIndex.forEach(function(h, p) {
                h !== f && (s.addGroup(d, p - d, f),
                f = h,
                d = p)
            }),
            s.groups.length > 0) {
                const h = s.groups[s.groups.length - 1]
                  , p = h.start + h.count;
                p !== a.materialIndex.length && s.addGroup(p, a.materialIndex.length - p, f)
            }
            s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
        }
        return this.addMorphTargets(s, e, i, r),
        s
    }
    parseGeoNode(e, t) {
        const i = {};
        if (i.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [],
        i.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [],
        e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])),
        e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])),
        e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])),
        e.LayerElementUV) {
            i.uv = [];
            let r = 0;
            for (; e.LayerElementUV[r]; )
                e.LayerElementUV[r].UV && i.uv.push(this.parseUVs(e.LayerElementUV[r])),
                r++
        }
        return i.weightTable = {},
        t !== null && (i.skeleton = t,
        t.rawBones.forEach(function(r, s) {
            r.indices.forEach(function(o, a) {
                i.weightTable[o] === void 0 && (i.weightTable[o] = []),
                i.weightTable[o].push({
                    id: s,
                    weight: r.weights[a]
                })
            })
        })),
        i
    }
    genBuffers(e) {
        const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
        };
        let i = 0
          , r = 0
          , s = !1
          , o = []
          , a = []
          , l = []
          , f = []
          , d = []
          , h = [];
        const p = this;
        return e.vertexIndices.forEach(function(m, y) {
            let S, M = !1;
            m < 0 && (m = m ^ -1,
            M = !0);
            let g = []
              , _ = [];
            if (o.push(m * 3, m * 3 + 1, m * 3 + 2),
            e.color) {
                const w = Jp(y, i, m, e.color);
                l.push(w[0], w[1], w[2])
            }
            if (e.skeleton) {
                if (e.weightTable[m] !== void 0 && e.weightTable[m].forEach(function(w) {
                    _.push(w.weight),
                    g.push(w.id)
                }),
                _.length > 4) {
                    s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                    s = !0);
                    const w = [0, 0, 0, 0]
                      , T = [0, 0, 0, 0];
                    _.forEach(function(A, C) {
                        let P = A
                          , N = g[C];
                        T.forEach(function(b, L, Y) {
                            if (P > b) {
                                Y[L] = P,
                                P = b;
                                const Z = w[L];
                                w[L] = N,
                                N = Z
                            }
                        })
                    }),
                    g = w,
                    _ = T
                }
                for (; _.length < 4; )
                    _.push(0),
                    g.push(0);
                for (let w = 0; w < 4; ++w)
                    d.push(_[w]),
                    h.push(g[w])
            }
            if (e.normal) {
                const w = Jp(y, i, m, e.normal);
                a.push(w[0], w[1], w[2])
            }
            e.material && e.material.mappingType !== "AllSame" && (S = Jp(y, i, m, e.material)[0],
            S < 0 && (p.negativeMaterialIndices = !0,
            S = 0)),
            e.uv && e.uv.forEach(function(w, T) {
                const A = Jp(y, i, m, w);
                f[T] === void 0 && (f[T] = []),
                f[T].push(A[0]),
                f[T].push(A[1])
            }),
            r++,
            M && (r > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),
            p.genFace(t, e, o, S, a, l, f, d, h, r),
            i++,
            r = 0,
            o = [],
            a = [],
            l = [],
            f = [],
            d = [],
            h = [])
        }),
        t
    }
    genFace(e, t, i, r, s, o, a, l, f, d) {
        for (let h = 2; h < d; h++)
            e.vertex.push(t.vertexPositions[i[0]]),
            e.vertex.push(t.vertexPositions[i[1]]),
            e.vertex.push(t.vertexPositions[i[2]]),
            e.vertex.push(t.vertexPositions[i[(h - 1) * 3]]),
            e.vertex.push(t.vertexPositions[i[(h - 1) * 3 + 1]]),
            e.vertex.push(t.vertexPositions[i[(h - 1) * 3 + 2]]),
            e.vertex.push(t.vertexPositions[i[h * 3]]),
            e.vertex.push(t.vertexPositions[i[h * 3 + 1]]),
            e.vertex.push(t.vertexPositions[i[h * 3 + 2]]),
            t.skeleton && (e.vertexWeights.push(l[0]),
            e.vertexWeights.push(l[1]),
            e.vertexWeights.push(l[2]),
            e.vertexWeights.push(l[3]),
            e.vertexWeights.push(l[(h - 1) * 4]),
            e.vertexWeights.push(l[(h - 1) * 4 + 1]),
            e.vertexWeights.push(l[(h - 1) * 4 + 2]),
            e.vertexWeights.push(l[(h - 1) * 4 + 3]),
            e.vertexWeights.push(l[h * 4]),
            e.vertexWeights.push(l[h * 4 + 1]),
            e.vertexWeights.push(l[h * 4 + 2]),
            e.vertexWeights.push(l[h * 4 + 3]),
            e.weightsIndices.push(f[0]),
            e.weightsIndices.push(f[1]),
            e.weightsIndices.push(f[2]),
            e.weightsIndices.push(f[3]),
            e.weightsIndices.push(f[(h - 1) * 4]),
            e.weightsIndices.push(f[(h - 1) * 4 + 1]),
            e.weightsIndices.push(f[(h - 1) * 4 + 2]),
            e.weightsIndices.push(f[(h - 1) * 4 + 3]),
            e.weightsIndices.push(f[h * 4]),
            e.weightsIndices.push(f[h * 4 + 1]),
            e.weightsIndices.push(f[h * 4 + 2]),
            e.weightsIndices.push(f[h * 4 + 3])),
            t.color && (e.colors.push(o[0]),
            e.colors.push(o[1]),
            e.colors.push(o[2]),
            e.colors.push(o[(h - 1) * 3]),
            e.colors.push(o[(h - 1) * 3 + 1]),
            e.colors.push(o[(h - 1) * 3 + 2]),
            e.colors.push(o[h * 3]),
            e.colors.push(o[h * 3 + 1]),
            e.colors.push(o[h * 3 + 2])),
            t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(r),
            e.materialIndex.push(r),
            e.materialIndex.push(r)),
            t.normal && (e.normal.push(s[0]),
            e.normal.push(s[1]),
            e.normal.push(s[2]),
            e.normal.push(s[(h - 1) * 3]),
            e.normal.push(s[(h - 1) * 3 + 1]),
            e.normal.push(s[(h - 1) * 3 + 2]),
            e.normal.push(s[h * 3]),
            e.normal.push(s[h * 3 + 1]),
            e.normal.push(s[h * 3 + 2])),
            t.uv && t.uv.forEach(function(p, m) {
                e.uvs[m] === void 0 && (e.uvs[m] = []),
                e.uvs[m].push(a[m][0]),
                e.uvs[m].push(a[m][1]),
                e.uvs[m].push(a[m][(h - 1) * 2]),
                e.uvs[m].push(a[m][(h - 1) * 2 + 1]),
                e.uvs[m].push(a[m][h * 2]),
                e.uvs[m].push(a[m][h * 2 + 1])
            })
    }
    addMorphTargets(e, t, i, r) {
        if (i.length === 0)
            return;
        e.morphTargetsRelative = !0,
        e.morphAttributes.position = [];
        const s = this;
        i.forEach(function(o) {
            o.rawTargets.forEach(function(a) {
                const l = Pt.Objects.Geometry[a.geoID];
                l !== void 0 && s.genMorphGeometry(e, t, l, r, a.name)
            })
        })
    }
    genMorphGeometry(e, t, i, r, s) {
        const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : []
          , a = i.Vertices !== void 0 ? i.Vertices.a : []
          , l = i.Indexes !== void 0 ? i.Indexes.a : []
          , f = e.attributes.position.count * 3
          , d = new Float32Array(f);
        for (let y = 0; y < l.length; y++) {
            const S = l[y] * 3;
            d[S] = a[y * 3],
            d[S + 1] = a[y * 3 + 1],
            d[S + 2] = a[y * 3 + 2]
        }
        const h = {
            vertexIndices: o,
            vertexPositions: d
        }
          , p = this.genBuffers(h)
          , m = new je(p.vertex,3);
        m.name = s || i.attrName,
        m.applyMatrix4(r),
        e.morphAttributes.position.push(m)
    }
    parseNormals(e) {
        const t = e.MappingInformationType
          , i = e.ReferenceInformationType
          , r = e.Normals.a;
        let s = [];
        return i === "IndexToDirect" && ("NormalIndex"in e ? s = e.NormalIndex.a : "NormalsIndex"in e && (s = e.NormalsIndex.a)),
        {
            dataSize: 3,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i
        }
    }
    parseUVs(e) {
        const t = e.MappingInformationType
          , i = e.ReferenceInformationType
          , r = e.UV.a;
        let s = [];
        return i === "IndexToDirect" && (s = e.UVIndex.a),
        {
            dataSize: 2,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i
        }
    }
    parseVertexColors(e) {
        const t = e.MappingInformationType
          , i = e.ReferenceInformationType
          , r = e.Colors.a;
        let s = [];
        i === "IndexToDirect" && (s = e.ColorIndex.a);
        for (let o = 0, a = new Oe; o < r.length; o += 4)
            a.fromArray(r, o).convertSRGBToLinear().toArray(r, o);
        return {
            dataSize: 4,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i
        }
    }
    parseMaterialIndices(e) {
        const t = e.MappingInformationType
          , i = e.ReferenceInformationType;
        if (t === "NoMappingInformation")
            return {
                dataSize: 1,
                buffer: [0],
                indices: [0],
                mappingType: "AllSame",
                referenceType: i
            };
        const r = e.Materials.a
          , s = [];
        for (let o = 0; o < r.length; ++o)
            s.push(o);
        return {
            dataSize: 1,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i
        }
    }
    parseNurbsGeometry(e) {
        const t = parseInt(e.Order);
        if (isNaN(t))
            return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id),
            new ft;
        const i = t - 1
          , r = e.KnotVector.a
          , s = []
          , o = e.Points.a;
        for (let h = 0, p = o.length; h < p; h += 4)
            s.push(new Ut().fromArray(o, h));
        let a, l;
        if (e.Form === "Closed")
            s.push(s[0]);
        else if (e.Form === "Periodic") {
            a = i,
            l = r.length - 1 - a;
            for (let h = 0; h < i; ++h)
                s.push(s[h])
        }
        const d = new Dj(i,r,s,a,l).getPoints(s.length * 12);
        return new ft().setFromPoints(d)
    }
}
class Oj {
    parse() {
        const e = []
          , t = this.parseClips();
        if (t !== void 0)
            for (const i in t) {
                const r = t[i]
                  , s = this.addClip(r);
                e.push(s)
            }
        return e
    }
    parseClips() {
        if (Pt.Objects.AnimationCurve === void 0)
            return;
        const e = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(e);
        const t = this.parseAnimationLayers(e);
        return this.parseAnimStacks(t)
    }
    parseAnimationCurveNodes() {
        const e = Pt.Objects.AnimationCurveNode
          , t = new Map;
        for (const i in e) {
            const r = e[i];
            if (r.attrName.match(/S|R|T|DeformPercent/) !== null) {
                const s = {
                    id: r.id,
                    attr: r.attrName,
                    curves: {}
                };
                t.set(s.id, s)
            }
        }
        return t
    }
    parseAnimationCurves(e) {
        const t = Pt.Objects.AnimationCurve;
        for (const i in t) {
            const r = {
                id: t[i].id,
                times: t[i].KeyTime.a.map(Hj),
                values: t[i].KeyValueFloat.a
            }
              , s = Mn.get(r.id);
            if (s !== void 0) {
                const o = s.parents[0].ID
                  , a = s.parents[0].relationship;
                a.match(/X/) ? e.get(o).curves.x = r : a.match(/Y/) ? e.get(o).curves.y = r : a.match(/Z/) ? e.get(o).curves.z = r : a.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = r)
            }
        }
    }
    parseAnimationLayers(e) {
        const t = Pt.Objects.AnimationLayer
          , i = new Map;
        for (const r in t) {
            const s = []
              , o = Mn.get(parseInt(r));
            o !== void 0 && (o.children.forEach(function(l, f) {
                if (e.has(l.ID)) {
                    const d = e.get(l.ID);
                    if (d.curves.x !== void 0 || d.curves.y !== void 0 || d.curves.z !== void 0) {
                        if (s[f] === void 0) {
                            const h = Mn.get(l.ID).parents.filter(function(p) {
                                return p.relationship !== void 0
                            })[0].ID;
                            if (h !== void 0) {
                                const p = Pt.Objects.Model[h.toString()];
                                if (p === void 0) {
                                    console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                                    return
                                }
                                const m = {
                                    modelName: p.attrName ? Ct.sanitizeNodeName(p.attrName) : "",
                                    ID: p.id,
                                    initialPosition: [0, 0, 0],
                                    initialRotation: [0, 0, 0],
                                    initialScale: [1, 1, 1]
                                };
                                bi.traverse(function(y) {
                                    y.ID === p.id && (m.transform = y.matrix,
                                    y.userData.transformData && (m.eulerOrder = y.userData.transformData.eulerOrder))
                                }),
                                m.transform || (m.transform = new $e),
                                "PreRotation"in p && (m.preRotation = p.PreRotation.value),
                                "PostRotation"in p && (m.postRotation = p.PostRotation.value),
                                s[f] = m
                            }
                        }
                        s[f] && (s[f][d.attr] = d)
                    } else if (d.curves.morph !== void 0) {
                        if (s[f] === void 0) {
                            const h = Mn.get(l.ID).parents.filter(function(g) {
                                return g.relationship !== void 0
                            })[0].ID
                              , p = Mn.get(h).parents[0].ID
                              , m = Mn.get(p).parents[0].ID
                              , y = Mn.get(m).parents[0].ID
                              , S = Pt.Objects.Model[y]
                              , M = {
                                modelName: S.attrName ? Ct.sanitizeNodeName(S.attrName) : "",
                                morphName: Pt.Objects.Deformer[h].attrName
                            };
                            s[f] = M
                        }
                        s[f][d.attr] = d
                    }
                }
            }),
            i.set(parseInt(r), s))
        }
        return i
    }
    parseAnimStacks(e) {
        const t = Pt.Objects.AnimationStack
          , i = {};
        for (const r in t) {
            const s = Mn.get(parseInt(r)).children;
            s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const o = e.get(s[0].ID);
            i[r] = {
                name: t[r].attrName,
                layer: o
            }
        }
        return i
    }
    addClip(e) {
        let t = [];
        const i = this;
        return e.layer.forEach(function(r) {
            t = t.concat(i.generateTracks(r))
        }),
        new rl(e.name,-1,t)
    }
    generateTracks(e) {
        const t = [];
        let i = new z
          , r = new In
          , s = new z;
        if (e.transform && e.transform.decompose(i, r, s),
        i = i.toArray(),
        r = new qi().setFromQuaternion(r, e.eulerOrder).toArray(),
        s = s.toArray(),
        e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
            const o = this.generateVectorTrack(e.modelName, e.T.curves, i, "position");
            o !== void 0 && t.push(o)
        }
        if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
            const o = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
            o !== void 0 && t.push(o)
        }
        if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
            const o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
            o !== void 0 && t.push(o)
        }
        if (e.DeformPercent !== void 0) {
            const o = this.generateMorphTrack(e);
            o !== void 0 && t.push(o)
        }
        return t
    }
    generateVectorTrack(e, t, i, r) {
        const s = this.getTimesForAllAxes(t)
          , o = this.getKeyframeTrackValues(s, t, i);
        return new il(e + "." + r,s,o)
    }
    generateRotationTrack(e, t, i, r, s, o) {
        t.x !== void 0 && (this.interpolateRotations(t.x),
        t.x.values = t.x.values.map(vr.degToRad)),
        t.y !== void 0 && (this.interpolateRotations(t.y),
        t.y.values = t.y.values.map(vr.degToRad)),
        t.z !== void 0 && (this.interpolateRotations(t.z),
        t.z.values = t.z.values.map(vr.degToRad));
        const a = this.getTimesForAllAxes(t)
          , l = this.getKeyframeTrackValues(a, t, i);
        r !== void 0 && (r = r.map(vr.degToRad),
        r.push(o),
        r = new qi().fromArray(r),
        r = new In().setFromEuler(r)),
        s !== void 0 && (s = s.map(vr.degToRad),
        s.push(o),
        s = new qi().fromArray(s),
        s = new In().setFromEuler(s).invert());
        const f = new In
          , d = new qi
          , h = [];
        for (let p = 0; p < l.length; p += 3)
            d.set(l[p], l[p + 1], l[p + 2], o),
            f.setFromEuler(d),
            r !== void 0 && f.premultiply(r),
            s !== void 0 && f.multiply(s),
            f.toArray(h, p / 3 * 4);
        return new no(e + ".quaternion",a,h)
    }
    generateMorphTrack(e) {
        const t = e.DeformPercent.curves.morph
          , i = t.values.map(function(s) {
            return s / 100
        })
          , r = bi.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
        return new nl(e.modelName + ".morphTargetInfluences[" + r + "]",t.times,i)
    }
    getTimesForAllAxes(e) {
        let t = [];
        if (e.x !== void 0 && (t = t.concat(e.x.times)),
        e.y !== void 0 && (t = t.concat(e.y.times)),
        e.z !== void 0 && (t = t.concat(e.z.times)),
        t = t.sort(function(i, r) {
            return i - r
        }),
        t.length > 1) {
            let i = 1
              , r = t[0];
            for (let s = 1; s < t.length; s++) {
                const o = t[s];
                o !== r && (t[i] = o,
                r = o,
                i++)
            }
            t = t.slice(0, i)
        }
        return t
    }
    getKeyframeTrackValues(e, t, i) {
        const r = i
          , s = [];
        let o = -1
          , a = -1
          , l = -1;
        return e.forEach(function(f) {
            if (t.x && (o = t.x.times.indexOf(f)),
            t.y && (a = t.y.times.indexOf(f)),
            t.z && (l = t.z.times.indexOf(f)),
            o !== -1) {
                const d = t.x.values[o];
                s.push(d),
                r[0] = d
            } else
                s.push(r[0]);
            if (a !== -1) {
                const d = t.y.values[a];
                s.push(d),
                r[1] = d
            } else
                s.push(r[1]);
            if (l !== -1) {
                const d = t.z.values[l];
                s.push(d),
                r[2] = d
            } else
                s.push(r[2])
        }),
        s
    }
    interpolateRotations(e) {
        for (let t = 1; t < e.values.length; t++) {
            const i = e.values[t - 1]
              , r = e.values[t] - i
              , s = Math.abs(r);
            if (s >= 180) {
                const o = s / 180
                  , a = r / o;
                let l = i + a;
                const f = e.times[t - 1]
                  , h = (e.times[t] - f) / o;
                let p = f + h;
                const m = []
                  , y = [];
                for (; p < e.times[t]; )
                    m.push(p),
                    p += h,
                    y.push(l),
                    l += a;
                e.times = BR(e.times, t, m),
                e.values = BR(e.values, t, y)
            }
        }
    }
}
class Fj {
    getPrevNode() {
        return this.nodeStack[this.currentIndent - 2]
    }
    getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1]
    }
    getCurrentProp() {
        return this.currentProp
    }
    pushStack(e) {
        this.nodeStack.push(e),
        this.currentIndent += 1
    }
    popStack() {
        this.nodeStack.pop(),
        this.currentIndent -= 1
    }
    setCurrentProp(e, t) {
        this.currentProp = e,
        this.currentPropName = t
    }
    parse(e) {
        this.currentIndent = 0,
        this.allNodes = new p3,
        this.nodeStack = [],
        this.currentProp = [],
        this.currentPropName = "";
        const t = this
          , i = e.split(/[\r\n]+/);
        return i.forEach(function(r, s) {
            const o = r.match(/^[\s\t]*;/)
              , a = r.match(/^[\s\t]*$/);
            if (o || a)
                return;
            const l = r.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", "")
              , f = r.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
              , d = r.match("^\\t{" + (t.currentIndent - 1) + "}}");
            l ? t.parseNodeBegin(r, l) : f ? t.parseNodeProperty(r, f, i[++s]) : d ? t.popStack() : r.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(r)
        }),
        this.allNodes
    }
    parseNodeBegin(e, t) {
        const i = t[1].trim().replace(/^"/, "").replace(/"$/, "")
          , r = t[2].split(",").map(function(l) {
            return l.trim().replace(/^"/, "").replace(/"$/, "")
        })
          , s = {
            name: i
        }
          , o = this.parseNodeAttr(r)
          , a = this.getCurrentNode();
        this.currentIndent === 0 ? this.allNodes.add(i, s) : i in a ? (i === "PoseNode" ? a.PoseNode.push(s) : a[i].id !== void 0 && (a[i] = {},
        a[i][a[i].id] = a[i]),
        o.id !== "" && (a[i][o.id] = s)) : typeof o.id == "number" ? (a[i] = {},
        a[i][o.id] = s) : i !== "Properties70" && (i === "PoseNode" ? a[i] = [s] : a[i] = s),
        typeof o.id == "number" && (s.id = o.id),
        o.name !== "" && (s.attrName = o.name),
        o.type !== "" && (s.attrType = o.type),
        this.pushStack(s)
    }
    parseNodeAttr(e) {
        let t = e[0];
        e[0] !== "" && (t = parseInt(e[0]),
        isNaN(t) && (t = e[0]));
        let i = ""
          , r = "";
        return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""),
        r = e[2]),
        {
            id: t,
            name: i,
            type: r
        }
    }
    parseNodeProperty(e, t, i) {
        let r = t[1].replace(/^"/, "").replace(/"$/, "").trim()
          , s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
        r === "Content" && s === "," && (s = i.replace(/"/g, "").replace(/,$/, "").trim());
        const o = this.getCurrentNode();
        if (o.name === "Properties70") {
            this.parseNodeSpecialProperty(e, r, s);
            return
        }
        if (r === "C") {
            const l = s.split(",").slice(1)
              , f = parseInt(l[0])
              , d = parseInt(l[1]);
            let h = s.split(",").slice(3);
            h = h.map(function(p) {
                return p.trim().replace(/^"/, "")
            }),
            r = "connections",
            s = [f, d],
            Wj(s, h),
            o[r] === void 0 && (o[r] = [])
        }
        r === "Node" && (o.id = s),
        r in o && Array.isArray(o[r]) ? o[r].push(s) : r !== "a" ? o[r] = s : o.a = s,
        this.setCurrentProp(o, r),
        r === "a" && s.slice(-1) !== "," && (o.a = l_(s))
    }
    parseNodePropertyContinued(e) {
        const t = this.getCurrentNode();
        t.a += e,
        e.slice(-1) !== "," && (t.a = l_(t.a))
    }
    parseNodeSpecialProperty(e, t, i) {
        const r = i.split('",').map(function(d) {
            return d.trim().replace(/^\"/, "").replace(/\s/, "_")
        })
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , l = r[3];
        let f = r[4];
        switch (o) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
            f = parseFloat(f);
            break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
            f = l_(f);
            break
        }
        this.getPrevNode()[s] = {
            type: o,
            type2: a,
            flag: l,
            value: f
        },
        this.setCurrentProp(this.getPrevNode(), s)
    }
}
class zj {
    parse(e) {
        const t = new FR(e);
        t.skip(23);
        const i = t.getUint32();
        if (i < 6400)
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
        const r = new p3;
        for (; !this.endOfContent(t); ) {
            const s = this.parseNode(t, i);
            s !== null && r.add(s.name, s)
        }
        return r
    }
    endOfContent(e) {
        return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
    }
    parseNode(e, t) {
        const i = {}
          , r = t >= 7500 ? e.getUint64() : e.getUint32()
          , s = t >= 7500 ? e.getUint64() : e.getUint32();
        t >= 7500 ? e.getUint64() : e.getUint32();
        const o = e.getUint8()
          , a = e.getString(o);
        if (r === 0)
            return null;
        const l = [];
        for (let p = 0; p < s; p++)
            l.push(this.parseProperty(e));
        const f = l.length > 0 ? l[0] : ""
          , d = l.length > 1 ? l[1] : ""
          , h = l.length > 2 ? l[2] : "";
        for (i.singleProperty = s === 1 && e.getOffset() === r; r > e.getOffset(); ) {
            const p = this.parseNode(e, t);
            p !== null && this.parseSubNode(a, i, p)
        }
        return i.propertyList = l,
        typeof f == "number" && (i.id = f),
        d !== "" && (i.attrName = d),
        h !== "" && (i.attrType = h),
        a !== "" && (i.name = a),
        i
    }
    parseSubNode(e, t, i) {
        if (i.singleProperty === !0) {
            const r = i.propertyList[0];
            Array.isArray(r) ? (t[i.name] = i,
            i.a = r) : t[i.name] = r
        } else if (e === "Connections" && i.name === "C") {
            const r = [];
            i.propertyList.forEach(function(s, o) {
                o !== 0 && r.push(s)
            }),
            t.connections === void 0 && (t.connections = []),
            t.connections.push(r)
        } else if (i.name === "Properties70")
            Object.keys(i).forEach(function(s) {
                t[s] = i[s]
            });
        else if (e === "Properties70" && i.name === "P") {
            let r = i.propertyList[0]
              , s = i.propertyList[1];
            const o = i.propertyList[2]
              , a = i.propertyList[3];
            let l;
            r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")),
            s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")),
            s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? l = [i.propertyList[4], i.propertyList[5], i.propertyList[6]] : l = i.propertyList[4],
            t[r] = {
                type: s,
                type2: o,
                flag: a,
                value: l
            }
        } else
            t[i.name] === void 0 ? typeof i.id == "number" ? (t[i.name] = {},
            t[i.name][i.id] = i) : t[i.name] = i : i.name === "PoseNode" ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]),
            t[i.name].push(i)) : t[i.name][i.id] === void 0 && (t[i.name][i.id] = i)
    }
    parseProperty(e) {
        const t = e.getString(1);
        let i;
        switch (t) {
        case "C":
            return e.getBoolean();
        case "D":
            return e.getFloat64();
        case "F":
            return e.getFloat32();
        case "I":
            return e.getInt32();
        case "L":
            return e.getInt64();
        case "R":
            return i = e.getUint32(),
            e.getArrayBuffer(i);
        case "S":
            return i = e.getUint32(),
            e.getString(i);
        case "Y":
            return e.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
            const r = e.getUint32()
              , s = e.getUint32()
              , o = e.getUint32();
            if (s === 0)
                switch (t) {
                case "b":
                case "c":
                    return e.getBooleanArray(r);
                case "d":
                    return e.getFloat64Array(r);
                case "f":
                    return e.getFloat32Array(r);
                case "i":
                    return e.getInt32Array(r);
                case "l":
                    return e.getInt64Array(r)
                }
            const a = Ej(new Uint8Array(e.getArrayBuffer(o)))
              , l = new FR(a.buffer);
            switch (t) {
            case "b":
            case "c":
                return l.getBooleanArray(r);
            case "d":
                return l.getFloat64Array(r);
            case "f":
                return l.getFloat32Array(r);
            case "i":
                return l.getInt32Array(r);
            case "l":
                return l.getInt64Array(r)
            }
            break;
        default:
            throw new Error("THREE.FBXLoader: Unknown property type " + t)
        }
    }
}
class FR {
    constructor(e, t) {
        this.dv = new DataView(e),
        this.offset = 0,
        this.littleEndian = t !== void 0 ? t : !0,
        this._textDecoder = new TextDecoder
    }
    getOffset() {
        return this.offset
    }
    size() {
        return this.dv.buffer.byteLength
    }
    skip(e) {
        this.offset += e
    }
    getBoolean() {
        return (this.getUint8() & 1) === 1
    }
    getBooleanArray(e) {
        const t = [];
        for (let i = 0; i < e; i++)
            t.push(this.getBoolean());
        return t
    }
    getUint8() {
        const e = this.dv.getUint8(this.offset);
        return this.offset += 1,
        e
    }
    getInt16() {
        const e = this.dv.getInt16(this.offset, this.littleEndian);
        return this.offset += 2,
        e
    }
    getInt32() {
        const e = this.dv.getInt32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getInt32Array(e) {
        const t = [];
        for (let i = 0; i < e; i++)
            t.push(this.getInt32());
        return t
    }
    getUint32() {
        const e = this.dv.getUint32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getInt64() {
        let e, t;
        return this.littleEndian ? (e = this.getUint32(),
        t = this.getUint32()) : (t = this.getUint32(),
        e = this.getUint32()),
        t & 2147483648 ? (t = ~t & 4294967295,
        e = ~e & 4294967295,
        e === 4294967295 && (t = t + 1 & 4294967295),
        e = e + 1 & 4294967295,
        -(t * 4294967296 + e)) : t * 4294967296 + e
    }
    getInt64Array(e) {
        const t = [];
        for (let i = 0; i < e; i++)
            t.push(this.getInt64());
        return t
    }
    getUint64() {
        let e, t;
        return this.littleEndian ? (e = this.getUint32(),
        t = this.getUint32()) : (t = this.getUint32(),
        e = this.getUint32()),
        t * 4294967296 + e
    }
    getFloat32() {
        const e = this.dv.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getFloat32Array(e) {
        const t = [];
        for (let i = 0; i < e; i++)
            t.push(this.getFloat32());
        return t
    }
    getFloat64() {
        const e = this.dv.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8,
        e
    }
    getFloat64Array(e) {
        const t = [];
        for (let i = 0; i < e; i++)
            t.push(this.getFloat64());
        return t
    }
    getArrayBuffer(e) {
        const t = this.dv.buffer.slice(this.offset, this.offset + e);
        return this.offset += e,
        t
    }
    getString(e) {
        const t = this.offset;
        let i = new Uint8Array(this.dv.buffer,t,e);
        this.skip(e);
        const r = i.indexOf(0);
        return r >= 0 && (i = new Uint8Array(this.dv.buffer,t,r)),
        this._textDecoder.decode(i)
    }
}
class p3 {
    add(e, t) {
        this[e] = t
    }
}
function Bj(n) {
    const e = "Kaydara FBX Binary  \0";
    return n.byteLength >= e.length && e === v3(n, 0, e.length)
}
function Vj(n) {
    const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
    let t = 0;
    function i(r) {
        const s = n[r - 1];
        return n = n.slice(t + r),
        t++,
        s
    }
    for (let r = 0; r < e.length; ++r)
        if (i(1) === e[r])
            return !1;
    return !0
}
function zR(n) {
    const e = /FBXVersion: (\d+)/
      , t = n.match(e);
    if (t)
        return parseInt(t[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
}
function Hj(n) {
    return n / 46186158e3
}
const Gj = [];
function Jp(n, e, t, i) {
    let r;
    switch (i.mappingType) {
    case "ByPolygonVertex":
        r = n;
        break;
    case "ByPolygon":
        r = e;
        break;
    case "ByVertice":
        r = t;
        break;
    case "AllSame":
        r = i.indices[0];
        break;
    default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType)
    }
    i.referenceType === "IndexToDirect" && (r = i.indices[r]);
    const s = r * i.dataSize
      , o = s + i.dataSize;
    return Xj(Gj, i.buffer, s, o)
}
const a_ = new qi
  , nc = new z;
function m3(n) {
    const e = new $e
      , t = new $e
      , i = new $e
      , r = new $e
      , s = new $e
      , o = new $e
      , a = new $e
      , l = new $e
      , f = new $e
      , d = new $e
      , h = new $e
      , p = new $e
      , m = n.inheritType ? n.inheritType : 0;
    if (n.translation && e.setPosition(nc.fromArray(n.translation)),
    n.preRotation) {
        const L = n.preRotation.map(vr.degToRad);
        L.push(n.eulerOrder || qi.DEFAULT_ORDER),
        t.makeRotationFromEuler(a_.fromArray(L))
    }
    if (n.rotation) {
        const L = n.rotation.map(vr.degToRad);
        L.push(n.eulerOrder || qi.DEFAULT_ORDER),
        i.makeRotationFromEuler(a_.fromArray(L))
    }
    if (n.postRotation) {
        const L = n.postRotation.map(vr.degToRad);
        L.push(n.eulerOrder || qi.DEFAULT_ORDER),
        r.makeRotationFromEuler(a_.fromArray(L)),
        r.invert()
    }
    n.scale && s.scale(nc.fromArray(n.scale)),
    n.scalingOffset && a.setPosition(nc.fromArray(n.scalingOffset)),
    n.scalingPivot && o.setPosition(nc.fromArray(n.scalingPivot)),
    n.rotationOffset && l.setPosition(nc.fromArray(n.rotationOffset)),
    n.rotationPivot && f.setPosition(nc.fromArray(n.rotationPivot)),
    n.parentMatrixWorld && (h.copy(n.parentMatrix),
    d.copy(n.parentMatrixWorld));
    const y = t.clone().multiply(i).multiply(r)
      , S = new $e;
    S.extractRotation(d);
    const M = new $e;
    M.copyPosition(d);
    const g = M.clone().invert().multiply(d)
      , _ = S.clone().invert().multiply(g)
      , w = s
      , T = new $e;
    if (m === 0)
        T.copy(S).multiply(y).multiply(_).multiply(w);
    else if (m === 1)
        T.copy(S).multiply(_).multiply(y).multiply(w);
    else {
        const Y = new $e().scale(new z().setFromMatrixScale(h)).clone().invert()
          , Z = _.clone().multiply(Y);
        T.copy(S).multiply(y).multiply(Z).multiply(w)
    }
    const A = f.clone().invert()
      , C = o.clone().invert();
    let P = e.clone().multiply(l).multiply(f).multiply(t).multiply(i).multiply(r).multiply(A).multiply(a).multiply(o).multiply(s).multiply(C);
    const N = new $e().copyPosition(P)
      , b = d.clone().multiply(N);
    return p.copyPosition(b),
    P = p.clone().multiply(T),
    P.premultiply(d.invert()),
    P
}
function g3(n) {
    n = n || 0;
    const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return n === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
    e[0]) : e[n]
}
function l_(n) {
    return n.split(",").map(function(t) {
        return parseFloat(t)
    })
}
function v3(n, e, t) {
    return e === void 0 && (e = 0),
    t === void 0 && (t = n.byteLength),
    new TextDecoder().decode(new Uint8Array(n,e,t))
}
function Wj(n, e) {
    for (let t = 0, i = n.length, r = e.length; t < r; t++,
    i++)
        n[i] = e[t]
}
function Xj(n, e, t, i) {
    for (let r = t, s = 0; r < i; r++,
    s++)
        n[s] = e[r];
    return n
}
function BR(n, e, t) {
    return n.slice(0, e).concat(t).concat(n.slice(e))
}
const $j = ()=>{
    const n = Rr(_w, "/lavacon.fbx")
      , [e,t] = ke.useState([]);
    return ke.useEffect(()=>{
        const i = fj.map(r=>{
            const s = n.clone();
            return s.traverse(o=>{
                o.castShadow = !0,
                o.receiveShadow = !0
            }
            ),
            s.scale.set(3, 3, 3),
            s.position.set(r.x, r.y, r.z),
            s.rotation.set(0, -Math.PI / 2, 0),
            s
        }
        );
        t(i)
    }
    , []),
    ct(hS, {
        children: e.map(i=>ct("primitive", {
            object: i
        }, i.id))
    })
}
  , jj = ()=>{
    const n = Rr(_w, "/arcade.fbx");
    return n.scale.set(.05, .05, .05),
    n.position.set(22, 0, -22),
    n.rotation.set(0, -Math.PI / 4, 0),
    n.name = "arcade",
    ct("primitive", {
        object: n
    })
}
  , Yj = ()=>{
    const n = Rr(_w, "/basketball.fbx").clone();
    return n.scale.set(.1, .1, .1),
    n.position.set(19, .5, -19),
    n.traverse(e=>{
        e.castShadow = !0,
        e.receiveShadow = !0
    }
    ),
    ZI(()=>{
        n.rotation.y += .03
    }
    ),
    ct("primitive", {
        object: n
    })
}
  , qj = 180 / Math.PI;
function Kj(n) {
    return n * qj
}
const Zj = ()=>{
    const n = KI();
    return ke.useEffect(()=>{
        const e = n.scene.getObjectByName("arcade");
        if (e) {
            const t = document.querySelector(".arcade");
            if (t) {
                const i = r3(e.position);
                t.style.transform = `translate(${i.x}px,${i.y}px) rotate(${Kj(e.rotation.y)}deg)`
            }
        }
    }
    , []),
    null
}
  , Qj = ()=>{
    const n = window.innerWidth / window.innerHeight;
    return es(w$, {
        gl: {
            antialias: !0
        },
        shadows: {
            enabled: !0,
            autoUpdate: !0,
            type: bc
        },
        orthographic: !0,
        camera: {
            zoom: 50,
            position: [1, 5, 5],
            left: -1 * n,
            right: 1 * n,
            top: 1,
            bottom: -1,
            near: -1e3,
            far: 1e3
        },
        children: [ct(sj, {}), ct(T$, {}), ["top", "right", "bottom", "left"].map(e=>ct(oj, {
            side: e,
            width: 50,
            depth: 1,
            height: 6
        }, e)), ct(E$, {}), ct(rj, {}), ct(aj, {}), ct(dj, {}), ct(lj, {}), uj.map(({name: e, position: t, width: i, depth: r, height: s, rotation: o})=>ct(cj, {
            name: e,
            url: `/images/${e}.png`,
            position: t,
            rotation: o,
            width: i,
            depth: r,
            height: s
        }, e)), ct(A$, {}), ct(Yj, {}), ct(jj, {}), ct($j, {}), ct(Zj, {})]
    })
}
  , Jj = ()=>RH(kP) === b1.ORTHOGONAL ? ct(Qj, {}) : ct("div", {
    children: "hi"
})
  , eY = "이곳은 Jay가 능숙하게 다루는 툴들을 모아둔 곳이에요. 천천히 둘러보세요.!. 혹시나 추가했으면 하는 궁금한 점이 있다면, 제 Velog에 댓글로 남겨주시면 감사하겠습니다."
  , tY = "이곳은 간단한 미니게임방으로 연결되는 통로입니다. 하지만 아직 준비중입니다.!"
  , nY = cl.div`
  width: 1000px;
  height: 200px;
  position: absolute;
  top: 0;
  left: 0;
  background-color: #ddddddee;
  display: none;
  border-radius: 10px;
  padding: 10px 15px;
  user-select: none;
  @media (max-width: 500px) {
    width: 400px;
    height: 60px;
    border-radius: 4px;
    padding: 2px 3px;
  }
`
  , iY = cl.span`
  font-size: 32px;
  color: #000;
  user-select: none;
  @media (max-width: 500px) {
    font-size: 14px;
  }
`
  , rY = ()=>{
    gx(kP);
    const [n,e] = gx(OP)
      , t = ke.useRef(null)
      , i = ke.useRef(null);
    ke.useEffect(()=>{
        const s = t.current
          , o = ()=>{
            s && (s.style.transform = `translate(${window.innerWidth / 2 - (window.innerWidth > 500 ? 500 : 200)}px,${window.innerHeight - (window.innerWidth > 500 ? 300 : 120)}px)`)
        }
        ;
        return o(),
        window.addEventListener("resize", o),
        ()=>{
            window.removeEventListener("resize", o)
        }
    }
    , []);
    const r = (s,o)=>{
        let a;
        for (let l = 0; l < s.length; l += 1)
            a = setTimeout(()=>{
                o.innerHTML += s[l]
            }
            , (l + 1) * 80);
        return a
    }
    ;
    return ke.useEffect(()=>{
        if (n === 0)
            return;
        const s = i.current;
        if (!s)
            return ()=>{}
            ;
        s.innerHTML = "";
        let o;
        return n === 1 ? o = r(eY, s) : n === 2 && (o = r(tY, s)),
        ()=>{
            o && clearTimeout(o)
        }
    }
    , [n]),
    ct(nY, {
        className: "dialog-wrapper",
        ref: t,
        children: n !== 0 && ct(iY, {
            ref: i
        })
    })
}
  , sY = cl.div`
  width: 100px;
  height: 100px;
  position: absolute;
  top: 0;
  left: 0;
  background-color: #333333cc;
`
  , oY = cl.div`
  width: 10px;
  height: 10px;
  border-radius: 50%;
  top: 10px;
  left: 10px;
  background-color: red;
`
  , aY = cl.div`
  width: 10px;
  height: 10px;
  top: 0;
  left: 0;
  &.arcade {
    background-color: blue;
  }
`
  , VR = cl.div`
  position: absolute;

  &.logo {
    width: 50px;
    height: 50px;
    top: 0;
    left: 0;
    background-color: #f0ff0055;
  }
  &.game {
    width: 25px;
    height: 25px;
    top: 0px;
    left: 75px;
    background-color: #00ff0055;
  }
`
  , lY = ()=>es(sY, {
    children: [ct(oY, {
        id: "current-position-circle"
    }), ct(VR, {
        className: "logo"
    }), ct(VR, {
        className: "game"
    }), ct(aY, {
        className: "arcade"
    })]
})
  , cY = ()=>es(hS, {
    children: [ct(lY, {}), ct(rY, {})]
})
  , uY = cl.div`
  width: 100vw;
  height: 100vh;
  background-color: #000;
  outline: none;
`;
function fY() {
    return ct(AH, {
        children: es(uY, {
            children: [ct(Jj, {}), ct(cY, {})]
        })
    })
}
c_.createRoot(document.getElementById("root")).render(ct(Wt.StrictMode, {
    children: ct(fY, {})
}));
